---
title: Java 线程池
tags: 
- Java
categories: 
- Java
date: 2022-08-23
permalink: /java/thread-threadpool.html
---

[美团线程池文章](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

## 为什么需要线程池

池化技术一般是为了解决由于频繁的对象创建、连接创建导致的性能问题，如数据库连接池、HTTP连接池、JVM线程池等。通过池化技术，固定维持一批连接或者线程对象，重复利用这些对象，避免频繁的创建和销毁，从而提高效率。

Java中提供了以 Executor 为顶级接口的线程池规范和实现。

线程池解决两个不同的问题：

它们通常在执行大量异步任务时提供更好的性能，这是因为减少了每个任务的调用开销；

它们还提供了一种方法，用于限制和管理执行任务集合时消耗的资源，包括线程。

## Executor

线程池的顶层接口是 Executor 。**Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分**

Executor相比显式的线程创建更加常用。比如，当你为一系列任务创建线程并启动的时候，你可以不用 `new Thread(new RunnableTask()).start()`，而是用Executor，如下所示

```java
Executor executor = anExecutor;
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
```

Executor 并没有严格要求任务异步执行，支持在当前线程中马上执行提交的任务

```java
class DirectExecutor implements Executor {
  public void execute(Runnable r) {
    r.run();
  }
}
```

但是更多的场景下，任务在调用方线程之外的其他线程中执行。下面的执行器为每个任务生成一个新线程。

```java
class ThreadPerTaskExecutor implements Executor {
  public void execute(Runnable r) {
    new Thread(r).start();
  }
}
```

许多Executor实现类对如何和何时调度任务施加了某些限制。如下面的Executor将任务的提交交给第二个执行器，该Executor是一个复合executor。

```java
class SerialExecutor implements Executor {
   final Queue<Runnable> tasks = new ArrayDeque<Runnable>();
   final Executor executor;
   Runnable active;

   SerialExecutor(Executor executor) {
     this.executor = executor;
   }

   public synchronized void execute(final Runnable r) {
     tasks.offer(new Runnable() {
       public void run() {
         try {
           r.run();
         } finally {
           scheduleNext();
         }
       }
     });
     if (active == null) {
       scheduleNext();
     }
   }

   protected synchronized void scheduleNext() {
     if ((active = tasks.poll()) != null) {
       executor.execute(active);
     }
   }
 }
```

## ExecutorService

JDK中提供了Executor的继承接口ExecutorService。ThreadPoolExecutor类提供了一个可扩展的线程池实现。Executors类为这些Executor类提供了方便的工厂方法。

内存一致性影响: 将Runnable对象提交给Executor的动作 happens-before Runnable对象开始执行的动作。

### 方法 execute()

在将来的某个时间执行给定的命令。该命令可以在新线程、线程池中的线程或调用线程中执行，这取决于Executor的实现类。

> 注意：execute()方法没有返回值

```java
void execute(Runnable command);
```

### this逃逸问题

如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象。


ExecutorService接口，继承自Executor，在 execute() 方法的基础上提供了更丰富的能力。

它提供了管理终止的方法，并提供了方法生成Future，用于跟踪一个或多个异步任务的进度。

ExecutorService 提供了线程池关闭的方法 shutdown() 和 shutdownNow()，关闭之后线程池将拒绝新任务的提交。

shutdown() 方法将允许之前提交的任务在终止之前执行；

shutdownNow()方法将阻止等待的任务启动，并尝试停止当前正在执行的任务。

在终止时，执行器没有正在执行的任务，没有等待执行的任务，也没有新的任务可以提交。未使用的ExecutorService应该被关闭，以允许回收其资源。

方法提交通过创建并返回一个Future来扩展基本方法 Executor.execute(Runnable)，该Future可用于取消执行或等待执行完成。方法invokeAny和invokeAll批量执行一组任务，然后等待至少一个或全部任务完成。(ExecutorCompletionService类可以用来编写这些方法的自定义变体。)

Executors类为这个包中的执行器服务提供工厂方法。

### 使用案例

下面是一个网络服务的示意图，其中线程池中的线程处理传入的请求。它使用预配置的 Executors.newFixedThreadPool(int) 工厂方法:

```java
class NetworkService implements Runnable {
   private final ServerSocket serverSocket;
   private final ExecutorService pool;

   public NetworkService(int port, int poolSize) throws IOException {
     serverSocket = new ServerSocket(port);
     pool = Executors.newFixedThreadPool(poolSize);
   }

   public void run() { // run the service
     try {
       for (;;) {
         pool.execute(new Handler(serverSocket.accept()));
       }
     } catch (IOException ex) {
       pool.shutdown();
     }
   }
 }

 class Handler implements Runnable {
   private final Socket socket;
   Handler(Socket socket) { this.socket = socket; }
   public void run() {
     // read and service request on socket
   }
 }
```

下面的方法分两个阶段关闭ExecutorService，首先通过调用shutdown来拒绝传入的任务，然后在必要时调用shutdownNow来取消任何滞留的任务:

```java
 void shutdownAndAwaitTermination(ExecutorService pool) {
   pool.shutdown(); // Disable new tasks from being submitted
   try {
     // Wait a while for existing tasks to terminate
     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
       pool.shutdownNow(); // Cancel currently executing tasks
       // Wait a while for tasks to respond to being cancelled
       if (!pool.awaitTermination(60, TimeUnit.SECONDS))
           System.err.println("Pool did not terminate");
     }
   } catch (InterruptedException ie) {
     // (Re-)Cancel if current thread also interrupted
     pool.shutdownNow();
     // Preserve interrupt status
     Thread.currentThread().interrupt();
   }
 }
```

内存一致性影响: ExecutorService提交 Runnable 或 Callable 任务的操作 happens-before 发生在该任务执行任何操作之前，同时 执行任务的操作 happen-before 通过 Future.get() 获取结果。

### shutdown() 方法

启动有序关闭，以便执行先前提交的任务，但不会接受新任务。如果已关闭，调用没有额外的效果。

此方法不等待以前提交的任务完成执行。使用awaitTermination()做到这一点。

如果存在安全管理器并关闭此ExecutorService可能会操纵呼叫者不允许修改的线程，因为它不包含RuntimEpermission（“ModifyThread”），或者安全管理器的CheckAccess方法拒绝访问。

### shutdownNow()方法

尝试停止所有正在执行的任务，停止处理等待任务，并返回正在等待执行的任务列表。

此方法不等待正在执行的任务终止。使用awaitTermination()做到这一点。

这个方法不保证尽最大努力去停止执行中的任务。比如，实现类通常通过 Thread.interrupt() 方法进行退出，但是无法响应终端的任务可能永远不会停止。

### isShutdown()方法

检查线程池是否已经关闭，如果已关闭，则返回TRUE。

### isTerminated()方法

如果所有任务已关闭，请返回True。请注意，除非shutdown 或 shutdownNow首次被调用，否则isTerminated()永远不会为true。

### awaitTermination()方法

在线程池执行关闭操作、线程处理超时、处理线程被中断等条件发生之后，一直阻塞，直到线程池中的所有任务都执行完成。

timeout 最大等待时间

### Submit() 方法

submit有3个重载的方法

```java
- <T> Future<T> submit(Callable<T> task)
- <T> Future<T> submit(Runnable task, T result)
- Future<?> submit(Runnable task)

<T> Future<T> submit(Callable<T> task) 
```

提交一个带返回值的任务，并返回Future对象去获取待执行任务的结果。执行成功后，可通过Future的 get() 方法获取任务结果。

如果你希望马上阻塞等待任务执行，你可以通过这种方式来进行：

```java
result = exec.submit(aCallable).get()
```

Executors类包括一组方法，可以转换其他一些常见的闭包类对象，例如，将[`PrivilegedAction`](https://docs.oracle.com/javase/8/docs/api/java/security/PrivilegedAction.html) 转换成 Callable，以便能直接提交。

```java
<T> Future<T> submit(Runnable task, T result) 
```

直接提交一个Runnable类型任务，并等待执行，返回类型由调用方进行指定。

```java
Future<?> submit(Runnable task)
```

也是提交一个Runnable类型的任务，不同之处在于Future的get()方法会返回null。

### invoke方法

提供了四个invoke方法

```java
- <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
- <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
- <T> T invokeAny(Collection<? extends Callable<T>> tasks)
- <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)

<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
```

执行给定的任务，当所有任务完成时，返回一个保存其状态和结果的Future列表。对于列表中的每一个元素，Future.isDone()都返回true。

请注意，已完成的任务可以正常终止，也可以通过引发异常终止。如果在执行此操作时修改了给定集合，则此方法的结果是不确定的。

```java
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
```

## AbstractExecutorService

AbstractExecutorService是ExecutorService的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。

提供ExecutorService执行方法的默认实现。此类使用 newTaskFor返回的RunnableFuture实现submit、invokeAny和invokeAll方法，JDK中提供了FutureTask类作为RunnableFuture的实现类。例如，submit(Runnable) 的实现会创建一个关联的 RunnableFuture，并执行和返回。子类可以重写newTaskFor方法，以返回除FutureTask以外的RunnableFuture实现。

扩展示例：

下面是一个示例，该类自定义ThreadPoolExecutor以使用CustomTask类而不是默认的FutureTask：

```java
 public class CustomThreadPoolExecutor extends ThreadPoolExecutor {

   static class CustomTask<V> implements RunnableFuture<V> {...}

   protected <V> RunnableFuture<V> newTaskFor(Callable<V> c) {
       return new CustomTask<V>(c);
   }
   protected <V> RunnableFuture<V> newTaskFor(Runnable r, V v) {
       return new CustomTask<V>(r, v);
   }
   // ... add constructors, etc.
 }
```

代码解析

### newTaskFor

```java
//返回给定Runnable和默认值的RunnableFuture
protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
	return new FutureTask<T>(runnable, value);
}
//返回给定可调用任务的RunnableFuture
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
  return new FutureTask<T>(callable);
}
```

### submit方法

```java
//提交可运行任务以执行，并返回表示该任务的Future对象。Future的get方法在成功完成后将返回null。
public Future<?> submit(Runnable task) {
  //判空
  if (task == null) throw new NullPointerException();
  //调用newTaskFor方法返回RunnableFuture
  RunnableFuture<Void> ftask = newTaskFor(task, null);
  //提交任务
  execute(ftask);
  return ftask;
}
//Future的get方法将在成功完成后返回给定的结果。
public <T> Future<T> submit(Runnable task, T result) {
  //判空
  if (task == null) throw new NullPointerException();
  //调用newTaskFor方法返回RunnableFuture
  RunnableFuture<T> ftask = newTaskFor(task, result);
  //提交任务
  execute(ftask);
  return ftask;
}
//提交一个返回值的任务以供执行，并返回一个表示任务挂起结果的Future。Future的get方法将在成功完成后返回任务的结果。
//如果要立即阻止等待任务，可以使用 result = exec.submit(aCallable).get()
//注意：Executors类包括一组方法，可以将其他一些常见的闭包类对象（例如PrivilegedAction）转换为可调用形式，以便提交。
public <T> Future<T> submit(Callable<T> task) {
  //判空
  if (task == null) throw new NullPointerException();
  //调用newTaskFor方法返回RunnableFuture
  RunnableFuture<T> ftask = newTaskFor(task);
  //提交任务
  execute(ftask);
  return ftask;
}
```

### invoke方法

```java
//执行给定的任务，返回已成功完成的任务的结果（即，不引发异常），如果有的话。正常或异常返回后，尚未完成的任务将被取消。如果在执行此操作时修改了给定集合，则此方法的结果是未定义的。
public <T> T invokeAny(Collection<? extends Callable<T>> tasks) 
  throws InterruptedException, ExecutionException {
  try {
    return doInvokeAny(tasks, false, 0);
  } catch (TimeoutException cannotHappen) {
    assert false;
    return null;
  }
}

//invokeAny的主要实现
private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,
                          boolean timed, long nanos)
  throws InterruptedException, ExecutionException, TimeoutException {
  //空的任务列表，NPE
  if (tasks == null)
    throw new NullPointerException();
  //获取任务的数量
  int ntasks = tasks.size();
  //任务数量为0，IllegalArgumentException
  if (ntasks == 0)
    throw new IllegalArgumentException();
  //创建对应的Future列表
  ArrayList<Future<T>> futures = new ArrayList<Future<T>>(ntasks);
  //创建
  ExecutorCompletionService<T> ecs = new ExecutorCompletionService<T>(this);

  // For efficiency, especially in executors with limited
  // parallelism, check to see if previously submitted tasks are
  // done before submitting more of them. This interleaving
  // plus the exception mechanics account for messiness of main
  // loop.

  try {
    // Record exceptions so that if we fail to obtain any
    // result, we can throw the last exception we got.
    ExecutionException ee = null;
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    Iterator<? extends Callable<T>> it = tasks.iterator();

    // Start one task for sure; the rest incrementally
    futures.add(ecs.submit(it.next()));
    --ntasks;
    int active = 1;

    for (;;) {
      Future<T> f = ecs.poll();
      if (f == null) {
        if (ntasks > 0) {
          --ntasks;
          futures.add(ecs.submit(it.next()));
          ++active;
        }
        else if (active == 0)
          break;
        else if (timed) {
          f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
          if (f == null)
            throw new TimeoutException();
          nanos = deadline - System.nanoTime();
        }
        else
          f = ecs.take();
      }
      if (f != null) {
        --active;
        try {
          return f.get();
        } catch (ExecutionException eex) {
          ee = eex;
        } catch (RuntimeException rex) {
          ee = new ExecutionException(rex);
        }
      }
    }

    if (ee == null)
      ee = new ExecutionException();
    throw ee;

  } finally {
    for (int i = 0, size = futures.size(); i < size; i++)
      futures.get(i).cancel(true);
  }
}

public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                       long timeout, TimeUnit unit)
  throws InterruptedException, ExecutionException, TimeoutException {
  return doInvokeAny(tasks, true, unit.toNanos(timeout));
}
public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
  throws InterruptedException {
  if (tasks == null)
    throw new NullPointerException();
  ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
  boolean done = false;
  try {
    for (Callable<T> t : tasks) {
      RunnableFuture<T> f = newTaskFor(t);
      futures.add(f);
      execute(f);
    }
    for (int i = 0, size = futures.size(); i < size; i++) {
      Future<T> f = futures.get(i);
      if (!f.isDone()) {
        try {
          f.get();
        } catch (CancellationException ignore) {
        } catch (ExecutionException ignore) {
        }
      }
    }
    done = true;
    return futures;
  } finally {
    if (!done)
      for (int i = 0, size = futures.size(); i < size; i++)
        futures.get(i).cancel(true);
  }
}

public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                     long timeout, TimeUnit unit)
  throws InterruptedException {
  if (tasks == null)
    throw new NullPointerException();
  long nanos = unit.toNanos(timeout);
  ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
  boolean done = false;
  try {
    for (Callable<T> t : tasks)
      futures.add(newTaskFor(t));

    final long deadline = System.nanoTime() + nanos;
    final int size = futures.size();

    // Interleave time checks and calls to execute in case
    // executor doesn't have any/much parallelism.
    for (int i = 0; i < size; i++) {
      execute((Runnable)futures.get(i));
      nanos = deadline - System.nanoTime();
      if (nanos <= 0L)
        return futures;
    }

    for (int i = 0; i < size; i++) {
      Future<T> f = futures.get(i);
      if (!f.isDone()) {
        if (nanos <= 0L)
          return futures;
        try {
          f.get(nanos, TimeUnit.NANOSECONDS);
        } catch (CancellationException ignore) {
        } catch (ExecutionException ignore) {
        } catch (TimeoutException toe) {
          return futures;
        }
        nanos = deadline - System.nanoTime();
      }
    }
    done = true;
    return futures;
  } finally {
    if (!done)
      for (int i = 0, size = futures.size(); i < size; i++)
        futures.get(i).cancel(true);
  }
}
```



## ThreadPoolExecutor

ExecutorService的实现类，线程池的核心实现。ThreadPoolExecutor 中对于线程池的线程数、工作队列和拒绝策略进行定义，同时还提供了线程池的管理方法，如关闭线程池、中断线程池等，此外还维护一些基本统计信息，例如已完成任务的数量。

JDK 中也提供了 Executors 工厂类来创建线程池

| 方法名 | 说明 |
| --- | --- |
| newCachedThreadPool()  | 无限线程池，具有自动线程回收的功能 |
| newFixedThreadPool(int)  | 固定大小的线程池 |
| newSingleThreadExecutor()  | 单后台线程 |
| newScheduledThreadPool() | 定时执行的线程池 |
| newSingleThreadScheduledExecutor() | 定时执行的线程池，但是只有一个线程 |

但是不建议直接使用 Executors 工厂类来创建线程池，比如 newFixedThreadPool 使用的是无界的 LinkedBlockingQueue ，可能会导致 OOM。

如果要自定义线程池参数，请参考核心参数的章节。

### ctl 属性

Java线程池的核心控制状态ctl是一个原子整数（AtomicInteger），它通过位操作将workerCount 和 runState 两个概念字段打包在一个32位整数中：

1. ​高3位​​表示线程池状态（runState）
2. 低29位​​表示工作线程数（workerCount），最大支持(2^29)-1(大约5亿)个线程

#### workerCount

workerCount，指示线程的有效数量。 workerCount是允许启动和不允许停止的工作线程数量。该值可能暂时不同于活动线程的实际数量，例如正在退出的线程在终止前仍在执行任务时。用户可见的池大小是工作集的当前大小。

#### runState

runState，指示线程是否运行、关闭等

| 状态 | 二进制高3位 | 十进制值 | 描述 |
|------|------------|----------|------|
| RUNNING | 111 | -536870912 | 接受新任务并处理队列任务（初始化默认状态） |
| SHUTDOWN | 000 | 0 | 拒绝新任务但处理队列任务（调用shutdown()触发） |
| STOP | 001 | 536870912 | 拒绝新任务、中断进行中任务、丢弃队列任务（调用shutdownNow()触发） |
| TIDYING | 010 | 1073741824 | 所有任务终止，准备执行terminated()钩子方法 |
| TERMINATED | 011 | 1610612736 | terminated()方法执行完成 |

线程池状态流转

![1749470143179.png](https://cdn4.winhlb.com/2025/06/09/6846cbc1b477d.png)

状态值严格递增（RUNNING < SHUTDOWN < STOP < TIDYING < TERMINATED），便于直接通过整数比较判断状态，比如 `isRunning(int c)` 方法通过比较c < SHUTDOWN（即数值是否小于0）判断是否处于RUNNING状态。

```java
//前3位是runStatus  后29位是workerCount
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//计算workerCount的位数，Integer.SIZE=32,则COUNT_BITS=29，workerCount最大值为2^29-1，大约5亿
private static final int COUNT_BITS = Integer.SIZE - 3;
//最大的线程数量限制，2^29-1，大约5亿
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// runState存储在ctl的高位，前3位
private static final int RUNNING    = -1 << COUNT_BITS;//11100000000000000000000000000000
private static final int SHUTDOWN   =  0 << COUNT_BITS;//00000000000000000000000000000000
private static final int STOP       =  1 << COUNT_BITS;//00100000000000000000000000000000
private static final int TIDYING    =  2 << COUNT_BITS;//01000000000000000000000000000000
private static final int TERMINATED =  3 << COUNT_BITS;//01100000000000000000000000000000

// 对ctl进行包装和拆包
//计算当前的运行状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//计算当前线程数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
//通过runStatus和workerCount获取ctl
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 核心参数

| 参数 | 描述 |
|------|------|
| corePoolSize | 核心线程数，线程池中始终存活的线程数，即使它们处于空闲状态。如果将allowCoreThreadTimeOut设置为true，那么核心线程也会在等待新任务时保持空闲状态。 | 
| maximumPoolSize | 最大线程数，线程池中允许的最大线程数。当线程数达到corePoolSize，且任务队列已满时，线程池会创建新的线程，直到线程数达到maximumPoolSize。 |
| keepAliveTime | 空闲线程的存活时间，当线程数大于corePoolSize时，空闲线程的最大存活时间。如果将allowCoreThreadTimeOut设置为true，那么核心线程也会在空闲时被终止。 |
| unit | keepAliveTime的时间单位，例如TimeUnit.SECONDS。 |
| workQueue | 任务队列，用于保存等待执行的任务。当所有核心线程都在处理任务时，新任务将被放入队列中等待执行。 |
| threadFactory | 线程工厂，用于创建新线程。 |
| RejectedExecutionHandler | 拒绝策略，当线程池无法接受新任务时，会触发拒绝策略。常见的拒绝策略有AbortPolicy（默认）、CallerRunsPolicy、DiscardPolicy和DiscardOldestPolicy。 |

ThreadPoolExecutor 的生命周期：

![1749472857314.png](https://cdn4.winhlb.com/2025/06/09/6846d65cd234c.png)

ThreadPoolExecutor 运行机制：

![1749473446539.png](https://cdn4.winhlb.com/2025/06/09/6846d8a93e860.png)

1. 在方法execute（Runnable）中提交新任务时，如果运行的线程少于corePoolSize，则会创建一个新线程来处理该请求，即使其他工作线程处于空闲状态。
2. 如果线程数超过了corePoolSize，此时新来的任务会进入到工作队列中
3. 如果运行的线程超过corePoolSize，且仅当队列已满时，但小于maximumPoolSize，才会创建新线程
4. 如果队列已满，且线程数达到maximumPoolSize，则会触发拒绝策略

#### corePoolSize 和 maximumPoolSize

通过将corePoolSize和maximumPoolSize设置相同，可以创建一个固定大小的线程池 —— Executors.newFixedThreadPool(int) 就是将两者设置为相同值。

通过将maximumPoolSize设置为本质上无界的值，例如Integer.MAX_VALUE（`Executors.newCachedThreadPool()`就是这么做的），允许线程池容纳任意数量的并发任务 —— 但是会有OOM的风险，生产中千万不要这样使用。

corePoolSize 和 maximumPoolSize 一般只在 ThreadPoolExecutor 创建时配置，但也可以使用 `setCorePoolSize(int)` 和`setMaximumPoolSize(int)` 动态更改。



#### 

使用ThreadFactory创建新线程。如果未另行规定，使用Executors.defaultThreadFactory()，它创建的线程都位于同一线程组中，并且具有相同的NORM_PRIORITY优先级和非守护线程	状态。通过提供不同的ThreadFactory，您可以更改线程的名称、线程组、优先级、守护线程状态等。如果ThreadFactory调用newThread()时返回null，则创建线程失败，此时执行器将继续运行，但可能无法执行任何任务。线程应该拥有“modifyThread”运行时权限。如果工作线程或使用该池的其他线程不具有此权限，则服务可能会降级：配置更改可能不会及时生效，关闭线程池可能会保持终止但未完成的状态。

如果线程池当前有多个corePoolSize线程，如果多余的线程空闲时间超过keepAliveTime，则会终止这些线程。这提供了一种在线程池中的线程未被使用时减少资源消耗的方法。如果线程池稍后有更多的任务到大，将构造新线程。也可以使用方法 setKeepAliveTime（long，TimeUnit）动态更改此参数。使用`Long.MAX_VALUE` TimeUnit.NANOSECONDS 有效地禁止空闲线程在关闭之前终止。默认情况下，仅当存在超出corePoolSize个线程时，keep-alive 策略才适用。但是方法allowCoreThreadTimeOut(boolean)也可以将此超时策略应用于核心线程，只要keepAliveTime值不为零。

任何BlockingQueue都可以用来传输和保存提交的任务。此队列的使用与线程池大小相关：

- 如果运行的线程少于corePoolSize，那么Executor总是先添加新线程，而不是排队。
- 如果corePoolSize或多个线程正在运行，Executor总是倾向于将请求排队，而不是添加新线程。
- 如果请求无法排队（队列已满），则会创建一个新线程；如果线程数超过maximumPoolSize，任务将被拒绝。

排队的一般策略有三种：

- 直接移交给线程执行任务。对于工作队列来说，一个很好的默认选择是SynchronousQueue，它将任务交给线程，而无需持有它们。在这里，如果没有线程可以立即运行任务，那么尝试将任务排队将失败，因此将构造一个新线程。在处理可能具有内部依赖关系的请求集时，此策略避免了锁定。直接交给线程处理 通常需要无限的maximumPoolSizes，以避免拒绝新提交的任务。这反过来又允许了当命令继续以平均比处理速度更快的速度到达时，线程无限增长的可能性。 —— 总体来说，就是需要定义一个Integer.MAX_VALUE数量的最大线程数，工作任务来时，不进入workQueue，而是直接复用已有线程或者创建线程，但是这种情况下，可能会存在无限制创建线程的问题。
- 无界队列。使用无界队列（例如，没有预定义容量的LinkedBlockingQueue）将导致新任务在所有corePoolSize线程都繁忙时在队列中等待。因此，创建的线程不会超过corePoolSize。（在此情况下，maximumPoolSize的值没有任何影响）当每个任务完全独立于其他任务时，这可能是合适的，因此任务不会影响其他任务的执行。虽然这种排队方式有助于消除短暂的请求突发，但当命令继续以平均比处理速度更快的速度到达时，工作队列可能会无限增长。 —— 线程池中最多存在corePoolSize个线程，maximumPoolSize设置不生效，工作任务提交后，如果线程池中没有空闲线程，则进入队列，队列可无限增长，所以存在OOM的风险。
- 有界的队列。当与有限的maximumPoolSize一起使用时，有界队列（例如ArrayBlockingQueue）有助于防止资源耗尽，但可能更难调整和控制。队列大小和最大池大小可以相互权衡：使用大型队列和较少的线程数可以最大限度地减少CPU使用、操作系统资源和上下文切换开销，但可能会导致较低的吞吐量。如果任务经常阻塞（例如，如果它们是I/O绑定的），系统可能需要频繁的进行线程切换。使用小队列通常需要更大的池大小，这使CPU更繁忙，但可能会遇到不可接受的调度开销，这也会降低吞吐量。

在方法 execute(Runnable) 中提交的新任务将在Executor关闭时被拒绝，并且当Executor对最大线程和工作队列容量使用有限边界，并且处于饱和状态时也将被拒绝。在这两种情况下，execute方法都会调用RejectedExecutionHandler。其RejectedExecutionHandler的rejectedExecution(Runnable，ThreadPoolExecutor)方法。提供了四个预定义的处理程序策略，具体参见下方的handler章节。

### Hook methods

ThreadPoolExecutor 提供了受保护的可重写beforeExecute(Thread，Runnable)和afterExecute(Runnable，Throwable)方法，这两个方法在每个任务执行之前和之后都会被调用。

这些可以用来操纵执行环境；例如，重新初始化ThreadLocals、收集统计信息或添加日志条目。此外，可以重写terminated()以执行Executor完全终止后需要执行的任何特殊处理。

如果钩子或回调方法抛出异常，内部工作线程可能会失败并突然终止。

### 队列维护

通过getQueue()方法可以访问工作队列以进行监视和调试。强烈反对将此方法用于任何其他目的。

提供的两种方法remove(Runnable)和purge()可用于在大量排队的任务被取消时帮助进行存储回收。

### 回收

程序中不再引用且没有剩余线程的线程池将自动关闭。如果要确保即使用户忘记调用shutdown()，也能回收未引用的池，则必须通过设置适当的keep-alive时间、使用零核心线程的下限或设置allowCoreThreadTimeOut(boolean)，安排未使用的线程最终死亡。

### 案例

此类的大多数扩展都会覆盖一个或多个受保护的钩子方法。例如，下面是一个子类，它添加了一个简单的暂停/恢复功能：

```java
class PausableThreadPoolExecutor extends ThreadPoolExecutor {
   private boolean isPaused;
   private ReentrantLock pauseLock = new ReentrantLock();
   private Condition unpaused = pauseLock.newCondition();

   public PausableThreadPoolExecutor(...) { super(...); }

   protected void beforeExecute(Thread t, Runnable r) {
     super.beforeExecute(t, r);
     pauseLock.lock();
     try {
       while (isPaused) unpaused.await();
     } catch (InterruptedException ie) {
       t.interrupt();
     } finally {
       pauseLock.unlock();
     }
   }

   public void pause() {
     pauseLock.lock();
     try {
       isPaused = true;
     } finally {
       pauseLock.unlock();
     }
   }

   public void resume() {
     pauseLock.lock();
     try {
       isPaused = false;
       unpaused.signalAll();
     } finally {
       pauseLock.unlock();
     }
   }
 }
```

### corePoolSize

在创建了线程池后，默认情况下，线程池中并没有 任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者 prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线 程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中

```java
//预加载核心线程，避免临时创建的开销 —— 但是可能会造成线程资源的浪费
public int prestartAllCoreThreads() {
  int n = 0;
  while (addWorker(null, true))
    ++n;
  return n;
}

//想工作队列中添加任务
private boolean addWorker(Runnable firstTask, boolean core) {
  retry:
  for (;;) {
    int c = ctl.get();
    int rs = runStateOf(c);

    // Check if queue empty only if necessary.
    if (rs >= SHUTDOWN &&
        ! (rs == SHUTDOWN &&
           firstTask == null &&
           ! workQueue.isEmpty()))
      return false;

    for (;;) {
      int wc = workerCountOf(c);
      if (wc >= CAPACITY ||
          wc >= (core ? corePoolSize : maximumPoolSize))
        return false;
      if (compareAndIncrementWorkerCount(c))
        break retry;
      c = ctl.get();  // Re-read ctl
      if (runStateOf(c) != rs)
        continue retry;
      // else CAS failed due to workerCount change; retry inner loop
    }
  }

  boolean workerStarted = false;
  boolean workerAdded = false;
  Worker w = null;
  try {
    w = new Worker(firstTask);
    final Thread t = w.thread;
    if (t != null) {
      final ReentrantLock mainLock = this.mainLock;
      mainLock.lock();
      try {
        // Recheck while holding lock.
        // Back out on ThreadFactory failure or if
        // shut down before lock acquired.
        int rs = runStateOf(ctl.get());

        if (rs < SHUTDOWN ||
            (rs == SHUTDOWN && firstTask == null)) {
          if (t.isAlive()) // precheck that t is startable
            throw new IllegalThreadStateException();
          workers.add(w);
          int s = workers.size();
          if (s > largestPoolSize)
            largestPoolSize = s;
          workerAdded = true;
        }
      } finally {
        mainLock.unlock();
      }
      if (workerAdded) {
        t.start();
        workerStarted = true;
      }
    }
  } finally {
    if (! workerStarted)
      addWorkerFailed(w);
  }
  return workerStarted;
}
```

### maximumPoolSize

最大线程数，线程池中最多能创建多少个线程

### keepAliveTime

线程空闲存活时间，当线程不执行任务并且worker队列中没有待执行之后时，超出keepAliveTime时间，线程一直空闲，那么线程就会被回收。这里需要注意，只会回收超出核心线程数的线程，当线程数量 = 核心线程数时，不会再进行回收操作。

如果想要回收核心线程，可以调用 allowsCoreThreadTimeOut() 方法，将allowCoreThreadTimeOut设置为true

```java
public boolean allowsCoreThreadTimeOut() {
  return allowCoreThreadTimeOut;
}

public void allowCoreThreadTimeOut(boolean value) {
  if (value && keepAliveTime <= 0)
    throw new IllegalArgumentException("Core threads must have nonzero keep alive times");
  if (value != allowCoreThreadTimeOut) {
    allowCoreThreadTimeOut = value;
    if (value)
      interruptIdleWorkers();
  }
}
```

### workQueue

工作任务队列，目前用的比较多的有

- LinkedBlockingQueue —— newSingleThreadExecutor方法
- SynchronousQueue —— newCachedThreadPool方法
- DelayedWorkQueue  —— newScheduledThreadPool方法

此外，还有 ArrayBlockingQueue 和 PriorityBlockingQueue，但是用的比较少，可以想一想为什么！

### threadFactory

线程工厂，主要用来创建线程

### handler

RejectedExecutionHandler对象，拒绝执行处理器，通常叫做拒绝策略。

JDK中内置了四种拒绝策略

- CallerRunsPolicy：由调用者线程来执行新来的工作任务

- AbortPolicy：直接抛出RejectedExecutionException异常，丢弃掉新来的工作任务
- DiscardPolicy：将新来的工作任务丢弃，不抛出异常
- DiscardOldestPolicy：丢弃最早的一个工作任务，执行新来的任务

AbortPolicy 是默认的拒绝策略

```java
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
```

几种拒绝策略的实现如下

```java
public static class CallerRunsPolicy implements RejectedExecutionHandler {
  
  public CallerRunsPolicy() { }

  //由调用者线程来执行新来的工作任务
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    //检查线程池是否被关闭
    if (!e.isShutdown()) {
      //注意：这里是R，而不是e，线程直接执行run方法
      r.run();
    }
  }
}

public static class AbortPolicy implements RejectedExecutionHandler {

  public AbortPolicy() { }

  //直接抛出RejectedExecutionException异常，丢弃掉新来的工作任务
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    throw new RejectedExecutionException("Task " + r.toString() +
                                         " rejected from " +
                                         e.toString());
  }
}

public static class DiscardPolicy implements RejectedExecutionHandler {
  
  public DiscardPolicy() { }

  //将新来的工作任务丢弃
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
  }
}

public static class DiscardOldestPolicy implements RejectedExecutionHandler {

  public DiscardOldestPolicy() { }

  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    //检查线程池是否被关闭
    if (!e.isShutdown()) {
      //线程池没有关闭时，去获取工作队列中第一个工作任务，出队——但是，不执行，相当于将最早的一个工作任务丢弃了
      e.getQueue().poll();
      //执行新来的工作任务
      e.execute(r);
    }
  }
}
```

1. 如果线程池中的线程数量少于 corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务；
2. 如果线程池中的线程数量大于等于 corePoolSize，但缓冲队列 workQueue 未满，则将新添加的任务放到 workQueue 中，按照 FIFO 的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）；
3. 如果线程池中的线程数量大于等于 corePoolSize，且缓冲队列 workQueue 已满，但线程池中的线程数量小于 maximumPoolSize，则会创建新的线程来处理被添加的任务；
4. 如果线程池中的线程数量等于了 maximumPoolSize，有 4 种才处理方式（该构造方法调用了含有 5 个参数的构造方法，并将最后一个构造方法为 RejectedExecutionHandler 类型，它在处理线程溢出时有 4 种方式，这里不再细说，要了解的，自己可以阅读下源码）。

当线程池中的线程数量大于 corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。

### 几种排队的策略

- 直接提交。缓冲队列采用 SynchronousQueue，它将任务直接交给线程处理而不保持它们。如果不存在可用于立即运行任务的线程（即线程池中的线程都在工作），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中。直接提交通常要求无界 maximumPoolSizes（Integer.MAX_VALUE） 以避免拒绝新提交的任务。newCachedThreadPool 采用的便是这种策略。
- 无界队列。使用无界队列（典型的便是采用预定义容量的 LinkedBlockingQueue，理论上是该缓冲队列可以对无限多的任务排队）将导致在所有 corePoolSize 线程都工作的情况下将新任务加入到缓冲队列中。这样，创建的线程就不会超过 corePoolSize，也因此，maximumPoolSize 的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。newFixedThreadPool采用的便是这种策略。
- 有界队列。当使用有限的 maximumPoolSizes 时，有界队列（一般缓冲队列使用 ArrayBlockingQueue，并制定队列的最大长度）有助于防止资源耗尽，但是可能较难调整和控制，队列大小和最大池大小需要相互折衷，需要设定合理的参数。

### 方法

```java
public void execute(Runnable command) {
  	//空判断，不能传入null
    if (command == null)
        throw new NullPointerException();
    /*
     * 分3步执行
     * 
     * 1. 如果池中线程数量小于corePoolSize，则尝试去启动一个新线程执行给定的第一个任务。
     * 对addWorker的调用会自动检查runState和workerCount，从而通过返回false来防止误报，
     * 因为误报会在不应该添加线程的时候添加线程。
     *
     * 2. 如果一个任务可以成功入队，那么我们仍然需要再次检查是否应该添加一个线程
     * (因为现有的线程在上次检查之后已经死亡)，或者在进入这个方法之后线程池已经关闭。
     * 因此，我们将重新检查状态，并在必要时回滚队列，或者在没有队列时启动一个新线程。
     * So we recheck state and if necessary roll back the enqueuing if stopped, 
     * or start a new thread if there are none
     * 
     * 3. 如果任务无法入队，则尝试去创建一个新的线程。
     * 如果创建失败，我们知道线程池已经关闭或饱和，所以拒绝了新的任务
     */
  	//获取ctl的值
    int c = ctl.get();
  	//线程数小于corePoolSize时，创建
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}

//获取ctl当前的值
public final int get() {
  return value;
}

private boolean addWorker(Runnable firstTask, boolean core) {
  //label，方便直接跳出循环
  retry:
  for (;;) {
    //获取ctl的值
    int c = ctl.get();
    //获取线程池的状态 runStatus
    int rs = runStateOf(c);
    
    //必要时自动检查runState和workQueue
    //判断条件是 
    //线程池非RUNNING状态 且 !(线程池状态为SHUTDOWN 且 第一个任务为空 且 workQueue不为空) —— 这里需要牢记runStatus的各种情况
    if (rs >= SHUTDOWN &&
        ! (rs == SHUTDOWN &&
           firstTask == null &&
           ! workQueue.isEmpty()))
      return false;

    //自旋
    for (;;) {
      //获取workerCount，池中的线程数量
      int wc = workerCountOf(c);
      //如果线程数量大于等于最大容量（2^29-1），或 超出corePoolSize或者maximumPoolSize，则直接返回false，添加失败
      if (wc >= CAPACITY ||
          wc >= (core ? corePoolSize : maximumPoolSize))
        return false;
      //各种检查之后，CAS的方式添加workerCount，workerCount+1
      if (compareAndIncrementWorkerCount(c))
        //直接跳出retry的循环
        break retry;
      //由于其他线程同步修改了 workerCount的值，导致CAS失败
      c = ctl.get();  // Re-read ctl
      if (runStateOf(c) != rs)
        continue retry;
      //由于其他线程同步修改了 workerCount的值，导致CAS失败，则重新进入retry循环，进行添加操作
    }
  }

  boolean workerStarted = false;
  boolean workerAdded = false;
  Worker w = null;
  try {
    w = new Worker(firstTask);
    final Thread t = w.thread;
    if (t != null) {
      final ReentrantLock mainLock = this.mainLock;
      mainLock.lock();
      try {
        // Recheck while holding lock.
        // Back out on ThreadFactory failure or if
        // shut down before lock acquired.
        int rs = runStateOf(ctl.get());

        if (rs < SHUTDOWN ||
            (rs == SHUTDOWN && firstTask == null)) {
          if (t.isAlive()) // precheck that t is startable
            throw new IllegalThreadStateException();
          workers.add(w);
          int s = workers.size();
          if (s > largestPoolSize)
            largestPoolSize = s;
          workerAdded = true;
        }
      } finally {
        mainLock.unlock();
      }
      if (workerAdded) {
        t.start();
        workerStarted = true;
      }
    }
  } finally {
    if (! workerStarted)
      addWorkerFailed(w);
  }
  return workerStarted;
}

    private boolean compareAndIncrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect + 1);
    }
```

对于Worker的解析单独拿出来

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {

  /** Thread this worker is running in.  Null if factory fails. */
  final Thread thread;
  /** Initial task to run.  Possibly null. */
  Runnable firstTask;
  /** Per-thread task counter */
  volatile long completedTasks;

  /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
  Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
  }

  /** Delegates main run loop to outer runWorker  */
  public void run() {
    runWorker(this);
  }

  // Lock methods
  //
  // The value 0 represents the unlocked state.
  // The value 1 represents the locked state.

  protected boolean isHeldExclusively() {
    return getState() != 0;
  }

  protected boolean tryAcquire(int unused) {
    if (compareAndSetState(0, 1)) {
      setExclusiveOwnerThread(Thread.currentThread());
      return true;
    }
    return false;
  }

  protected boolean tryRelease(int unused) {
    setExclusiveOwnerThread(null);
    setState(0);
    return true;
  }

  public void lock()        { acquire(1); }
  public boolean tryLock()  { return tryAcquire(1); }
  public void unlock()      { release(1); }
  public boolean isLocked() { return isHeldExclusively(); }

  void interruptIfStarted() {
    Thread t;
    if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
      try {
        t.interrupt();
      } catch (SecurityException ignore) {
      }
    }
  }
}
```

#### 线程池预热

默认情况下，核心线程在初始化时创建，并仅在新任务到达时启动，但这可以使用方法 `prestartCoreThread()` 或 `prestartAllCoreThreads()`来进行预热启动。如果使用非空队列构建线程池，可能需要预启动线程。



# ThreadFactory

### Executors

https://wiki.jikexueyuan.com/project/java-concurrency/executor.html

##### newFixedThreadPool

创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，在提交新任务，任务将会进入等待队列中等待。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

https://www.cnblogs.com/vhua/p/5277694.html



创建一个线程工程ThreadFactory

```java
public static ThreadFactory defaultThreadFactory() {
    return new DefaultThreadFactory();
}
```

DefaultThreadFactory 是一个静态内部类，实现了ThreadFactory接口

```java
static class DefaultThreadFactory implements ThreadFactory {
  private static final AtomicInteger poolNumber = new AtomicInteger(1);
  private final ThreadGroup group;
  private final AtomicInteger threadNumber = new AtomicInteger(1);
  private final String namePrefix;

  //构造器
  DefaultThreadFactory() {
    SecurityManager s = System.getSecurityManager();
    group = (s != null) ? s.getThreadGroup() :
    Thread.currentThread().getThreadGroup();
    //线程的名称前缀  pool-数字-thread-  嗯？是不是感觉很熟悉
    namePrefix = "pool-" +
      poolNumber.getAndIncrement() +
      "-thread-";
  }

  public Thread newThread(Runnable r) {
    //Thread(ThreadGroup group, Runnable target, String name, long stackSize)
    Thread t = new Thread(group, r,
                          namePrefix + threadNumber.getAndIncrement(),
                          0);
    if (t.isDaemon())
      t.setDaemon(false);
    if (t.getPriority() != Thread.NORM_PRIORITY)
      t.setPriority(Thread.NORM_PRIORITY);
    return t;
  }
}
```

### ScheduledThreadPoolExecutor

### ScheduledExecutorService

### CompletionService

一种将新异步任务的产生与已完成任务结果的消费分离开来的服务。生产者提交任务执行，消费者接受完成的任务，并按照完成的顺序处理结果。例如，CompletionService可用于管理异步I/O，在异步I/O中，执行读取的任务在程序或系统的一个部分中提交，然后在读取完成时在程序的另一个部分中执行，可能与请求的顺序不同。

通常，一个CompletionService依赖于一个独立的Executor来执行任务，在这种情况下，CompletionService只管理一个内部的完成队列。ExecutorCompletionService类提供了这种方法的实现。

内存一致性影响：在将任务提交给CompletionService之前，线程中的操作发生在该任务执行的操作之前，而该任务执行的操作又发生在相应take（）成功返回后的操作之前。

```java
//提交一个带返回值的任务以供执行，并返回一个表示任务挂起结果的Future。完成后，可以接受或轮询此任务。
Future<V> submit(Callable<V> task);

//提交可运行任务以执行，并返回表示该任务的Future。完成后，可以接受或轮询此任务。
Future<V> submit(Runnable task, V result);

//检索并删除代表下一个已完成任务的Future，如果还没有，则等待。
Future<V> take() throws InterruptedException;

//检索并删除表示下一个已完成任务的Future，如果不存在，则返回null。
Future<V> poll();

//检索并删除表示下一个已完成任务的未来，如果没有，则在必要时等待到指定的等待时间。
Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException;
```





### ExecutorCompletionService

构造器

```java
//传入一个线程池对象
public ExecutorCompletionService(Executor executor) {
  //判空
  if (executor == null)
    throw new NullPointerException();
  this.executor = executor;
  this.aes = (executor instanceof AbstractExecutorService) ?
    (AbstractExecutorService) executor : null;
  this.completionQueue = new LinkedBlockingQueue<Future<V>>();
}

//传入线程池对象和阻塞队列，队列中存放任务执行结果的Future
public ExecutorCompletionService(Executor executor,
                                 BlockingQueue<Future<V>> completionQueue) {
  if (executor == null || completionQueue == null)
    throw new NullPointerException();
  this.executor = executor;
  this.aes = (executor instanceof AbstractExecutorService) ?
    (AbstractExecutorService) executor : null;
  this.completionQueue = completionQueue;
}
```

### Future

Future表示异步计算的结果。提供了一些方法来检查计算是否完成、等待其完成以及检索计算的结果。结果只能在计算完成时使用get方法进行检索，必要时阻塞直到准备就绪。取消由cancel方法执行。提供了其他方法来确定任务是正常完成还是被取消。一旦计算完成，计算就不能取消。如果为了可取消性而使用Future但不提供可用的结果，可以声明Future<!--?</span-->>和返回null作为底层任务的结果。

应用案例：

```java
interface ArchiveSearcher { String search(String target); }
class App {
  	ExecutorService executor = ...
    ArchiveSearcher searcher = ...
    void showSearch(final String target)
    throws InterruptedException {
    Future<String> future
      = executor.submit(new Callable<String>() {
        public String call() {
          return searcher.search(target);
        }});
    displayOtherThings(); // do other things while searching
    try {
      displayText(future.get()); // use future
    } catch (ExecutionException ex) { cleanup(); return; }
  }
}
```

FutureTask类是Future的一个实现，它实现了Runnable，因此可以由执行器执行。例如，上述带有submit的结构可以替换为

```java
FutureTask<String> future = new FutureTask<String>(
  new Callable<String>() {
    	public String call() {
      	return searcher.search(target);
    	}
	});
executor.execute(future);
```

内存一致性效应：异步计算所采取的行动发生在相应未来的行动之前。进入另一个线程。

```java
//取消任务
boolean cancel(boolean mayInterruptIfRunning);

//判断任务是否已取消
boolean isCancelled();

//判断任务是否已结束
boolean isDone();

//获取任务结果 —— 阻塞式，等待任务执行完成后再返回
V get() throws InterruptedException, ExecutionException;

//获取任务结果，超出给定时间，则抛出异常 —— 超时机制支持 —— 阻塞式
V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
```

### FutureTask

构造方法

```java
public FutureTask(Callable<V> callable) {
  if (callable == null)
    throw new NullPointerException();
  this.callable = callable;
  this.state = NEW;       // ensure visibility of callable
}
public FutureTask(Runnable runnable, V result) {
  this.callable = Executors.callable(runnable, result);
  this.state = NEW;       // ensure visibility of callable
}
```



