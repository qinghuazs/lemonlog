# 打车系统设计

## 1. 需求分析与核心挑战

### 1.1 功能需求

#### 1.1.1 用户端功能
- **乘客功能**：
  - 注册登录、实名认证
  - 发起打车请求（起点、终点、车型选择）
  - 实时查看附近司机、预估价格和到达时间
  - 与司机实时通信（文字、语音、位置共享）
  - 订单状态跟踪、路线导航
  - 在线支付、订单评价、投诉反馈

- **司机功能**：
  - 注册登录、资质认证、车辆信息管理
  - 接单/拒单、设置服务状态（在线/离线/忙碌）
  - 导航到乘客位置、行程导航
  - 与乘客实时通信
  - 收入统计、订单历史、评价管理

#### 1.1.2 平台管理功能
- **运营管理**：
  - 司机审核、车辆管理、实时监控
  - 订单管理、客服系统、投诉处理
  - 数据分析、财务结算、营销活动

- **安全保障**：
  - 行程录音、紧急联系人、一键报警
  - 人脸识别、轨迹异常监测
  - 风险控制、反作弊系统

### 1.2 非功能需求

#### 1.2.1 性能要求

```java
/**
 * 系统性能指标
 */
public class PerformanceRequirements {

    // 响应时间要求
    public static final int LOCATION_UPDATE_MAX_LATENCY = 100; // ms
    public static final int MATCHING_MAX_RESPONSE_TIME = 3000; // ms
    public static final int ORDER_CREATION_MAX_TIME = 500; // ms

    // 吞吐量要求
    public static final int PEAK_ORDERS_PER_SECOND = 50000; // 订单/秒
    public static final int CONCURRENT_USERS = 10_000_000; // 并发用户
    public static final int LOCATION_UPDATES_PER_SECOND = 500_000; // 位置更新/秒

    // 可用性要求
    public static final double AVAILABILITY_SLA = 99.99; // %
    public static final int MAX_DOWNTIME_PER_MONTH = 4; // 分钟

    // 数据一致性要求
    public static final int MAX_DATA_INCONSISTENCY_TIME = 1000; // ms
    public static final double DATA_ACCURACY_RATE = 99.9; // %

    /**
     * 性能指标监控
     */
    @Data
    @Builder
    public static class PerformanceMetrics {
        private long responseTime;          // 响应时间
        private double throughput;          // 吞吐量
        private double availability;        // 可用性
        private double errorRate;           // 错误率
        private long activeUsers;           // 活跃用户数
        private long orderVolume;           // 订单量
        private double matchingSuccessRate; // 匹配成功率
    }
}
```

#### 1.2.2 扩展性要求

- **地理扩展**：支持多城市部署，每个城市独立运营
- **用户扩展**：支持从万级到千万级用户的平滑扩展
- **功能扩展**：支持快车、专车、拼车、货运等多种业务模式
- **技术扩展**：支持微服务架构，服务可独立部署和扩展

### 1.3 核心技术挑战

#### 1.3.1 地理位置挑战

```java
/**
 * 地理位置技术挑战
 */
public class GeolocationChallenges {

    /**
     * 挑战1：大规模位置数据存储与查询
     * - 司机实时位置更新：每秒数十万次
     * - 附近司机查询：毫秒级响应
     * - 地理围栏：进出特定区域检测
     */
    public static class MassiveLocationData {
        // 位置数据结构
        @Data
        public static class LocationData {
            private String driverId;
            private double latitude;    // 纬度
            private double longitude;   // 经度
            private long timestamp;     // 时间戳
            private float accuracy;     // 精度
            private float speed;        // 速度
            private float bearing;      // 方向角
            private int status;         // 司机状态
        }

        // 空间索引策略
        public enum SpatialIndexStrategy {
            GEOHASH,        // GeoHash编码
            QUADTREE,       // 四叉树
            RTREE,          // R树
            GRID_INDEX      // 网格索引
        }
    }

    /**
     * 挑战2：高精度距离计算
     * - 球面距离计算（考虑地球曲率）
     * - 路网距离计算（实际行驶距离）
     * - 实时ETA预估（考虑交通状况）
     */
    public static class DistanceCalculation {

        /**
         * Haversine公式计算球面距离
         */
        public static double calculateHaversineDistance(
            double lat1, double lon1, double lat2, double lon2) {

            final double EARTH_RADIUS = 6371000; // 地球半径(米)

            double dLat = Math.toRadians(lat2 - lat1);
            double dLon = Math.toRadians(lon2 - lon1);

            double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);

            double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return EARTH_RADIUS * c;
        }

        /**
         * 考虑交通状况的ETA计算
         */
        public static class ETACalculation {
            private double baseDistance;      // 基础距离
            private double trafficFactor;    // 交通系数 (1.0-3.0)
            private double weatherFactor;    // 天气系数
            private double timeOfDayFactor;  // 时段系数

            public long calculateETA() {
                double adjustedDistance = baseDistance * trafficFactor *
                                        weatherFactor * timeOfDayFactor;
                // 假设平均速度 30km/h
                return (long) (adjustedDistance / 30 * 3600); // 秒
            }
        }
    }

    /**
     * 挑战3：地理围栏和热力图
     */
    public static class GeofencingAndHeatmap {

        @Data
        public static class Geofence {
            private String id;
            private String name;
            private GeofenceType type;
            private List<GeoPoint> boundary;  // 边界点
            private Map<String, Object> properties;

            public enum GeofenceType {
                AIRPORT,           // 机场
                TRAIN_STATION,     // 火车站
                BUSINESS_DISTRICT, // 商务区
                RESIDENTIAL,       // 住宅区
                RESTRICTED_AREA    // 限行区域
            }
        }

        @Data
        public static class HeatmapData {
            private GeoPoint center;
            private double intensity;      // 热度值
            private int orderCount;        // 订单数量
            private double avgWaitTime;    // 平均等待时间
            private long timestamp;
        }
    }
}
```

#### 1.3.2 实时匹配挑战

```java
/**
 * 实时匹配算法挑战
 */
public class RealTimeMatchingChallenges {

    /**
     * 挑战1：毫秒级匹配响应
     * - 海量司机池中快速筛选
     * - 多维度匹配条件（距离、评分、车型等）
     * - 动态调整匹配策略
     */
    public static class MatchingAlgorithm {

        @Data
        public static class MatchingCriteria {
            private double maxDistance;           // 最大距离(米)
            private double minDriverRating;       // 最低司机评分
            private VehicleType vehicleType;      // 车型要求
            private boolean allowWaiting;        // 是否允许等待
            private int maxWaitTime;             // 最大等待时间(秒)
            private PricingStrategy pricing;      // 定价策略
        }

        @Data
        public static class MatchingResult {
            private String orderId;
            private String passengerId;
            private String driverId;
            private double distance;              // 司机到乘客距离
            private long estimatedArrivalTime;    // 预计到达时间
            private double estimatedPrice;        // 预估价格
            private double matchingScore;         // 匹配分数
            private long matchingTime;           // 匹配耗时
        }

        /**
         * 匹配算法策略
         */
        public enum MatchingStrategy {
            NEAREST_FIRST,          // 距离优先
            RATING_WEIGHTED,        // 评分加权
            BALANCED_SCORE,         // 综合评分
            INTELLIGENT_DISPATCH    // 智能调度
        }
    }

    /**
     * 挑战2：避免匹配冲突
     * - 防止多个乘客匹配同一司机
     * - 司机拒单后的重新匹配
     * - 订单取消的处理
     */
    public static class MatchingConflictResolution {

        /**
         * 分布式锁确保匹配唯一性
         */
        public static class DistributedMatchingLock {
            private final RedisTemplate<String, String> redisTemplate;
            private static final String LOCK_PREFIX = "matching:lock:";
            private static final int LOCK_TIMEOUT = 5000; // 5秒

            public boolean tryLockDriver(String driverId, String orderId) {
                String lockKey = LOCK_PREFIX + driverId;
                Boolean success = redisTemplate.opsForValue()
                    .setIfAbsent(lockKey, orderId, Duration.ofMillis(LOCK_TIMEOUT));
                return Boolean.TRUE.equals(success);
            }

            public void releaseLock(String driverId) {
                String lockKey = LOCK_PREFIX + driverId;
                redisTemplate.delete(lockKey);
            }
        }

        /**
         * 匹配状态机
         */
        public enum MatchingStatus {
            PENDING,        // 待匹配
            MATCHING,       // 匹配中
            MATCHED,        // 已匹配
            DRIVER_REJECT,  // 司机拒绝
            PASSENGER_CANCEL, // 乘客取消
            TIMEOUT,        // 超时
            FAILED          // 失败
        }
    }

    /**
     * 挑战3：智能调度优化
     * - 全局最优vs局部最优
     * - 供需平衡调节
     * - 长期收益最大化
     */
    public static class IntelligentDispatch {

        @Data
        public static class DispatchContext {
            private List<Driver> availableDrivers;
            private List<Order> pendingOrders;
            private RegionSupplyDemand supplyDemand;
            private TrafficCondition trafficCondition;
            private WeatherCondition weatherCondition;
        }

        /**
         * 供需平衡模型
         */
        @Data
        public static class RegionSupplyDemand {
            private String regionId;
            private int driverCount;              // 司机数量
            private int orderCount;               // 订单数量
            private double supplyDemandRatio;     // 供需比
            private double surgeMultiplier;       // 动态定价倍数
            private long timestamp;
        }

        /**
         * 调度目标函数
         */
        public static class DispatchObjective {
            // 最小化总等待时间
            public double minimizeTotalWaitTime(List<MatchingPair> pairs) {
                return pairs.stream()
                    .mapToDouble(pair -> pair.getEstimatedArrivalTime())
                    .sum();
            }

            // 最大化司机利用率
            public double maximizeDriverUtilization(List<Driver> drivers) {
                long busyDrivers = drivers.stream()
                    .filter(d -> d.getStatus() == DriverStatus.BUSY)
                    .count();
                return (double) busyDrivers / drivers.size();
            }

            // 最大化平台收益
            public double maximizePlatformRevenue(List<MatchingPair> pairs) {
                return pairs.stream()
                    .mapToDouble(pair -> pair.getEstimatedPrice() * 0.2) // 20%抽成
                    .sum();
            }
        }
    }
}
```

#### 1.3.3 高并发架构挑战

```java
/**
 * 高并发架构挑战
 */
public class HighConcurrencyArchitectureChallenges {

    /**
     * 挑战1：数据库读写分离与分片
     */
    public static class DatabaseScaling {

        /**
         * 分库分表策略
         */
        public enum ShardingStrategy {
            BY_CITY,        // 按城市分片
            BY_USER_ID,     // 按用户ID分片
            BY_TIME,        // 按时间分片
            HYBRID          // 混合策略
        }

        /**
         * 数据库连接配置
         */
        @Configuration
        public static class DatabaseConfig {

            @Bean
            @Primary
            public DataSource masterDataSource() {
                HikariConfig config = new HikariConfig();
                config.setJdbcUrl("jdbc:mysql://master-db:3306/ride_hailing");
                config.setUsername("root");
                config.setPassword("password");
                config.setMaximumPoolSize(50);
                config.setMinimumIdle(10);
                config.setConnectionTimeout(30000);
                config.setIdleTimeout(600000);
                config.setMaxLifetime(1800000);
                return new HikariDataSource(config);
            }

            @Bean
            public DataSource slaveDataSource() {
                HikariConfig config = new HikariConfig();
                config.setJdbcUrl("jdbc:mysql://slave-db:3306/ride_hailing");
                config.setUsername("readonly");
                config.setPassword("password");
                config.setMaximumPoolSize(30);
                config.setReadOnly(true);
                return new HikariDataSource(config);
            }
        }

        /**
         * 分片路由
         */
        public static class ShardingRouter {

            public String getShardKey(String userId, String cityId) {
                // 城市 + 用户ID hash
                return cityId + "_" + (userId.hashCode() % 16);
            }

            public String getTableSuffix(long timestamp) {
                // 按月分表
                return new SimpleDateFormat("yyyyMM").format(new Date(timestamp));
            }
        }
    }

    /**
     * 挑战2：缓存策略与一致性
     */
    public static class CachingStrategy {

        /**
         * 多级缓存架构
         */
        public enum CacheLevel {
            L1_LOCAL,       // 本地缓存 (Caffeine)
            L2_REDIS,       // 分布式缓存 (Redis)
            L3_DATABASE     // 数据库
        }

        /**
         * 缓存配置
         */
        @Configuration
        public static class CacheConfig {

            @Bean
            public CacheManager cacheManager() {
                CaffeineCacheManager cacheManager = new CaffeineCacheManager();
                cacheManager.setCaffeine(Caffeine.newBuilder()
                    .maximumSize(10000)
                    .expireAfterWrite(5, TimeUnit.MINUTES)
                    .recordStats());
                return cacheManager;
            }

            @Bean
            public RedisTemplate<String, Object> redisTemplate() {
                RedisTemplate<String, Object> template = new RedisTemplate<>();
                template.setConnectionFactory(jedisConnectionFactory());
                template.setKeySerializer(new StringRedisSerializer());
                template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
                return template;
            }
        }

        /**
         * 缓存更新策略
         */
        public static class CacheUpdateStrategy {

            /**
             * 司机位置缓存 - 写入即更新
             */
            public void updateDriverLocation(String driverId, LocationData location) {
                // 同时更新Redis和本地缓存
                redisTemplate.opsForValue().set(
                    "driver:location:" + driverId,
                    location,
                    Duration.ofMinutes(10)
                );

                localCache.put("driver:location:" + driverId, location);
            }

            /**
             * 订单数据缓存 - 最终一致性
             */
            public void updateOrderCache(Order order) {
                // 异步更新缓存，避免阻塞主流程
                CompletableFuture.runAsync(() -> {
                    redisTemplate.opsForValue().set(
                        "order:" + order.getId(),
                        order,
                        Duration.ofHours(1)
                    );
                });
            }
        }
    }

    /**
     * 挑战3：服务降级与熔断
     */
    public static class ServiceDegradation {

        /**
         * 熔断器配置
         */
        @Component
        public static class CircuitBreakerConfig {

            @Bean
            public CircuitBreaker matchingServiceCircuitBreaker() {
                return CircuitBreaker.ofDefaults("matchingService");
            }

            @Bean
            public CircuitBreaker routingServiceCircuitBreaker() {
                return CircuitBreaker.ofDefaults("routingService");
            }
        }

        /**
         * 降级策略
         */
        public static class DegradationStrategy {

            /**
             * 匹配服务降级 - 使用简化算法
             */
            public MatchingResult degradedMatching(String passengerId, Location location) {
                // 降级到最简单的距离匹配
                return findNearestDriver(location);
            }

            /**
             * 路由服务降级 - 使用直线距离
             */
            public Route degradedRouting(Location from, Location to) {
                double distance = calculateStraightLineDistance(from, to);
                long estimatedTime = (long) (distance / 30 * 3600); // 30km/h

                return Route.builder()
                    .distance(distance)
                    .estimatedTime(estimatedTime)
                    .degraded(true)
                    .build();
            }
        }
    }
}
```

### 1.4 系统规模估算

#### 1.4.1 用户规模与访问模式

```java
/**
 * 系统规模估算
 */
public class SystemScaleEstimation {

    /**
     * 用户规模
     */
    public static class UserScale {
        public static final int TOTAL_USERS = 50_000_000;        // 总注册用户
        public static final int ACTIVE_DRIVERS = 2_000_000;      // 活跃司机
        public static final int DAILY_ACTIVE_USERS = 10_000_000; // 日活用户
        public static final int PEAK_CONCURRENT_USERS = 1_000_000; // 峰值并发

        // 用户分布 (以北京为例)
        public static final int BEIJING_TOTAL_USERS = 8_000_000;
        public static final int BEIJING_ACTIVE_DRIVERS = 300_000;
        public static final int BEIJING_PEAK_ORDERS = 20_000; // 峰值订单/小时
    }

    /**
     * 数据量估算
     */
    public static class DataVolumeEstimation {

        // 位置数据
        public static final int LOCATION_UPDATES_PER_SECOND = 500_000; // 位置更新/秒
        public static final int LOCATION_DATA_SIZE = 200; // 字节/条
        public static final long DAILY_LOCATION_DATA =
            LOCATION_UPDATES_PER_SECOND * 86400L * LOCATION_DATA_SIZE; // 约8.6TB/天

        // 订单数据
        public static final int DAILY_ORDERS = 5_000_000; // 日订单量
        public static final int ORDER_DATA_SIZE = 2048; // 字节/订单
        public static final long DAILY_ORDER_DATA =
            DAILY_ORDERS * ORDER_DATA_SIZE; // 约10GB/天

        // 消息数据
        public static final int MESSAGES_PER_ORDER = 10; // 平均消息数/订单
        public static final int MESSAGE_SIZE = 512; // 字节/消息
        public static final long DAILY_MESSAGE_DATA =
            DAILY_ORDERS * MESSAGES_PER_ORDER * MESSAGE_SIZE; // 约25GB/天
    }

    /**
     * 性能要求
     */
    public static class PerformanceRequirements {

        // QPS要求
        public static final int PEAK_ORDER_QPS = 10_000;      // 峰值下单QPS
        public static final int LOCATION_UPDATE_QPS = 500_000; // 位置更新QPS
        public static final int QUERY_QPS = 100_000;          // 查询QPS

        // 响应时间要求
        public static final int MATCHING_RT = 3000;  // 匹配响应时间 3s
        public static final int LOCATION_RT = 100;   // 位置更新响应时间 100ms
        public static final int ORDER_RT = 500;      // 下单响应时间 500ms

        // 可用性要求
        public static final double AVAILABILITY = 99.99; // 99.99%可用性
        public static final int MAX_DOWNTIME_MINUTES = 4; // 每月最大宕机时间
    }

    /**
     * 资源估算
     */
    public static class ResourceEstimation {

        /**
         * 服务器资源估算
         */
        public static class ServerResources {
            // API服务器 (处理业务请求)
            public static final int API_SERVERS = 200;
            public static final String API_SERVER_SPEC = "8核16GB";

            // 匹配服务器 (专门处理匹配算法)
            public static final int MATCHING_SERVERS = 50;
            public static final String MATCHING_SERVER_SPEC = "16核32GB";

            // 位置服务器 (处理位置更新)
            public static final int LOCATION_SERVERS = 100;
            public static final String LOCATION_SERVER_SPEC = "8核16GB";

            // WebSocket服务器 (处理实时通信)
            public static final int WEBSOCKET_SERVERS = 80;
            public static final String WEBSOCKET_SERVER_SPEC = "4核8GB";
        }

        /**
         * 数据库资源估算
         */
        public static class DatabaseResources {
            // 主数据库
            public static final int MASTER_DB_COUNT = 16; // 分片数
            public static final String MASTER_DB_SPEC = "32核64GB,2TB SSD";

            // 从数据库
            public static final int SLAVE_DB_COUNT = 32; // 每个主库2个从库
            public static final String SLAVE_DB_SPEC = "16核32GB,1TB SSD";

            // Redis集群
            public static final int REDIS_NODES = 24; // 集群节点数
            public static final String REDIS_SPEC = "8核16GB,256GB内存";
        }

        /**
         * 网络带宽估算
         */
        public static class NetworkBandwidth {
            // 位置更新带宽
            public static final long LOCATION_BANDWIDTH =
                UserScale.PEAK_CONCURRENT_USERS * 200 * 8 / 1024 / 1024; // Mbps

            // API请求带宽
            public static final long API_BANDWIDTH =
                PerformanceRequirements.PEAK_ORDER_QPS * 1024 * 8 / 1024 / 1024; // Mbps

            // 实时消息带宽
            public static final long MESSAGE_BANDWIDTH =
                UserScale.PEAK_CONCURRENT_USERS * 100 * 8 / 1024 / 1024; // Mbps

            public static final long TOTAL_BANDWIDTH =
                LOCATION_BANDWIDTH + API_BANDWIDTH + MESSAGE_BANDWIDTH; // 总带宽需求
        }
    }
}

## 2. 系统整体架构

### 2.1 架构概览

#### 2.1.1 微服务架构设计

```java
/**
 * 微服务架构组件
 */
public class MicroserviceArchitecture {

    /**
     * 核心业务服务
     */
    public enum CoreServices {
        USER_SERVICE("用户服务", "用户注册、认证、资料管理"),
        DRIVER_SERVICE("司机服务", "司机认证、状态管理、车辆管理"),
        LOCATION_SERVICE("位置服务", "实时位置更新、地理查询"),
        MATCHING_SERVICE("匹配服务", "供需匹配、智能调度"),
        ORDER_SERVICE("订单服务", "订单生命周期管理"),
        ROUTING_SERVICE("路由服务", "路径规划、导航"),
        PRICING_SERVICE("定价服务", "动态定价、费用计算"),
        PAYMENT_SERVICE("支付服务", "支付处理、账务管理"),
        NOTIFICATION_SERVICE("通知服务", "消息推送、实时通信"),
        RATING_SERVICE("评价服务", "订单评价、信誉管理");

        private final String name;
        private final String description;

        CoreServices(String name, String description) {
            this.name = name;
            this.description = description;
        }
    }

    /**
     * 基础设施服务
     */
    public enum InfrastructureServices {
        API_GATEWAY("API网关", "请求路由、认证、限流"),
        CONFIG_CENTER("配置中心", "配置管理、动态更新"),
        SERVICE_DISCOVERY("服务发现", "服务注册、发现、负载均衡"),
        MESSAGE_QUEUE("消息队列", "异步消息处理"),
        MONITORING("监控服务", "指标收集、告警"),
        LOGGING("日志服务", "日志收集、分析"),
        TRACING("链路追踪", "分布式追踪"),
        CACHE("缓存服务", "Redis集群");

        private final String name;
        private final String description;

        InfrastructureServices(String name, String description) {
            this.name = name;
            this.description = description;
        }
    }

    /**
     * 服务间通信协议
     */
    public static class ServiceCommunication {

        /**
         * 同步调用 - gRPC
         */
        @Service
        public class GrpcServiceClient {

            @GrpcClient("user-service")
            private UserServiceGrpc.UserServiceBlockingStub userServiceStub;

            @GrpcClient("driver-service")
            private DriverServiceGrpc.DriverServiceBlockingStub driverServiceStub;

            public UserInfo getUserInfo(String userId) {
                GetUserRequest request = GetUserRequest.newBuilder()
                    .setUserId(userId)
                    .build();

                return userServiceStub.getUser(request);
            }
        }

        /**
         * 异步消息 - Kafka
         */
        @Component
        public class EventPublisher {

            @Autowired
            private KafkaTemplate<String, Object> kafkaTemplate;

            public void publishLocationUpdate(LocationUpdateEvent event) {
                kafkaTemplate.send("location-updates", event.getDriverId(), event);
            }

            public void publishOrderCreated(OrderCreatedEvent event) {
                kafkaTemplate.send("order-events", event.getOrderId(), event);
            }
        }

        /**
         * 实时通信 - WebSocket
         */
        @Component
        public class WebSocketHandler extends TextWebSocketHandler {

            private final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>();

            @Override
            public void afterConnectionEstablished(WebSocketSession session) {
                String userId = extractUserId(session);
                sessions.put(userId, session);
            }

            public void sendLocationUpdate(String userId, LocationData location) {
                WebSocketSession session = sessions.get(userId);
                if (session != null && session.isOpen()) {
                    try {
                        session.sendMessage(new TextMessage(
                            objectMapper.writeValueAsString(location)));
                    } catch (Exception e) {
                        log.error("发送位置更新失败", e);
                    }
                }
            }
        }
    }
}
```

#### 2.1.2 数据库架构设计

```java
/**
 * 数据库架构设计
 */
public class DatabaseArchitecture {

    /**
     * 分库分表策略
     */
    public static class ShardingStrategy {

        /**
         * 用户数据分片 - 按用户ID哈希
         */
        @Configuration
        public class UserShardingConfig {

            @Bean
            public ShardingDataSource userShardingDataSource() {
                ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();

                // 用户表分片规则
                TableRuleConfiguration userTableRule = new TableRuleConfiguration(
                    "user", "ds${0..15}.user_${0..7}");
                userTableRule.setDatabaseShardingStrategyConfig(
                    new InlineShardingStrategyConfiguration("user_id", "ds${user_id.hashCode() % 16}"));
                userTableRule.setTableShardingStrategyConfig(
                    new InlineShardingStrategyConfiguration("user_id", "user_${user_id.hashCode() % 8}"));

                shardingRuleConfig.getTableRuleConfigs().add(userTableRule);
                return ShardingDataSourceFactory.createDataSource(
                    createDataSourceMap(), shardingRuleConfig, new Properties());
            }
        }

        /**
         * 订单数据分片 - 按时间+城市
         */
        @Configuration
        public class OrderShardingConfig {

            @Bean
            public ShardingDataSource orderShardingDataSource() {
                ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();

                // 订单表分片规则
                TableRuleConfiguration orderTableRule = new TableRuleConfiguration(
                    "order", "ds${0..31}.order_${202301..202412}");

                // 按城市分库
                orderTableRule.setDatabaseShardingStrategyConfig(
                    new InlineShardingStrategyConfiguration("city_id", "ds${city_id.hashCode() % 32}"));

                // 按创建时间分表
                orderTableRule.setTableShardingStrategyConfig(
                    new ComplexShardingStrategyConfiguration("create_time",
                        new OrderTimeShardingAlgorithm()));

                shardingRuleConfig.getTableRuleConfigs().add(orderTableRule);
                return ShardingDataSourceFactory.createDataSource(
                    createDataSourceMap(), shardingRuleConfig, new Properties());
            }
        }

        /**
         * 位置数据分片 - 按地理区域
         */
        @Configuration
        public class LocationShardingConfig {

            /**
             * 位置数据使用时序数据库 InfluxDB
             */
            @Bean
            public InfluxDB influxDB() {
                return InfluxDBFactory.connect(
                    "http://influxdb-cluster:8086",
                    "username",
                    "password"
                );
            }

            /**
             * 地理空间数据使用 Redis Geo
             */
            @Bean
            public RedisTemplate<String, String> geoRedisTemplate() {
                RedisTemplate<String, String> template = new RedisTemplate<>();
                template.setConnectionFactory(jedisConnectionFactory());
                template.setKeySerializer(new StringRedisSerializer());
                template.setValueSerializer(new StringRedisSerializer());
                return template;
            }
        }
    }

    /**
     * 数据模型设计
     */
    public static class DataModel {

        /**
         * 用户数据模型
         */
        @Entity
        @Table(name = "user")
        @Data
        public static class User {
            @Id
            private String userId;

            private String phone;
            private String email;
            private String name;
            private String avatar;
            private UserType userType;      // 乘客/司机
            private UserStatus status;      // 正常/冻结/注销
            private String cityId;
            private Date createTime;
            private Date updateTime;

            public enum UserType {
                PASSENGER, DRIVER, BOTH
            }

            public enum UserStatus {
                ACTIVE, FROZEN, DELETED
            }
        }

        /**
         * 司机数据模型
         */
        @Entity
        @Table(name = "driver")
        @Data
        public static class Driver {
            @Id
            private String driverId;

            private String userId;          // 关联用户ID
            private String licenseNumber;   // 驾驶证号
            private String vehicleId;       // 车辆ID
            private DriverStatus status;    // 司机状态
            private Double rating;          // 评分
            private Integer totalOrders;    // 总订单数
            private Date certifyTime;       // 认证时间
            private Date lastActiveTime;    // 最后活跃时间

            public enum DriverStatus {
                OFFLINE,    // 离线
                ONLINE,     // 在线空闲
                BUSY,       // 服务中
                BREAK       // 休息
            }
        }

        /**
         * 订单数据模型
         */
        @Entity
        @Table(name = "order")
        @Data
        public static class Order {
            @Id
            private String orderId;

            private String passengerId;     // 乘客ID
            private String driverId;        // 司机ID
            private String cityId;          // 城市ID

            // 地理信息
            private String fromAddress;     // 起点地址
            private Double fromLat;         // 起点纬度
            private Double fromLng;         // 起点经度
            private String toAddress;       // 终点地址
            private Double toLat;           // 终点纬度
            private Double toLng;           // 终点经度

            // 订单信息
            private OrderStatus status;     // 订单状态
            private VehicleType vehicleType; // 车型
            private Double estimatedPrice;  // 预估价格
            private Double actualPrice;     // 实际价格
            private Double distance;        // 距离(米)
            private Integer duration;       // 时长(秒)

            // 时间信息
            private Date createTime;        // 创建时间
            private Date acceptTime;        // 接单时间
            private Date startTime;         // 开始时间
            private Date endTime;           // 结束时间

            public enum OrderStatus {
                CREATED,        // 已创建
                MATCHING,       // 匹配中
                MATCHED,        // 已匹配
                DRIVER_ARRIVED, // 司机到达
                STARTED,        // 行程开始
                COMPLETED,      // 行程完成
                CANCELLED,      // 已取消
                TIMEOUT         // 超时
            }

            public enum VehicleType {
                ECONOMY,        // 经济型
                COMFORT,        // 舒适型
                BUSINESS,       // 商务型
                LUXURY          // 豪华型
            }
        }

        /**
         * 位置数据模型
         */
        @Data
        public static class LocationData {
            private String driverId;
            private Double latitude;        // 纬度
            private Double longitude;       // 经度
            private Float accuracy;         // 精度(米)
            private Float speed;            // 速度(m/s)
            private Float bearing;          // 方向角(度)
            private Long timestamp;         // 时间戳
            private DriverStatus status;    // 司机状态
        }
    }

    /**
     * 读写分离配置
     */
    @Configuration
    public static class ReadWriteSplitConfig {

        @Bean
        @Primary
        public DataSource dataSource() {
            return new ReadWriteSplitDataSource(masterDataSource(), slaveDataSources());
        }

        @Bean
        public DataSource masterDataSource() {
            HikariConfig config = new HikariConfig();
            config.setJdbcUrl("jdbc:mysql://master-db:3306/ride_hailing");
            config.setUsername("root");
            config.setPassword("password");
            config.setMaximumPoolSize(50);
            return new HikariDataSource(config);
        }

        @Bean
        public List<DataSource> slaveDataSources() {
            List<DataSource> slaves = new ArrayList<>();
            for (int i = 1; i <= 3; i++) {
                HikariConfig config = new HikariConfig();
                config.setJdbcUrl("jdbc:mysql://slave-db-" + i + ":3306/ride_hailing");
                config.setUsername("readonly");
                config.setPassword("password");
                config.setMaximumPoolSize(30);
                config.setReadOnly(true);
                slaves.add(new HikariDataSource(config));
            }
            return slaves;
        }
    }
}
```

### 2.2 技术栈选择

#### 2.2.1 后端技术栈

```java
/**
 * 技术栈配置
 */
@Configuration
public class TechnologyStackConfig {

    /**
     * Spring Boot 配置
     */
    @SpringBootApplication
    @EnableEurekaClient
    @EnableAsync
    @EnableScheduling
    public class RideHailingApplication {

        public static void main(String[] args) {
            SpringApplication.run(RideHailingApplication.class, args);
        }

        @Bean
        public TaskExecutor taskExecutor() {
            ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
            executor.setCorePoolSize(20);
            executor.setMaxPoolSize(100);
            executor.setQueueCapacity(500);
            executor.setThreadNamePrefix("RideHailing-");
            executor.initialize();
            return executor;
        }
    }

    /**
     * 数据库技术栈
     */
    public static class DatabaseStack {
        // 主数据库: MySQL 8.0 (ACID事务支持)
        // 缓存: Redis 6.0 (地理空间数据、分布式锁)
        // 时序数据: InfluxDB (位置轨迹存储)
        // 搜索引擎: Elasticsearch (历史订单搜索)
        // 图数据库: Neo4j (路网数据、社交关系)
    }

    /**
     * 中间件技术栈
     */
    public static class MiddlewareStack {
        // 消息队列: Apache Kafka (高吞吐量事件流)
        // RPC框架: gRPC (服务间高性能通信)
        // API网关: Spring Cloud Gateway
        // 服务注册: Eureka
        // 配置中心: Apollo
        // 链路追踪: Jaeger
        // 监控: Prometheus + Grafana
    }

    /**
     * Kafka 配置
     */
    @Configuration
    @EnableKafka
    public static class KafkaConfig {

        @Bean
        public ProducerFactory<String, Object> producerFactory() {
            Map<String, Object> props = new HashMap<>();
            props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "kafka-cluster:9092");
            props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
            props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
            props.put(ProducerConfig.ACKS_CONFIG, "1");
            props.put(ProducerConfig.RETRIES_CONFIG, 3);
            props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);
            props.put(ProducerConfig.LINGER_MS_CONFIG, 10);
            props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, "lz4");
            return new DefaultKafkaProducerFactory<>(props);
        }

        @Bean
        public ConsumerFactory<String, Object> consumerFactory() {
            Map<String, Object> props = new HashMap<>();
            props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "kafka-cluster:9092");
            props.put(ConsumerConfig.GROUP_ID_CONFIG, "ride-hailing-group");
            props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
            props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
            props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "latest");
            props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
            props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 100);
            return new DefaultKafkaConsumerFactory<>(props);
        }
    }

    /**
     * Redis 配置
     */
    @Configuration
    @EnableCaching
    public static class RedisConfig {

        @Bean
        public JedisConnectionFactory jedisConnectionFactory() {
            JedisPoolConfig poolConfig = new JedisPoolConfig();
            poolConfig.setMaxTotal(200);
            poolConfig.setMaxIdle(50);
            poolConfig.setMinIdle(10);
            poolConfig.setTestOnBorrow(true);
            poolConfig.setTestOnReturn(true);

            RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration();
            clusterConfig.addClusterNode(new RedisNode("redis-node-1", 6379));
            clusterConfig.addClusterNode(new RedisNode("redis-node-2", 6379));
            clusterConfig.addClusterNode(new RedisNode("redis-node-3", 6379));
            clusterConfig.addClusterNode(new RedisNode("redis-node-4", 6379));
            clusterConfig.addClusterNode(new RedisNode("redis-node-5", 6379));
            clusterConfig.addClusterNode(new RedisNode("redis-node-6", 6379));

            JedisConnectionFactory factory = new JedisConnectionFactory(clusterConfig, poolConfig);
            factory.setPassword("redis-password");
            return factory;
        }

        @Bean
        public RedisTemplate<String, Object> redisTemplate() {
            RedisTemplate<String, Object> template = new RedisTemplate<>();
            template.setConnectionFactory(jedisConnectionFactory());
            template.setKeySerializer(new StringRedisSerializer());
            template.setHashKeySerializer(new StringRedisSerializer());
            template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
            template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
            template.afterPropertiesSet();
            return template;
        }
    }
}
```

#### 2.2.2 前端技术栈

```javascript
/**
 * 前端技术栈配置
 */

// React Native 配置 (跨平台移动端)
const AppConfig = {
  // 乘客端App
  passengerApp: {
    framework: 'React Native 0.72',
    stateManagement: 'Redux Toolkit',
    navigation: 'React Navigation 6',
    maps: 'react-native-maps',
    realtime: 'Socket.io-client',
    push: 'react-native-push-notification'
  },

  // 司机端App
  driverApp: {
    framework: 'React Native 0.72',
    stateManagement: 'Redux Toolkit',
    navigation: 'React Navigation 6',
    maps: 'react-native-maps',
    location: 'react-native-geolocation-service',
    backgroundTask: '@react-native-async-storage/async-storage'
  },

  // 管理后台 (Web)
  adminWeb: {
    framework: 'React 18',
    ui: 'Ant Design Pro',
    charts: 'ECharts',
    maps: 'Mapbox GL JS',
    build: 'Vite'
  }
};

// 实时位置更新组件
const LocationTracker = () => {
  const [location, setLocation] = useState(null);
  const socketRef = useRef(null);

  useEffect(() => {
    // 初始化WebSocket连接
    socketRef.current = io('wss://api.ridehailing.com/location', {
      transports: ['websocket'],
      upgrade: false
    });

    // 启动位置监听
    const watchId = Geolocation.watchPosition(
      (position) => {
        const newLocation = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy,
          speed: position.coords.speed,
          bearing: position.coords.heading,
          timestamp: Date.now()
        };

        setLocation(newLocation);

        // 发送位置更新
        if (socketRef.current) {
          socketRef.current.emit('location_update', newLocation);
        }
      },
      (error) => console.error('位置获取失败:', error),
      {
        enableHighAccuracy: true,
        distanceFilter: 10, // 10米更新一次
        interval: 5000,     // 5秒更新一次
        fastestInterval: 3000
      }
    );

    return () => {
      Geolocation.clearWatch(watchId);
      if (socketRef.current) {
        socketRef.current.disconnect();
      }
    };
  }, []);

  return location;
};

// 地图组件
const MapComponent = ({ drivers, userLocation, destination }) => {
  const mapRef = useRef(null);

  const centerMapOnUser = () => {
    if (mapRef.current && userLocation) {
      mapRef.current.animateToRegion({
        ...userLocation,
        latitudeDelta: 0.01,
        longitudeDelta: 0.01
      });
    }
  };

  return (
    <MapView
      ref={mapRef}
      style={{ flex: 1 }}
      initialRegion={{
        latitude: userLocation?.latitude || 39.9042,
        longitude: userLocation?.longitude || 116.4074,
        latitudeDelta: 0.01,
        longitudeDelta: 0.01
      }}
    >
      {/* 用户位置标记 */}
      {userLocation && (
        <Marker
          coordinate={userLocation}
          title="我的位置"
          pinColor="blue"
        />
      )}

      {/* 司机位置标记 */}
      {drivers.map(driver => (
        <Marker
          key={driver.id}
          coordinate={{
            latitude: driver.latitude,
            longitude: driver.longitude
          }}
          title={`司机 ${driver.name}`}
          description={`评分: ${driver.rating} ⭐`}
        >
          <Image
            source={require('./assets/car-icon.png')}
            style={{ width: 30, height: 30 }}
          />
        </Marker>
      ))}

      {/* 目的地标记 */}
      {destination && (
        <Marker
          coordinate={destination}
          title="目的地"
          pinColor="red"
        />
      )}
    </MapView>
  );
};
```

### 2.3 部署架构

#### 2.3.1 容器化部署

```yaml
# Docker Compose 配置
version: '3.8'

services:
  # API网关
  api-gateway:
    image: ride-hailing/api-gateway:latest
    ports:
      - "80:8080"
      - "443:8443"
    environment:
      - EUREKA_CLIENT_SERVICE_URL=http://eureka-server:8761/eureka
    volumes:
      - ./ssl:/etc/ssl/certs
    networks:
      - ride-hailing-network

  # 用户服务
  user-service:
    image: ride-hailing/user-service:latest
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - EUREKA_CLIENT_SERVICE_URL=http://eureka-server:8761/eureka
      - DB_URL=jdbc:mysql://mysql-master:3306/user_db
      - REDIS_CLUSTER=redis-cluster:6379
    networks:
      - ride-hailing-network
    depends_on:
      - mysql-master
      - redis-cluster

  # 位置服务
  location-service:
    image: ride-hailing/location-service:latest
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - INFLUXDB_URL=http://influxdb:8086
      - REDIS_CLUSTER=redis-cluster:6379
    networks:
      - ride-hailing-network
    depends_on:
      - influxdb
      - redis-cluster

  # 匹配服务
  matching-service:
    image: ride-hailing/matching-service:latest
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - KAFKA_BROKERS=kafka-cluster:9092
      - REDIS_CLUSTER=redis-cluster:6379
    networks:
      - ride-hailing-network
    depends_on:
      - kafka-cluster
      - redis-cluster

  # MySQL主库
  mysql-master:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root_password
      - MYSQL_REPLICATION_MODE=master
      - MYSQL_REPLICATION_USER=replica_user
      - MYSQL_REPLICATION_PASSWORD=replica_password
    volumes:
      - mysql-master-data:/var/lib/mysql
      - ./mysql/master.cnf:/etc/mysql/conf.d/master.cnf
    networks:
      - ride-hailing-network

  # Redis集群
  redis-cluster:
    image: redis:6.0-alpine
    command: redis-server /etc/redis/redis.conf
    volumes:
      - ./redis/redis.conf:/etc/redis/redis.conf
      - redis-data:/data
    networks:
      - ride-hailing-network

  # Kafka集群
  kafka-cluster:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka-cluster:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 3
    volumes:
      - kafka-data:/var/lib/kafka/data
    networks:
      - ride-hailing-network

volumes:
  mysql-master-data:
  redis-data:
  kafka-data:

networks:
  ride-hailing-network:
    driver: bridge
```

#### 2.3.2 Kubernetes部署

```yaml
# Kubernetes 部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: matching-service
  namespace: ride-hailing
spec:
  replicas: 10
  selector:
    matchLabels:
      app: matching-service
  template:
    metadata:
      labels:
        app: matching-service
    spec:
      containers:
      - name: matching-service
        image: ride-hailing/matching-service:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: KAFKA_BROKERS
          value: "kafka-cluster:9092"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10

---
apiVersion: v1
kind: Service
metadata:
  name: matching-service
  namespace: ride-hailing
spec:
  selector:
    app: matching-service
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: matching-service-hpa
  namespace: ride-hailing
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: matching-service
  minReplicas: 5
  maxReplicas: 50
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## 3. 地理位置服务

### 3.1 位置数据存储与索引

#### 3.1.1 多层存储架构

```java
/**
 * 位置数据存储架构
 */
@Service
public class LocationStorageService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private InfluxDB influxDB;

    @Autowired
    private LocationRepository locationRepository;

    /**
     * L1缓存：Redis实时位置 (热数据，TTL=10分钟)
     * L2存储：InfluxDB历史轨迹 (时序数据，保留30天)
     * L3存储：MySQL关键位置点 (持久化，无限期)
     */

    /**
     * 更新司机实时位置
     */
    public void updateDriverLocation(String driverId, LocationData location) {
        // 1. 更新Redis实时位置
        updateRealTimeLocation(driverId, location);

        // 2. 异步写入InfluxDB历史轨迹
        CompletableFuture.runAsync(() -> writeToTimeSeries(driverId, location));

        // 3. 关键位置点写入MySQL
        if (isKeyLocation(location)) {
            CompletableFuture.runAsync(() -> persistKeyLocation(driverId, location));
        }

        // 4. 发布位置变更事件
        publishLocationUpdateEvent(driverId, location);
    }

    /**
     * 更新Redis实时位置
     */
    private void updateRealTimeLocation(String driverId, LocationData location) {
        String key = "driver:location:" + driverId;

        // 使用Redis Geo存储地理位置
        redisTemplate.opsForGeo().add(
            "drivers:geo",
            new Point(location.getLongitude(), location.getLatitude()),
            driverId
        );

        // 存储详细位置信息
        redisTemplate.opsForValue().set(key, location, Duration.ofMinutes(10));

        // 更新司机状态索引
        updateDriverStatusIndex(driverId, location);
    }

    /**
     * 写入InfluxDB时序数据库
     */
    private void writeToTimeSeries(String driverId, LocationData location) {
        Point point = Point.measurement("driver_location")
            .time(location.getTimestamp(), TimeUnit.MILLISECONDS)
            .tag("driver_id", driverId)
            .tag("status", location.getStatus().name())
            .addField("latitude", location.getLatitude())
            .addField("longitude", location.getLongitude())
            .addField("accuracy", location.getAccuracy())
            .addField("speed", location.getSpeed())
            .addField("bearing", location.getBearing())
            .build();

        influxDB.write("ride_hailing", "autogen", point);
    }

    /**
     * 关键位置点持久化
     */
    private void persistKeyLocation(String driverId, LocationData location) {
        if (isPickupLocation(location) || isDropoffLocation(location) ||
            isLandmarkLocation(location)) {

            KeyLocationPoint keyPoint = KeyLocationPoint.builder()
                .driverId(driverId)
                .latitude(location.getLatitude())
                .longitude(location.getLongitude())
                .locationType(determineLocationType(location))
                .timestamp(new Date(location.getTimestamp()))
                .build();

            locationRepository.save(keyPoint);
        }
    }

    /**
     * 数据库与Redis缓存一致性保证
     */
    @Transactional
    public void updateLocationWithConsistency(String driverId, LocationData location) {
        try {
            // 1. 开启分布式锁，确保同一司机位置更新的原子性
            String lockKey = "location_update_lock:" + driverId;
            String lockValue = UUID.randomUUID().toString();

            boolean acquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(5));

            if (!acquired) {
                throw new LocationUpdateException("Failed to acquire location update lock for driver: " + driverId);
            }

            try {
                // 2. 先更新数据库（Write-Through策略）
                updateDatabaseLocation(driverId, location);

                // 3. 更新Redis缓存
                updateRedisLocation(driverId, location);

                // 4. 发布缓存更新事件（用于其他节点缓存同步）
                publishCacheUpdateEvent(driverId, location);

            } finally {
                // 释放分布式锁
                releaseLock(lockKey, lockValue);
            }

        } catch (Exception e) {
            log.error("Location update failed for driver: " + driverId, e);
            // 缓存失效策略：删除可能不一致的缓存
            evictLocationCache(driverId);
            throw e;
        }
    }

    /**
     * 更新数据库位置信息
     */
    private void updateDatabaseLocation(String driverId, LocationData location) {
        // 更新司机当前位置表
        DriverLocation driverLocation = DriverLocation.builder()
            .driverId(driverId)
            .latitude(location.getLatitude())
            .longitude(location.getLongitude())
            .accuracy(location.getAccuracy())
            .speed(location.getSpeed())
            .bearing(location.getBearing())
            .timestamp(new Date(location.getTimestamp()))
            .status(location.getStatus())
            .build();

        // 使用ON DUPLICATE KEY UPDATE确保原子性
        locationRepository.saveOrUpdate(driverLocation);

        // 异步写入轨迹历史表
        CompletableFuture.runAsync(() -> {
            LocationTrajectory trajectory = LocationTrajectory.builder()
                .driverId(driverId)
                .latitude(location.getLatitude())
                .longitude(location.getLongitude())
                .timestamp(new Date(location.getTimestamp()))
                .build();
            trajectoryRepository.save(trajectory);
        });
    }

    /**
     * 更新Redis缓存
     */
    private void updateRedisLocation(String driverId, LocationData location) {
        // 使用Redis Pipeline批量操作，确保原子性
        redisTemplate.executePipelined(new SessionCallback<Object>() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {
                // 1. 更新地理位置索引
                operations.opsForGeo().add("drivers:geo",
                    new Point(location.getLongitude(), location.getLatitude()), driverId);

                // 2. 更新位置详情
                String locationKey = "driver:location:" + driverId;
                operations.opsForValue().set(locationKey, location, Duration.ofMinutes(10));

                // 3. 更新位置时间戳
                String timestampKey = "driver:timestamp:" + driverId;
                operations.opsForValue().set(timestampKey, location.getTimestamp(), Duration.ofMinutes(10));

                // 4. 更新司机状态索引
                if (location.getStatus() != null) {
                    String statusKey = "drivers:status:" + location.getStatus().name();
                    operations.opsForSet().add(statusKey, driverId);
                    operations.expire(statusKey, Duration.ofMinutes(15));
                }

                return null;
            }
        });
    }

    /**
     * 缓存一致性修复机制
     */
    @Scheduled(fixedDelay = 30000) // 每30秒执行一次
    public void repairCacheConsistency() {
        try {
            // 1. 检查Redis中的司机位置数据
            Set<String> redisDrivers = redisTemplate.opsForSet().members("active_drivers");

            // 2. 批量检查数据库中的最新位置
            List<String> driverIds = new ArrayList<>(redisDrivers);
            List<DriverLocation> dbLocations = locationRepository.findByDriverIds(driverIds);

            Map<String, DriverLocation> dbLocationMap = dbLocations.stream()
                .collect(Collectors.toMap(DriverLocation::getDriverId, Function.identity()));

            // 3. 比较Redis和数据库的数据一致性
            for (String driverId : driverIds) {
                try {
                    repairDriverLocationConsistency(driverId, dbLocationMap.get(driverId));
                } catch (Exception e) {
                    log.warn("Failed to repair consistency for driver: " + driverId, e);
                }
            }

        } catch (Exception e) {
            log.error("Cache consistency repair failed", e);
        }
    }

    /**
     * 修复单个司机的位置一致性
     */
    private void repairDriverLocationConsistency(String driverId, DriverLocation dbLocation) {
        if (dbLocation == null) {
            // 数据库中无数据，清理Redis缓存
            evictLocationCache(driverId);
            return;
        }

        String locationKey = "driver:location:" + driverId;
        LocationData redisLocation = (LocationData) redisTemplate.opsForValue().get(locationKey);

        if (redisLocation == null) {
            // Redis中无数据，从数据库恢复
            LocationData locationData = convertToLocationData(dbLocation);
            updateRedisLocation(driverId, locationData);
            return;
        }

        // 检查时间戳一致性
        if (Math.abs(redisLocation.getTimestamp() - dbLocation.getTimestamp().getTime()) > 60000) { // 1分钟误差
            // 数据不一致，以数据库为准
            LocationData locationData = convertToLocationData(dbLocation);
            updateRedisLocation(driverId, locationData);

            log.info("Repaired location consistency for driver: {}, timestamp diff: {}ms",
                driverId, Math.abs(redisLocation.getTimestamp() - dbLocation.getTimestamp().getTime()));
        }
    }

    /**
     * 缓存失效策略
     */
    private void evictLocationCache(String driverId) {
        try {
            // 删除相关的Redis键
            List<String> keysToDelete = Arrays.asList(
                "driver:location:" + driverId,
                "driver:timestamp:" + driverId
            );

            redisTemplate.delete(keysToDelete);

            // 从地理位置索引中移除
            redisTemplate.opsForGeo().remove("drivers:geo", driverId);

            // 从状态索引中移除
            for (DriverStatus status : DriverStatus.values()) {
                redisTemplate.opsForSet().remove("drivers:status:" + status.name(), driverId);
            }

            log.info("Evicted location cache for driver: {}", driverId);

        } catch (Exception e) {
            log.error("Failed to evict location cache for driver: " + driverId, e);
        }
    }

    /**
     * 缓存预热策略
     */
    @EventListener
    @Async
    public void warmupLocationCache(ApplicationReadyEvent event) {
        log.info("Starting location cache warmup...");

        try {
            // 1. 加载活跃司机列表
            List<String> activeDrivers = driverService.getActiveDriverIds();

            // 2. 分批预热缓存
            int batchSize = 100;
            for (int i = 0; i < activeDrivers.size(); i += batchSize) {
                List<String> batch = activeDrivers.subList(i, Math.min(i + batchSize, activeDrivers.size()));
                warmupDriverLocationBatch(batch);

                // 避免过度压力
                Thread.sleep(100);
            }

            log.info("Location cache warmup completed for {} drivers", activeDrivers.size());

        } catch (Exception e) {
            log.error("Location cache warmup failed", e);
        }
    }

    /**
     * 批量预热司机位置缓存
     */
    private void warmupDriverLocationBatch(List<String> driverIds) {
        try {
            // 从数据库批量查询位置信息
            List<DriverLocation> locations = locationRepository.findByDriverIds(driverIds);

            // 批量写入Redis
            redisTemplate.executePipelined(new SessionCallback<Object>() {
                @Override
                public Object execute(RedisOperations operations) throws DataAccessException {
                    for (DriverLocation location : locations) {
                        LocationData locationData = convertToLocationData(location);

                        // 更新地理位置索引
                        operations.opsForGeo().add("drivers:geo",
                            new Point(location.getLongitude(), location.getLatitude()),
                            location.getDriverId());

                        // 更新位置详情
                        String locationKey = "driver:location:" + location.getDriverId();
                        operations.opsForValue().set(locationKey, locationData, Duration.ofMinutes(10));

                        // 更新状态索引
                        if (location.getStatus() != null) {
                            String statusKey = "drivers:status:" + location.getStatus().name();
                            operations.opsForSet().add(statusKey, location.getDriverId());
                        }
                    }
                    return null;
                }
            });

        } catch (Exception e) {
            log.error("Failed to warmup location cache for batch", e);
        }
    }

    /**
     * 发布缓存更新事件（用于集群间缓存同步）
     */
    private void publishCacheUpdateEvent(String driverId, LocationData location) {
        LocationCacheUpdateEvent event = LocationCacheUpdateEvent.builder()
            .driverId(driverId)
            .location(location)
            .timestamp(System.currentTimeMillis())
            .sourceServer(getServerId())
            .build();

        redisTemplate.convertAndSend("location_cache_updates", event);
    }

    /**
     * 监听其他节点的缓存更新事件
     */
    @RedisStreamListener
    public void handleLocationCacheUpdate(LocationCacheUpdateEvent event) {
        // 避免处理自己发出的事件
        if (getServerId().equals(event.getSourceServer())) {
            return;
        }

        try {
            // 更新本地缓存
            updateRedisLocation(event.getDriverId(), event.getLocation());
        } catch (Exception e) {
            log.error("Failed to handle location cache update event", e);
        }
    }

    /**
     * 分布式锁释放
     */
    private void releaseLock(String lockKey, String lockValue) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "  return redis.call('del', KEYS[1]) " +
            "else " +
            "  return 0 " +
            "end";

        redisTemplate.execute(RedisScript.of(script, Long.class),
            Collections.singletonList(lockKey), lockValue);
    }

    /**
     * 数据转换方法
     */
    private LocationData convertToLocationData(DriverLocation dbLocation) {
        return LocationData.builder()
            .latitude(dbLocation.getLatitude())
            .longitude(dbLocation.getLongitude())
            .accuracy(dbLocation.getAccuracy())
            .speed(dbLocation.getSpeed())
            .bearing(dbLocation.getBearing())
            .timestamp(dbLocation.getTimestamp().getTime())
            .status(dbLocation.getStatus())
            .build();
    }

    /**
     * 获取服务器ID
     */
    private String getServerId() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            return "unknown";
        }
    }

    /**
     * 更新司机状态索引
     */
    private void updateDriverStatusIndex(String driverId, LocationData location) {
        String statusKey = "drivers:status:" + location.getStatus().name();

        // 从所有状态索引中移除
        Arrays.stream(DriverStatus.values()).forEach(status -> {
            redisTemplate.opsForSet().remove("drivers:status:" + status.name(), driverId);
        });

        // 添加到当前状态索引
        redisTemplate.opsForSet().add(statusKey, driverId);
        redisTemplate.expire(statusKey, Duration.ofMinutes(15));
    }
}

/**
 * 位置缓存一致性监控
 */
@Component
public class LocationCacheConsistencyMonitor {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private LocationRepository locationRepository;

    private final MeterRegistry meterRegistry;

    public LocationCacheConsistencyMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }

    /**
     * 监控缓存一致性
     */
    @Scheduled(fixedDelay = 60000) // 每分钟检查
    public void monitorCacheConsistency() {
        try {
            Set<String> activeDrivers = redisTemplate.opsForSet().members("active_drivers");
            int totalDrivers = activeDrivers.size();
            int inconsistentCount = 0;

            for (String driverId : activeDrivers) {
                if (isDataInconsistent(driverId)) {
                    inconsistentCount++;
                }
            }

            // 记录一致性指标
            double consistencyRatio = totalDrivers > 0 ?
                (double)(totalDrivers - inconsistentCount) / totalDrivers : 1.0;

            meterRegistry.gauge("location.cache.consistency.ratio", consistencyRatio);
            meterRegistry.gauge("location.cache.inconsistent.count", inconsistentCount);

            if (consistencyRatio < 0.95) { // 一致性低于95%时告警
                log.warn("Location cache consistency is low: {}%, inconsistent drivers: {}",
                    consistencyRatio * 100, inconsistentCount);
            }

        } catch (Exception e) {
            log.error("Failed to monitor cache consistency", e);
        }
    }

    /**
     * 检查单个司机数据是否一致
     */
    private boolean isDataInconsistent(String driverId) {
        try {
            // 获取Redis中的位置数据
            String locationKey = "driver:location:" + driverId;
            LocationData cacheLocation = (LocationData) redisTemplate.opsForValue().get(locationKey);

            if (cacheLocation == null) {
                return true; // 缓存缺失
            }

            // 获取数据库中的位置数据
            Optional<DriverLocation> dbLocationOpt = locationRepository.findByDriverId(driverId);
            if (!dbLocationOpt.isPresent()) {
                return true; // 数据库中无数据但缓存中有
            }

            DriverLocation dbLocation = dbLocationOpt.get();

            // 比较关键字段
            return !Objects.equals(cacheLocation.getLatitude(), dbLocation.getLatitude()) ||
                   !Objects.equals(cacheLocation.getLongitude(), dbLocation.getLongitude()) ||
                   !Objects.equals(cacheLocation.getStatus(), dbLocation.getStatus()) ||
                   Math.abs(cacheLocation.getTimestamp() - dbLocation.getTimestamp().getTime()) > 10000; // 10秒差异

        } catch (Exception e) {
            log.error("Failed to check data consistency for driver: {}", driverId, e);
            return true; // 检查失败视为不一致
        }
    }
}

/**
 * 位置缓存刷新策略
 */
@Component
public class LocationCacheRefreshStrategy {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private LocationRepository locationRepository;

    /**
     * 智能缓存刷新
     */
    @Scheduled(fixedDelay = 120000) // 每2分钟执行
    public void intelligentCacheRefresh() {
        try {
            // 1. 识别热点司机（查询频次高的司机）
            Set<String> hotDrivers = identifyHotDrivers();

            // 2. 预测性刷新即将过期的热点司机缓存
            for (String driverId : hotDrivers) {
                String locationKey = "driver:location:" + driverId;
                Long ttl = redisTemplate.getExpire(locationKey);

                // TTL小于2分钟时预刷新
                if (ttl != null && ttl < 120 && ttl > 0) {
                    refreshDriverLocationCache(driverId);
                }
            }

            // 3. 清理僵尸缓存（司机已下线但缓存仍存在）
            cleanupZombieCache();

        } catch (Exception e) {
            log.error("Failed to execute intelligent cache refresh", e);
        }
    }

    /**
     * 识别热点司机
     */
    private Set<String> identifyHotDrivers() {
        // 从Redis中获取访问频次统计
        String pattern = "driver:access:count:*";
        Set<String> keys = redisTemplate.keys(pattern);

        return keys.stream()
            .map(key -> key.substring("driver:access:count:".length()))
            .filter(driverId -> {
                Integer count = (Integer) redisTemplate.opsForValue().get("driver:access:count:" + driverId);
                return count != null && count > 10; // 访问次数超过10次
            })
            .collect(Collectors.toSet());
    }

    /**
     * 刷新司机位置缓存
     */
    private void refreshDriverLocationCache(String driverId) {
        try {
            Optional<DriverLocation> dbLocationOpt = locationRepository.findByDriverId(driverId);
            if (dbLocationOpt.isPresent()) {
                DriverLocation dbLocation = dbLocationOpt.get();
                LocationData locationData = convertToLocationData(dbLocation);

                String locationKey = "driver:location:" + driverId;
                redisTemplate.opsForValue().set(locationKey, locationData, Duration.ofMinutes(10));

                log.debug("Refreshed cache for hot driver: {}", driverId);
            }
        } catch (Exception e) {
            log.error("Failed to refresh cache for driver: {}", driverId, e);
        }
    }

    /**
     * 清理僵尸缓存
     */
    private void cleanupZombieCache() {
        try {
            Set<String> activeDrivers = redisTemplate.opsForSet().members("active_drivers");
            String pattern = "driver:location:*";
            Set<String> locationKeys = redisTemplate.keys(pattern);

            for (String key : locationKeys) {
                String driverId = key.substring("driver:location:".length());
                if (!activeDrivers.contains(driverId)) {
                    redisTemplate.delete(key);
                    log.debug("Cleaned up zombie cache for driver: {}", driverId);
                }
            }
        } catch (Exception e) {
            log.error("Failed to cleanup zombie cache", e);
        }
    }

    private LocationData convertToLocationData(DriverLocation dbLocation) {
        return LocationData.builder()
            .latitude(dbLocation.getLatitude())
            .longitude(dbLocation.getLongitude())
            .accuracy(dbLocation.getAccuracy())
            .speed(dbLocation.getSpeed())
            .bearing(dbLocation.getBearing())
            .timestamp(dbLocation.getTimestamp().getTime())
            .status(dbLocation.getStatus())
            .build();
    }
}

/**
 * 位置缓存验证工具
 */
@Component
public class LocationCacheValidator {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private LocationRepository locationRepository;

    /**
     * 全量缓存一致性验证
     */
    public CacheValidationReport validateAllCache() {
        CacheValidationReport report = new CacheValidationReport();

        try {
            Set<String> activeDrivers = redisTemplate.opsForSet().members("active_drivers");

            for (String driverId : activeDrivers) {
                ValidationResult result = validateDriverCache(driverId);
                report.addResult(driverId, result);
            }

        } catch (Exception e) {
            log.error("Failed to validate cache", e);
            report.setError(e.getMessage());
        }

        return report;
    }

    /**
     * 验证单个司机缓存
     */
    public ValidationResult validateDriverCache(String driverId) {
        ValidationResult result = new ValidationResult();
        result.setDriverId(driverId);

        try {
            // 检查Redis缓存
            String locationKey = "driver:location:" + driverId;
            LocationData cacheLocation = (LocationData) redisTemplate.opsForValue().get(locationKey);

            // 检查数据库
            Optional<DriverLocation> dbLocationOpt = locationRepository.findByDriverId(driverId);

            if (cacheLocation == null && !dbLocationOpt.isPresent()) {
                result.setStatus(ValidationStatus.BOTH_MISSING);
            } else if (cacheLocation == null) {
                result.setStatus(ValidationStatus.CACHE_MISSING);
            } else if (!dbLocationOpt.isPresent()) {
                result.setStatus(ValidationStatus.DB_MISSING);
            } else {
                // 比较数据一致性
                DriverLocation dbLocation = dbLocationOpt.get();
                if (isDataConsistent(cacheLocation, dbLocation)) {
                    result.setStatus(ValidationStatus.CONSISTENT);
                } else {
                    result.setStatus(ValidationStatus.INCONSISTENT);
                    result.setInconsistencies(findInconsistencies(cacheLocation, dbLocation));
                }
            }

        } catch (Exception e) {
            result.setStatus(ValidationStatus.ERROR);
            result.setError(e.getMessage());
        }

        return result;
    }

    /**
     * 检查数据一致性
     */
    private boolean isDataConsistent(LocationData cacheData, DriverLocation dbData) {
        return Objects.equals(cacheData.getLatitude(), dbData.getLatitude()) &&
               Objects.equals(cacheData.getLongitude(), dbData.getLongitude()) &&
               Objects.equals(cacheData.getStatus(), dbData.getStatus()) &&
               Math.abs(cacheData.getTimestamp() - dbData.getTimestamp().getTime()) <= 5000;
    }

    /**
     * 查找不一致的字段
     */
    private List<String> findInconsistencies(LocationData cacheData, DriverLocation dbData) {
        List<String> inconsistencies = new ArrayList<>();

        if (!Objects.equals(cacheData.getLatitude(), dbData.getLatitude())) {
            inconsistencies.add("latitude");
        }
        if (!Objects.equals(cacheData.getLongitude(), dbData.getLongitude())) {
            inconsistencies.add("longitude");
        }
        if (!Objects.equals(cacheData.getStatus(), dbData.getStatus())) {
            inconsistencies.add("status");
        }
        if (Math.abs(cacheData.getTimestamp() - dbData.getTimestamp().getTime()) > 5000) {
            inconsistencies.add("timestamp");
        }

        return inconsistencies;
    }

    @Data
    public static class CacheValidationReport {
        private Map<String, ValidationResult> results = new HashMap<>();
        private long totalDrivers;
        private long consistentCount;
        private long inconsistentCount;
        private long errorCount;
        private String error;

        public void addResult(String driverId, ValidationResult result) {
            results.put(driverId, result);
            totalDrivers++;

            switch (result.getStatus()) {
                case CONSISTENT:
                    consistentCount++;
                    break;
                case INCONSISTENT:
                case CACHE_MISSING:
                case DB_MISSING:
                    inconsistentCount++;
                    break;
                case ERROR:
                    errorCount++;
                    break;
            }
        }

        public double getConsistencyRatio() {
            return totalDrivers > 0 ? (double) consistentCount / totalDrivers : 0.0;
        }
    }

    @Data
    public static class ValidationResult {
        private String driverId;
        private ValidationStatus status;
        private List<String> inconsistencies = new ArrayList<>();
        private String error;
    }

    public enum ValidationStatus {
        CONSISTENT,       // 数据一致
        INCONSISTENT,     // 数据不一致
        CACHE_MISSING,    // 缓存缺失
        DB_MISSING,       // 数据库缺失
        BOTH_MISSING,     // 都缺失
        ERROR            // 验证错误
    }
}

/**
 * 位置布隆过滤器（防止缓存穿透）
 */
@Component
public class LocationBloomFilter {

    private final BloomFilter<String> driverBloomFilter;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    public LocationBloomFilter() {
        // 预估100万司机，误判率0.01%
        this.driverBloomFilter = BloomFilter.create(
            Funnels.stringFunnel(Charset.defaultCharset()),
            1_000_000,
            0.0001
        );
    }

    /**
     * 初始化布隆过滤器
     */
    @PostConstruct
    public void initBloomFilter() {
        try {
            // 从Redis中获取现有的司机列表
            Set<String> activeDrivers = redisTemplate.opsForSet().members("active_drivers");
            for (String driverId : activeDrivers) {
                driverBloomFilter.put(driverId);
            }

            log.info("Initialized bloom filter with {} drivers", activeDrivers.size());

        } catch (Exception e) {
            log.error("Failed to initialize bloom filter", e);
        }
    }

    /**
     * 添加司机到布隆过滤器
     */
    public void addDriver(String driverId) {
        driverBloomFilter.put(driverId);
    }

    /**
     * 检查司机是否可能存在
     */
    public boolean mightContain(String driverId) {
        return driverBloomFilter.mightContain(driverId);
    }

    /**
     * 定期重建布隆过滤器
     */
    @Scheduled(fixedDelay = 3600000) // 每小时重建
    public void rebuildBloomFilter() {
        try {
            // 创建新的布隆过滤器
            BloomFilter<String> newFilter = BloomFilter.create(
                Funnels.stringFunnel(Charset.defaultCharset()),
                1_000_000,
                0.0001
            );

            // 重新加载司机数据
            Set<String> activeDrivers = redisTemplate.opsForSet().members("active_drivers");
            for (String driverId : activeDrivers) {
                newFilter.put(driverId);
            }

            // 原子性替换
            synchronized (this) {
                // 注意：这里简化处理，实际应用中需要更复杂的并发控制
                driverBloomFilter.clear();
                for (String driverId : activeDrivers) {
                    driverBloomFilter.put(driverId);
                }
            }

            log.info("Rebuilt bloom filter with {} drivers", activeDrivers.size());

        } catch (Exception e) {
            log.error("Failed to rebuild bloom filter", e);
        }
    }
}
```

#### 3.1.2 地理空间索引算法

```java
/**
 * 地理空间索引实现
 */
@Component
public class GeospatialIndexService {

    /**
     * GeoHash编码实现
     */
    public static class GeoHashEncoder {

        private static final String BASE32 = "0123456789bcdefghjkmnpqrstuvwxyz";
        private static final int[] BITS = {16, 8, 4, 2, 1};

        /**
         * 将经纬度编码为GeoHash
         */
        public static String encode(double latitude, double longitude, int precision) {
            double[] latRange = {-90.0, 90.0};
            double[] lonRange = {-180.0, 180.0};

            StringBuilder geohash = new StringBuilder();
            boolean isEven = true;
            int bit = 0;
            int ch = 0;

            while (geohash.length() < precision) {
                double mid;
                if (isEven) {
                    // 处理经度
                    mid = (lonRange[0] + lonRange[1]) / 2;
                    if (longitude >= mid) {
                        ch |= BITS[bit];
                        lonRange[0] = mid;
                    } else {
                        lonRange[1] = mid;
                    }
                } else {
                    // 处理纬度
                    mid = (latRange[0] + latRange[1]) / 2;
                    if (latitude >= mid) {
                        ch |= BITS[bit];
                        latRange[0] = mid;
                    } else {
                        latRange[1] = mid;
                    }
                }

                isEven = !isEven;
                if (bit < 4) {
                    bit++;
                } else {
                    geohash.append(BASE32.charAt(ch));
                    bit = 0;
                    ch = 0;
                }
            }

            return geohash.toString();
        }

        /**
         * 获取相邻的GeoHash区域
         */
        public static List<String> getNeighbors(String geohash) {
            List<String> neighbors = new ArrayList<>();

            // 获取8个相邻区域
            neighbors.add(getNeighbor(geohash, "top"));
            neighbors.add(getNeighbor(geohash, "bottom"));
            neighbors.add(getNeighbor(geohash, "left"));
            neighbors.add(getNeighbor(geohash, "right"));
            neighbors.add(getNeighbor(geohash, "top-left"));
            neighbors.add(getNeighbor(geohash, "top-right"));
            neighbors.add(getNeighbor(geohash, "bottom-left"));
            neighbors.add(getNeighbor(geohash, "bottom-right"));

            return neighbors.stream().filter(Objects::nonNull).collect(Collectors.toList());
        }

        private static String getNeighbor(String geohash, String direction) {
            // 实现GeoHash邻居计算算法
            // 这里简化实现，实际需要完整的邻居计算逻辑
            return null;
        }
    }

    /**
     * 四叉树空间索引
     */
    public static class QuadTreeIndex {

        @Data
        public static class QuadTreeNode {
            private Rectangle bounds;           // 边界矩形
            private List<DriverLocation> drivers; // 司机列表
            private QuadTreeNode[] children;    // 子节点
            private boolean isLeaf;            // 是否叶子节点
            private static final int MAX_CAPACITY = 50; // 最大容量

            public QuadTreeNode(Rectangle bounds) {
                this.bounds = bounds;
                this.drivers = new ArrayList<>();
                this.children = new QuadTreeNode[4];
                this.isLeaf = true;
            }

            /**
             * 插入司机位置
             */
            public void insert(DriverLocation driver) {
                if (!bounds.contains(driver.getLatitude(), driver.getLongitude())) {
                    return; // 不在当前区域内
                }

                if (isLeaf) {
                    drivers.add(driver);
                    if (drivers.size() > MAX_CAPACITY) {
                        subdivide(); // 分裂节点
                    }
                } else {
                    // 递归插入到子节点
                    for (QuadTreeNode child : children) {
                        child.insert(driver);
                    }
                }
            }

            /**
             * 查询范围内的司机
             */
            public List<DriverLocation> queryRange(Rectangle range) {
                List<DriverLocation> result = new ArrayList<>();

                if (!bounds.intersects(range)) {
                    return result; // 不相交，直接返回
                }

                if (isLeaf) {
                    for (DriverLocation driver : drivers) {
                        if (range.contains(driver.getLatitude(), driver.getLongitude())) {
                            result.add(driver);
                        }
                    }
                } else {
                    for (QuadTreeNode child : children) {
                        result.addAll(child.queryRange(range));
                    }
                }

                return result;
            }

            /**
             * 分裂节点
             */
            private void subdivide() {
                double centerLat = (bounds.getMinLat() + bounds.getMaxLat()) / 2;
                double centerLon = (bounds.getMinLon() + bounds.getMaxLon()) / 2;

                // 创建四个子区域
                children[0] = new QuadTreeNode(new Rectangle(
                    bounds.getMinLat(), centerLat, bounds.getMinLon(), centerLon)); // 西南
                children[1] = new QuadTreeNode(new Rectangle(
                    bounds.getMinLat(), centerLat, centerLon, bounds.getMaxLon())); // 东南
                children[2] = new QuadTreeNode(new Rectangle(
                    centerLat, bounds.getMaxLat(), bounds.getMinLon(), centerLon)); // 西北
                children[3] = new QuadTreeNode(new Rectangle(
                    centerLat, bounds.getMaxLat(), centerLon, bounds.getMaxLon())); // 东北

                // 重新分配司机到子节点
                for (DriverLocation driver : drivers) {
                    for (QuadTreeNode child : children) {
                        child.insert(driver);
                    }
                }

                drivers.clear();
                isLeaf = false;
            }
        }

        @Data
        public static class Rectangle {
            private double minLat, maxLat, minLon, maxLon;

            public Rectangle(double minLat, double maxLat, double minLon, double maxLon) {
                this.minLat = minLat;
                this.maxLat = maxLat;
                this.minLon = minLon;
                this.maxLon = maxLon;
            }

            public boolean contains(double lat, double lon) {
                return lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon;
            }

            public boolean intersects(Rectangle other) {
                return !(other.maxLat < minLat || other.minLat > maxLat ||
                        other.maxLon < minLon || other.minLon > maxLon);
            }
        }

        @Data
        public static class DriverLocation {
            private String driverId;
            private double latitude;
            private double longitude;
            private DriverStatus status;
            private long timestamp;
        }
    }
}
```

### 3.2 附近司机查询服务

#### 3.2.1 多策略查询算法

```java
/**
 * 附近司机查询服务
 */
@Service
public class NearbyDriverQueryService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private GeospatialIndexService geospatialIndexService;

    /**
     * 查询附近可用司机
     */
    public List<DriverInfo> findNearbyDrivers(NearbyDriverQuery query) {
        // 根据场景选择最优查询策略
        QueryStrategy strategy = selectOptimalStrategy(query);

        switch (strategy) {
            case REDIS_GEO:
                return queryByRedisGeo(query);
            case GEOHASH:
                return queryByGeoHash(query);
            case QUADTREE:
                return queryByQuadTree(query);
            default:
                return queryByRedisGeo(query); // 默认策略
        }
    }

    /**
     * Redis Geo查询 (适用于实时查询)
     */
    private List<DriverInfo> queryByRedisGeo(NearbyDriverQuery query) {
        // 1. 使用Redis GEORADIUS查询
        GeoResults<RedisGeoCommands.GeoLocation<String>> results = redisTemplate.opsForGeo()
            .radius("drivers:geo",
                new Circle(new Point(query.getLongitude(), query.getLatitude()),
                          new Distance(query.getRadius(), Metrics.KILOMETERS)),
                RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()
                    .includeDistance()
                    .includeCoordinates()
                    .sortAscending()
                    .limit(query.getLimit()));

        List<DriverInfo> drivers = new ArrayList<>();

        for (GeoResult<RedisGeoCommands.GeoLocation<String>> result : results) {
            String driverId = result.getContent().getName();
            double distance = result.getDistance().getValue();

            // 2. 获取司机详细信息
            DriverInfo driver = getDriverDetails(driverId);
            if (driver != null && isDriverAvailable(driver, query)) {
                driver.setDistance(distance);
                drivers.add(driver);
            }

            if (drivers.size() >= query.getLimit()) {
                break;
            }
        }

        // 3. 按优先级排序
        return sortDriversByPriority(drivers, query);
    }

    /**
     * GeoHash查询 (适用于大范围查询)
     */
    private List<DriverInfo> queryByGeoHash(NearbyDriverQuery query) {
        // 1. 计算查询点的GeoHash
        String centerGeoHash = GeospatialIndexService.GeoHashEncoder.encode(
            query.getLatitude(), query.getLongitude(), 7);

        // 2. 获取相邻区域
        List<String> searchAreas = new ArrayList<>();
        searchAreas.add(centerGeoHash);
        searchAreas.addAll(GeospatialIndexService.GeoHashEncoder.getNeighbors(centerGeoHash));

        List<DriverInfo> candidates = new ArrayList<>();

        // 3. 查询每个区域的司机
        for (String geoHash : searchAreas) {
            Set<String> driverIds = redisTemplate.opsForSet()
                .members("geohash:" + geoHash);

            if (driverIds != null) {
                for (String driverId : driverIds) {
                    DriverInfo driver = getDriverDetails(driverId);
                    if (driver != null && isDriverAvailable(driver, query)) {
                        double distance = calculateDistance(
                            query.getLatitude(), query.getLongitude(),
                            driver.getLatitude(), driver.getLongitude());

                        if (distance <= query.getRadius()) {
                            driver.setDistance(distance);
                            candidates.add(driver);
                        }
                    }
                }
            }
        }

        // 4. 排序并限制数量
        return candidates.stream()
            .sorted(Comparator.comparingDouble(DriverInfo::getDistance))
            .limit(query.getLimit())
            .collect(Collectors.toList());
    }

    /**
     * 四叉树查询 (适用于高精度查询)
     */
    private List<DriverInfo> queryByQuadTree(NearbyDriverQuery query) {
        // 构建查询矩形
        double radius = query.getRadius();
        GeospatialIndexService.QuadTreeIndex.Rectangle queryRange =
            new GeospatialIndexService.QuadTreeIndex.Rectangle(
                query.getLatitude() - radius / 111.0,  // 1度约等于111km
                query.getLatitude() + radius / 111.0,
                query.getLongitude() - radius / (111.0 * Math.cos(Math.toRadians(query.getLatitude()))),
                query.getLongitude() + radius / (111.0 * Math.cos(Math.toRadians(query.getLatitude())))
            );

        // 查询四叉树
        List<GeospatialIndexService.QuadTreeIndex.DriverLocation> locations =
            getQuadTreeIndex().queryRange(queryRange);

        List<DriverInfo> drivers = new ArrayList<>();

        for (GeospatialIndexService.QuadTreeIndex.DriverLocation location : locations) {
            double distance = calculateDistance(
                query.getLatitude(), query.getLongitude(),
                location.getLatitude(), location.getLongitude());

            if (distance <= query.getRadius()) {
                DriverInfo driver = getDriverDetails(location.getDriverId());
                if (driver != null && isDriverAvailable(driver, query)) {
                    driver.setDistance(distance);
                    drivers.add(driver);
                }
            }
        }

        return drivers.stream()
            .sorted(Comparator.comparingDouble(DriverInfo::getDistance))
            .limit(query.getLimit())
            .collect(Collectors.toList());
    }

    /**
     * 选择最优查询策略
     */
    private QueryStrategy selectOptimalStrategy(NearbyDriverQuery query) {
        // 根据查询参数和系统负载选择策略
        if (query.getRadius() <= 5.0) {
            return QueryStrategy.REDIS_GEO; // 小范围查询使用Redis Geo
        } else if (query.getRadius() <= 20.0) {
            return QueryStrategy.GEOHASH;   // 中等范围使用GeoHash
        } else {
            return QueryStrategy.QUADTREE;  // 大范围使用四叉树
        }
    }

    /**
     * 检查司机是否可用
     */
    private boolean isDriverAvailable(DriverInfo driver, NearbyDriverQuery query) {
        // 1. 状态检查
        if (driver.getStatus() != DriverStatus.ONLINE) {
            return false;
        }

        // 2. 车型匹配
        if (query.getVehicleType() != null &&
            !driver.getVehicleType().equals(query.getVehicleType())) {
            return false;
        }

        // 3. 评分过滤
        if (query.getMinRating() > 0 && driver.getRating() < query.getMinRating()) {
            return false;
        }

        // 4. 位置新鲜度检查
        long locationAge = System.currentTimeMillis() - driver.getLastLocationUpdate();
        if (locationAge > 60000) { // 位置超过1分钟认为过期
            return false;
        }

        return true;
    }

    /**
     * 按优先级排序司机
     */
    private List<DriverInfo> sortDriversByPriority(List<DriverInfo> drivers, NearbyDriverQuery query) {
        return drivers.stream()
            .sorted((d1, d2) -> {
                // 1. 距离权重 (40%)
                double distanceScore1 = 1.0 / (1.0 + d1.getDistance());
                double distanceScore2 = 1.0 / (1.0 + d2.getDistance());

                // 2. 评分权重 (30%)
                double ratingScore1 = d1.getRating() / 5.0;
                double ratingScore2 = d2.getRating() / 5.0;

                // 3. 完单率权重 (20%)
                double completionScore1 = d1.getCompletionRate();
                double completionScore2 = d2.getCompletionRate();

                // 4. 响应时间权重 (10%)
                double responseScore1 = 1.0 / (1.0 + d1.getAverageResponseTime());
                double responseScore2 = 1.0 / (1.0 + d2.getAverageResponseTime());

                double totalScore1 = distanceScore1 * 0.4 + ratingScore1 * 0.3 +
                                   completionScore1 * 0.2 + responseScore1 * 0.1;
                double totalScore2 = distanceScore2 * 0.4 + ratingScore2 * 0.3 +
                                   completionScore2 * 0.2 + responseScore2 * 0.1;

                return Double.compare(totalScore2, totalScore1); // 降序排列
            })
            .collect(Collectors.toList());
    }

    private enum QueryStrategy {
        REDIS_GEO, GEOHASH, QUADTREE
    }

    @Data
    public static class NearbyDriverQuery {
        private double latitude;        // 查询中心纬度
        private double longitude;       // 查询中心经度
        private double radius;          // 查询半径(公里)
        private int limit;             // 返回数量限制
        private VehicleType vehicleType; // 车型过滤
        private double minRating;       // 最低评分
        private boolean includeDistance; // 是否包含距离信息
    }

    @Data
    public static class DriverInfo {
        private String driverId;
        private String name;
        private double latitude;
        private double longitude;
        private DriverStatus status;
        private VehicleType vehicleType;
        private double rating;
        private double completionRate;
        private long averageResponseTime;
        private long lastLocationUpdate;
        private double distance; // 到查询点的距离
    }
}
```

### 3.3 位置轨迹分析

#### 3.3.1 轨迹数据处理

```java
/**
 * 位置轨迹分析服务
 */
@Service
public class LocationTrajectoryService {

    @Autowired
    private InfluxDB influxDB;

    /**
     * 轨迹分析和异常检测
     */
    public TrajectoryAnalysisResult analyzeTrajectory(String driverId, long startTime, long endTime) {
        // 1. 查询轨迹数据
        List<LocationPoint> trajectory = queryTrajectoryData(driverId, startTime, endTime);

        if (trajectory.size() < 2) {
            return TrajectoryAnalysisResult.empty();
        }

        // 2. 轨迹清洗和预处理
        trajectory = cleanTrajectoryData(trajectory);

        // 3. 计算基础统计信息
        TrajectoryStats stats = calculateTrajectoryStats(trajectory);

        // 4. 异常检测
        List<TrajectoryAnomaly> anomalies = detectAnomalies(trajectory);

        // 5. 路径分析
        RouteAnalysis routeAnalysis = analyzeRoute(trajectory);

        return TrajectoryAnalysisResult.builder()
            .driverId(driverId)
            .startTime(startTime)
            .endTime(endTime)
            .trajectory(trajectory)
            .stats(stats)
            .anomalies(anomalies)
            .routeAnalysis(routeAnalysis)
            .build();
    }

    /**
     * 查询轨迹数据
     */
    private List<LocationPoint> queryTrajectoryData(String driverId, long startTime, long endTime) {
        String query = String.format(
            "SELECT time, latitude, longitude, speed, bearing " +
            "FROM driver_location " +
            "WHERE driver_id = '%s' AND time >= %d AND time <= %d " +
            "ORDER BY time ASC",
            driverId, startTime * 1_000_000, endTime * 1_000_000 // InfluxDB使用纳秒
        );

        QueryResult result = influxDB.query(new Query(query, "ride_hailing"));
        List<LocationPoint> points = new ArrayList<>();

        for (QueryResult.Series series : result.getResults().get(0).getSeries()) {
            for (List<Object> values : series.getValues()) {
                LocationPoint point = LocationPoint.builder()
                    .timestamp(Instant.parse(values.get(0).toString()).toEpochMilli())
                    .latitude(Double.parseDouble(values.get(1).toString()))
                    .longitude(Double.parseDouble(values.get(2).toString()))
                    .speed(values.get(3) != null ? Double.parseDouble(values.get(3).toString()) : 0.0)
                    .bearing(values.get(4) != null ? Double.parseDouble(values.get(4).toString()) : 0.0)
                    .build();
                points.add(point);
            }
        }

        return points;
    }

    /**
     * 轨迹数据清洗
     */
    private List<LocationPoint> cleanTrajectoryData(List<LocationPoint> trajectory) {
        List<LocationPoint> cleaned = new ArrayList<>();

        for (int i = 0; i < trajectory.size(); i++) {
            LocationPoint current = trajectory.get(i);

            // 1. 过滤明显错误的GPS点
            if (!isValidGPSPoint(current)) {
                continue;
            }

            // 2. 过滤漂移点
            if (i > 0 && isDriftPoint(trajectory.get(i - 1), current)) {
                continue;
            }

            // 3. 过滤重复点
            if (i > 0 && isDuplicatePoint(trajectory.get(i - 1), current)) {
                continue;
            }

            cleaned.add(current);
        }

        return cleaned;
    }

    /**
     * 计算轨迹统计信息
     */
    private TrajectoryStats calculateTrajectoryStats(List<LocationPoint> trajectory) {
        double totalDistance = 0.0;
        double maxSpeed = 0.0;
        double totalDuration = 0.0;
        int stopCount = 0;
        List<Double> speeds = new ArrayList<>();

        for (int i = 1; i < trajectory.size(); i++) {
            LocationPoint prev = trajectory.get(i - 1);
            LocationPoint curr = trajectory.get(i);

            // 计算距离
            double distance = calculateDistance(
                prev.getLatitude(), prev.getLongitude(),
                curr.getLatitude(), curr.getLongitude()
            );
            totalDistance += distance;

            // 计算时间
            double duration = (curr.getTimestamp() - prev.getTimestamp()) / 1000.0; // 秒
            totalDuration += duration;

            // 计算速度
            double speed = duration > 0 ? (distance * 3600 / duration) : 0; // km/h
            speeds.add(speed);
            maxSpeed = Math.max(maxSpeed, speed);

            // 检测停车
            if (speed < 5.0 && duration > 30) { // 速度低于5km/h且持续30秒以上
                stopCount++;
            }
        }

        double averageSpeed = speeds.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);

        return TrajectoryStats.builder()
            .totalDistance(totalDistance)
            .totalDuration(totalDuration)
            .averageSpeed(averageSpeed)
            .maxSpeed(maxSpeed)
            .stopCount(stopCount)
            .pointCount(trajectory.size())
            .build();
    }

    /**
     * 异常检测
     */
    private List<TrajectoryAnomaly> detectAnomalies(List<LocationPoint> trajectory) {
        List<TrajectoryAnomaly> anomalies = new ArrayList<>();

        for (int i = 1; i < trajectory.size(); i++) {
            LocationPoint prev = trajectory.get(i - 1);
            LocationPoint curr = trajectory.get(i);

            // 1. 速度异常检测
            double speed = calculateSpeed(prev, curr);
            if (speed > 150) { // 超过150km/h
                anomalies.add(TrajectoryAnomaly.builder()
                    .type(AnomalyType.EXCESSIVE_SPEED)
                    .timestamp(curr.getTimestamp())
                    .location(curr)
                    .value(speed)
                    .description("异常高速: " + String.format("%.1f km/h", speed))
                    .build());
            }

            // 2. 瞬移检测
            double distance = calculateDistance(
                prev.getLatitude(), prev.getLongitude(),
                curr.getLatitude(), curr.getLongitude()
            );
            double timeGap = (curr.getTimestamp() - prev.getTimestamp()) / 1000.0;

            if (timeGap > 0 && distance / timeGap > 50) { // 超过50m/s
                anomalies.add(TrajectoryAnomaly.builder()
                    .type(AnomalyType.TELEPORTATION)
                    .timestamp(curr.getTimestamp())
                    .location(curr)
                    .value(distance)
                    .description("可能的GPS漂移或瞬移: " + String.format("%.1f米", distance))
                    .build());
            }

            // 3. 长时间停留检测
            if (speed < 1.0 && timeGap > 600) { // 静止超过10分钟
                anomalies.add(TrajectoryAnomaly.builder()
                    .type(AnomalyType.LONG_STAY)
                    .timestamp(curr.getTimestamp())
                    .location(curr)
                    .value(timeGap)
                    .description("长时间停留: " + String.format("%.1f分钟", timeGap / 60))
                    .build());
            }
        }

        return anomalies;
    }

    /**
     * 路径分析
     */
    private RouteAnalysis analyzeRoute(List<LocationPoint> trajectory) {
        // 1. 路径偏离检测
        List<RouteDeviation> deviations = detectRouteDeviations(trajectory);

        // 2. 热力图数据生成
        List<HeatmapPoint> heatmapData = generateHeatmapData(trajectory);

        // 3. 道路类型分析
        RoadTypeAnalysis roadTypeAnalysis = analyzeRoadTypes(trajectory);

        return RouteAnalysis.builder()
            .deviations(deviations)
            .heatmapData(heatmapData)
            .roadTypeAnalysis(roadTypeAnalysis)
            .build();
    }

    /**
     * 检测路径偏离
     */
    private List<RouteDeviation> detectRouteDeviations(List<LocationPoint> trajectory) {
        // 实现路径偏离检测算法
        // 可以与预期路径对比，检测绕路、逆行等行为
        return new ArrayList<>();
    }

    /**
     * 生成热力图数据
     */
    private List<HeatmapPoint> generateHeatmapData(List<LocationPoint> trajectory) {
        Map<String, HeatmapPoint> heatmap = new HashMap<>();

        for (LocationPoint point : trajectory) {
            // 使用GeoHash将相近的点聚合
            String geoHash = GeospatialIndexService.GeoHashEncoder.encode(
                point.getLatitude(), point.getLongitude(), 6);

            HeatmapPoint heatPoint = heatmap.computeIfAbsent(geoHash, k ->
                HeatmapPoint.builder()
                    .latitude(point.getLatitude())
                    .longitude(point.getLongitude())
                    .intensity(0)
                    .build());

            heatPoint.setIntensity(heatPoint.getIntensity() + 1);
        }

        return new ArrayList<>(heatmap.values());
    }

    // 辅助方法
    private boolean isValidGPSPoint(LocationPoint point) {
        return point.getLatitude() >= -90 && point.getLatitude() <= 90 &&
               point.getLongitude() >= -180 && point.getLongitude() <= 180;
    }

    private boolean isDriftPoint(LocationPoint prev, LocationPoint curr) {
        double distance = calculateDistance(
            prev.getLatitude(), prev.getLongitude(),
            curr.getLatitude(), curr.getLongitude()
        );
        double timeGap = (curr.getTimestamp() - prev.getTimestamp()) / 1000.0;

        // 如果速度超过物理极限（如200km/h），认为是漂移点
        return timeGap > 0 && (distance / timeGap) > 55.6; // 200km/h = 55.6m/s
    }

    private boolean isDuplicatePoint(LocationPoint prev, LocationPoint curr) {
        double distance = calculateDistance(
            prev.getLatitude(), prev.getLongitude(),
            curr.getLatitude(), curr.getLongitude()
        );
        return distance < 5.0; // 小于5米认为是重复点
    }

    private double calculateSpeed(LocationPoint prev, LocationPoint curr) {
        double distance = calculateDistance(
            prev.getLatitude(), prev.getLongitude(),
            curr.getLatitude(), curr.getLongitude()
        );
        double timeGap = (curr.getTimestamp() - prev.getTimestamp()) / 1000.0;
        return timeGap > 0 ? (distance * 3600 / timeGap) : 0; // km/h
    }

    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        // Haversine公式计算球面距离
        final double EARTH_RADIUS = 6371000; // 地球半径(米)

        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);

        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return EARTH_RADIUS * c;
    }

    // 数据模型类
    @Data
    @Builder
    public static class LocationPoint {
        private long timestamp;
        private double latitude;
        private double longitude;
        private double speed;
        private double bearing;
    }

    @Data
    @Builder
    public static class TrajectoryStats {
        private double totalDistance;      // 总距离(米)
        private double totalDuration;      // 总时长(秒)
        private double averageSpeed;       // 平均速度(km/h)
        private double maxSpeed;           // 最高速度(km/h)
        private int stopCount;             // 停车次数
        private int pointCount;            // 轨迹点数量
    }

    @Data
    @Builder
    public static class TrajectoryAnomaly {
        private AnomalyType type;
        private long timestamp;
        private LocationPoint location;
        private double value;
        private String description;
    }

    @Data
    @Builder
    public static class HeatmapPoint {
        private double latitude;
        private double longitude;
        private int intensity;
    }

    public enum AnomalyType {
        EXCESSIVE_SPEED,    // 超速
        TELEPORTATION,      // 瞬移
        LONG_STAY,         // 长时间停留
        ROUTE_DEVIATION,   // 路径偏离
        GPS_DRIFT          // GPS漂移
    }
}
```

### 3.4 地理围栏服务

#### 3.4.1 动态围栏管理

```java
/**
 * 地理围栏服务
 */
@Service
public class GeofenceService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private GeofenceRepository geofenceRepository;

    /**
     * 创建地理围栏
     */
    public void createGeofence(GeofenceDefinition definition) {
        // 1. 保存到数据库
        Geofence geofence = Geofence.builder()
            .id(definition.getId())
            .name(definition.getName())
            .type(definition.getType())
            .geometry(definition.getGeometry())
            .properties(definition.getProperties())
            .isActive(true)
            .createTime(new Date())
            .build();

        geofenceRepository.save(geofence);

        // 2. 构建空间索引
        buildSpatialIndex(geofence);

        // 3. 缓存到Redis
        cacheGeofence(geofence);

        log.info("地理围栏已创建: {}", definition.getName());
    }

    /**
     * 检查位置是否在围栏内
     */
    public List<GeofenceEvent> checkGeofences(String entityId, LocationData location) {
        List<GeofenceEvent> events = new ArrayList<>();

        // 1. 获取当前位置附近的所有围栏
        List<Geofence> nearbyFences = findNearbyGeofences(location);

        // 2. 获取实体的历史状态
        Set<String> previousFences = getPreviousGeofenceState(entityId);
        Set<String> currentFences = new HashSet<>();

        // 3. 检查每个围栏
        for (Geofence fence : nearbyFences) {
            if (isPointInGeofence(location, fence)) {
                currentFences.add(fence.getId());

                // 检查是否是新进入
                if (!previousFences.contains(fence.getId())) {
                    events.add(GeofenceEvent.builder()
                        .entityId(entityId)
                        .geofenceId(fence.getId())
                        .geofenceName(fence.getName())
                        .eventType(GeofenceEventType.ENTER)
                        .location(location)
                        .timestamp(System.currentTimeMillis())
                        .build());
                }
            }
        }

        // 4. 检查离开事件
        for (String previousFenceId : previousFences) {
            if (!currentFences.contains(previousFenceId)) {
                Geofence fence = getGeofenceById(previousFenceId);
                if (fence != null) {
                    events.add(GeofenceEvent.builder()
                        .entityId(entityId)
                        .geofenceId(fence.getId())
                        .geofenceName(fence.getName())
                        .eventType(GeofenceEventType.EXIT)
                        .location(location)
                        .timestamp(System.currentTimeMillis())
                        .build());
                }
            }
        }

        // 5. 更新状态
        updateGeofenceState(entityId, currentFences);

        // 6. 发布事件
        publishGeofenceEvents(events);

        return events;
    }

    /**
     * 查找附近的地理围栏
     */
    private List<Geofence> findNearbyGeofences(LocationData location) {
        // 使用GeoHash快速查找
        String geoHash = GeospatialIndexService.GeoHashEncoder.encode(
            location.getLatitude(), location.getLongitude(), 6);

        List<String> searchAreas = new ArrayList<>();
        searchAreas.add(geoHash);
        searchAreas.addAll(GeospatialIndexService.GeoHashEncoder.getNeighbors(geoHash));

        Set<String> geofenceIds = new HashSet<>();
        for (String area : searchAreas) {
            Set<String> ids = redisTemplate.opsForSet()
                .members("geofence:area:" + area);
            if (ids != null) {
                geofenceIds.addAll(ids);
            }
        }

        List<Geofence> geofences = new ArrayList<>();
        for (String geofenceId : geofenceIds) {
            Geofence fence = getGeofenceFromCache(geofenceId);
            if (fence != null && fence.isActive()) {
                geofences.add(fence);
            }
        }

        return geofences;
    }

    /**
     * 检查点是否在地理围栏内
     */
    private boolean isPointInGeofence(LocationData location, Geofence geofence) {
        GeofenceGeometry geometry = geofence.getGeometry();

        switch (geometry.getType()) {
            case CIRCLE:
                return isPointInCircle(location, geometry.getCircle());
            case POLYGON:
                return isPointInPolygon(location, geometry.getPolygon());
            case RECTANGLE:
                return isPointInRectangle(location, geometry.getRectangle());
            default:
                return false;
        }
    }

    /**
     * 点在圆形内判断
     */
    private boolean isPointInCircle(LocationData location, CircleGeometry circle) {
        double distance = calculateDistance(
            location.getLatitude(), location.getLongitude(),
            circle.getCenterLat(), circle.getCenterLon()
        );
        return distance <= circle.getRadius();
    }

    /**
     * 点在多边形内判断 (射线法)
     */
    private boolean isPointInPolygon(LocationData location, PolygonGeometry polygon) {
        List<GeoPoint> vertices = polygon.getVertices();
        int intersectCount = 0;

        for (int i = 0; i < vertices.size(); i++) {
            GeoPoint p1 = vertices.get(i);
            GeoPoint p2 = vertices.get((i + 1) % vertices.size());

            if (isRayIntersect(location.getLatitude(), location.getLongitude(),
                              p1.getLatitude(), p1.getLongitude(),
                              p2.getLatitude(), p2.getLongitude())) {
                intersectCount++;
            }
        }

        return intersectCount % 2 == 1; // 奇数次相交表示在多边形内
    }

    /**
     * 射线相交判断
     */
    private boolean isRayIntersect(double px, double py, double x1, double y1, double x2, double y2) {
        if ((y1 > py) == (y2 > py)) {
            return false; // 线段不跨越水平射线
        }

        double x = x1 + (py - y1) / (y2 - y1) * (x2 - x1);
        return x > px; // 交点在射线右侧
    }

    /**
     * 点在矩形内判断
     */
    private boolean isPointInRectangle(LocationData location, RectangleGeometry rectangle) {
        return location.getLatitude() >= rectangle.getMinLat() &&
               location.getLatitude() <= rectangle.getMaxLat() &&
               location.getLongitude() >= rectangle.getMinLon() &&
               location.getLongitude() <= rectangle.getMaxLon();
    }

    /**
     * 构建空间索引
     */
    private void buildSpatialIndex(Geofence geofence) {
        // 计算围栏覆盖的GeoHash区域
        Set<String> geoHashAreas = calculateCoveredGeoHashAreas(geofence);

        // 将围栏ID添加到对应区域的索引
        for (String area : geoHashAreas) {
            redisTemplate.opsForSet().add("geofence:area:" + area, geofence.getId());
        }
    }

    /**
     * 计算围栏覆盖的GeoHash区域
     */
    private Set<String> calculateCoveredGeoHashAreas(Geofence geofence) {
        Set<String> areas = new HashSet<>();
        GeofenceGeometry geometry = geofence.getGeometry();

        // 根据几何类型计算覆盖区域
        switch (geometry.getType()) {
            case CIRCLE:
                areas.addAll(calculateCircleCoverage(geometry.getCircle()));
                break;
            case POLYGON:
                areas.addAll(calculatePolygonCoverage(geometry.getPolygon()));
                break;
            case RECTANGLE:
                areas.addAll(calculateRectangleCoverage(geometry.getRectangle()));
                break;
        }

        return areas;
    }

    /**
     * 计算圆形覆盖的GeoHash区域
     */
    private Set<String> calculateCircleCoverage(CircleGeometry circle) {
        Set<String> areas = new HashSet<>();

        // 计算包围盒
        double radiusInDegrees = circle.getRadius() / 111000.0; // 大约111km/度
        double minLat = circle.getCenterLat() - radiusInDegrees;
        double maxLat = circle.getCenterLat() + radiusInDegrees;
        double minLon = circle.getCenterLon() - radiusInDegrees;
        double maxLon = circle.getCenterLon() + radiusInDegrees;

        // 网格采样
        double step = radiusInDegrees / 10; // 采样精度
        for (double lat = minLat; lat <= maxLat; lat += step) {
            for (double lon = minLon; lon <= maxLon; lon += step) {
                double distance = calculateDistance(
                    lat, lon, circle.getCenterLat(), circle.getCenterLon()
                );
                if (distance <= circle.getRadius()) {
                    String geoHash = GeospatialIndexService.GeoHashEncoder.encode(lat, lon, 6);
                    areas.add(geoHash);
                }
            }
        }

        return areas;
    }

    // 数据模型类
    @Data
    @Builder
    public static class GeofenceDefinition {
        private String id;
        private String name;
        private GeofenceType type;
        private GeofenceGeometry geometry;
        private Map<String, Object> properties;
    }

    @Data
    @Builder
    public static class GeofenceEvent {
        private String entityId;
        private String geofenceId;
        private String geofenceName;
        private GeofenceEventType eventType;
        private LocationData location;
        private long timestamp;
    }

    @Entity
    @Table(name = "geofence")
    @Data
    @Builder
    public static class Geofence {
        @Id
        private String id;
        private String name;
        private GeofenceType type;
        private GeofenceGeometry geometry;
        private Map<String, Object> properties;
        private boolean isActive;
        private Date createTime;
        private Date updateTime;
    }

    public enum GeofenceType {
        AIRPORT,           // 机场
        TRAIN_STATION,     // 火车站
        BUSINESS_DISTRICT, // 商务区
        RESIDENTIAL,       // 住宅区
        RESTRICTED_AREA,   // 限行区域
        PICKUP_ZONE,       // 接客区
        CUSTOM             // 自定义
    }

    public enum GeofenceEventType {
        ENTER, EXIT, DWELL
    }
}
```

## 4. 实时匹配算法

### 4.1 匹配引擎核心架构

#### 4.1.1 匹配服务主体设计

```java
/**
 * 实时匹配服务核心引擎
 */
@Service
public class RideMatchingService {

    @Autowired
    private NearbyDriverQueryService nearbyDriverService;

    @Autowired
    private MatchingAlgorithmFactory algorithmFactory;

    @Autowired
    private MatchingResultCache matchingCache;

    @Autowired
    private DistributedLockService lockService;

    @Autowired
    private EventPublisher eventPublisher;

    /**
     * 执行匹配主流程
     */
    public MatchingResult executeMatching(MatchingRequest request) {
        long startTime = System.currentTimeMillis();

        try {
            // 1. 参数验证
            validateMatchingRequest(request);

            // 2. 查询可用司机
            List<DriverInfo> availableDrivers = findAvailableDrivers(request);

            if (availableDrivers.isEmpty()) {
                return createNoDriversResult(request);
            }

            // 3. 选择匹配算法
            MatchingAlgorithm algorithm = algorithmFactory.selectAlgorithm(request, availableDrivers);

            // 4. 执行匹配
            MatchingResult result = performMatching(request, availableDrivers, algorithm);

            // 5. 结果验证和处理
            if (result.isSuccess()) {
                processSuccessfulMatch(result);
            }

            // 6. 记录匹配指标
            recordMatchingMetrics(request, result, System.currentTimeMillis() - startTime);

            return result;

        } catch (Exception e) {
            log.error("匹配执行失败: orderId={}", request.getOrderId(), e);
            return createErrorResult(request, e);
        }
    }

    /**
     * 查找可用司机
     */
    private List<DriverInfo> findAvailableDrivers(MatchingRequest request) {
        NearbyDriverQuery query = NearbyDriverQuery.builder()
            .latitude(request.getPickupLatitude())
            .longitude(request.getPickupLongitude())
            .radius(request.getSearchRadius())
            .limit(request.getMaxCandidates())
            .vehicleType(request.getVehicleType())
            .minRating(request.getMinDriverRating())
            .includeDistance(true)
            .build();

        return nearbyDriverService.findNearbyDrivers(query);
    }

    /**
     * 执行具体匹配逻辑
     */
    private MatchingResult performMatching(MatchingRequest request,
                                          List<DriverInfo> candidates,
                                          MatchingAlgorithm algorithm) {

        // 使用选定的算法进行匹配
        List<MatchingCandidate> rankedCandidates = algorithm.rank(request, candidates);

        // 逐个尝试匹配，直到成功或用尽候选者
        for (MatchingCandidate candidate : rankedCandidates) {
            if (attemptMatch(request, candidate)) {
                return createSuccessResult(request, candidate);
            }
        }

        return createNoMatchResult(request, rankedCandidates);
    }

    /**
     * 尝试与单个司机匹配
     */
    private boolean attemptMatch(MatchingRequest request, MatchingCandidate candidate) {
        String lockKey = "driver:match:" + candidate.getDriverId();

        // 使用分布式锁确保司机不会被重复匹配
        return lockService.executeWithLock(lockKey, Duration.ofSeconds(10), () -> {
            // 双重检查司机是否仍然可用
            if (!isDriverStillAvailable(candidate.getDriverId())) {
                return false;
            }

            // 创建匹配记录
            createMatchRecord(request, candidate);

            // 通知司机
            notifyDriver(candidate.getDriverId(), request);

            // 更新司机状态
            updateDriverStatus(candidate.getDriverId(), DriverStatus.MATCHING);

            return true;
        });
    }

    /**
     * 处理成功匹配
     */
    private void processSuccessfulMatch(MatchingResult result) {
        // 1. 缓存匹配结果
        matchingCache.cacheResult(result);

        // 2. 发布匹配成功事件
        eventPublisher.publishMatchSuccessEvent(result);

        // 3. 通知乘客
        notifyPassenger(result);

        // 4. 启动超时处理
        scheduleMatchTimeout(result);
    }
}
```

#### 4.1.2 匹配算法工厂

```java
/**
 * 匹配算法工厂
 */
@Component
public class MatchingAlgorithmFactory {

    private final Map<String, MatchingAlgorithm> algorithms = new HashMap<>();

    @PostConstruct
    public void initializeAlgorithms() {
        algorithms.put("distance_first", new DistanceFirstAlgorithm());
        algorithms.put("comprehensive", new ComprehensiveAlgorithm());
        algorithms.put("intelligent", new IntelligentAlgorithm());
        algorithms.put("surge_pricing", new SurgePricingAlgorithm());
    }

    /**
     * 根据场景选择最优算法
     */
    public MatchingAlgorithm selectAlgorithm(MatchingRequest request, List<DriverInfo> candidates) {
        // 根据业务场景选择算法
        if (request.isPriorityOrder()) {
            return algorithms.get("distance_first"); // 优先订单使用距离优先
        }

        if (request.getRegionSupplyDemand().getSurgeMultiplier() > 1.5) {
            return algorithms.get("surge_pricing"); // 高峰期使用动态定价算法
        }

        if (candidates.size() > 50) {
            return algorithms.get("intelligent"); // 候选者多时使用智能算法
        }

        return algorithms.get("comprehensive"); // 默认使用综合算法
    }
}

/**
 * 距离优先算法
 */
public class DistanceFirstAlgorithm implements MatchingAlgorithm {

    @Override
    public List<MatchingCandidate> rank(MatchingRequest request, List<DriverInfo> drivers) {
        return drivers.stream()
            .map(driver -> MatchingCandidate.builder()
                .driverId(driver.getDriverId())
                .driver(driver)
                .score(calculateDistanceScore(driver))
                .estimatedArrivalTime(calculateETA(driver, request))
                .build())
            .sorted(Comparator.comparingDouble(MatchingCandidate::getScore).reversed())
            .collect(Collectors.toList());
    }

    private double calculateDistanceScore(DriverInfo driver) {
        // 距离越近分数越高
        return 1.0 / (1.0 + driver.getDistance());
    }

    private long calculateETA(DriverInfo driver, MatchingRequest request) {
        // 简化的ETA计算：距离/平均速度
        double averageSpeed = 30.0; // km/h
        return (long) (driver.getDistance() / averageSpeed * 3600); // 秒
    }
}

/**
 * 综合评分算法
 */
public class ComprehensiveAlgorithm implements MatchingAlgorithm {

    @Override
    public List<MatchingCandidate> rank(MatchingRequest request, List<DriverInfo> drivers) {
        return drivers.stream()
            .map(driver -> {
                double score = calculateComprehensiveScore(driver, request);
                return MatchingCandidate.builder()
                    .driverId(driver.getDriverId())
                    .driver(driver)
                    .score(score)
                    .estimatedArrivalTime(calculateETA(driver, request))
                    .build();
            })
            .sorted(Comparator.comparingDouble(MatchingCandidate::getScore).reversed())
            .collect(Collectors.toList());
    }

    /**
     * 综合评分计算
     */
    private double calculateComprehensiveScore(DriverInfo driver, MatchingRequest request) {
        // 距离因子 (40%)
        double distanceScore = 1.0 / (1.0 + driver.getDistance());

        // 评分因子 (25%)
        double ratingScore = driver.getRating() / 5.0;

        // 完单率因子 (20%)
        double completionScore = driver.getCompletionRate();

        // 响应速度因子 (10%)
        double responseScore = 1.0 / (1.0 + driver.getAverageResponseTime() / 1000.0);

        // 接单意愿因子 (5%) - 基于历史接单率
        double acceptanceScore = getDriverAcceptanceRate(driver.getDriverId());

        return distanceScore * 0.4 + ratingScore * 0.25 + completionScore * 0.2 +
               responseScore * 0.1 + acceptanceScore * 0.05;
    }

    private double getDriverAcceptanceRate(String driverId) {
        // 查询司机历史接单率
        return 0.85; // 示例值
    }
}

/**
 * 智能匹配算法 (使用机器学习)
 */
public class IntelligentAlgorithm implements MatchingAlgorithm {

    @Autowired
    private MLPredictionService mlService;

    @Override
    public List<MatchingCandidate> rank(MatchingRequest request, List<DriverInfo> drivers) {
        // 构建特征向量
        List<MatchingFeature> features = buildFeatures(request, drivers);

        // 使用ML模型预测匹配成功概率
        Map<String, Double> predictions = mlService.predictMatchingProbability(features);

        return drivers.stream()
            .map(driver -> MatchingCandidate.builder()
                .driverId(driver.getDriverId())
                .driver(driver)
                .score(predictions.getOrDefault(driver.getDriverId(), 0.5))
                .estimatedArrivalTime(calculateETA(driver, request))
                .build())
            .sorted(Comparator.comparingDouble(MatchingCandidate::getScore).reversed())
            .collect(Collectors.toList());
    }

    /**
     * 构建机器学习特征
     */
    private List<MatchingFeature> buildFeatures(MatchingRequest request, List<DriverInfo> drivers) {
        return drivers.stream()
            .map(driver -> MatchingFeature.builder()
                .driverId(driver.getDriverId())
                .distance(driver.getDistance())
                .driverRating(driver.getRating())
                .completionRate(driver.getCompletionRate())
                .timeOfDay(getTimeOfDay())
                .dayOfWeek(getDayOfWeek())
                .weatherCondition(getCurrentWeather())
                .regionDemand(request.getRegionSupplyDemand().getSupplyDemandRatio())
                .surgeMultiplier(request.getRegionSupplyDemand().getSurgeMultiplier())
                .passengerRating(request.getPassengerRating())
                .build())
            .collect(Collectors.toList());
    }
}

/**
 * 动态定价匹配算法
 */
public class SurgePricingAlgorithm implements MatchingAlgorithm {

    @Override
    public List<MatchingCandidate> rank(MatchingRequest request, List<DriverInfo> drivers) {
        double surgeMultiplier = request.getRegionSupplyDemand().getSurgeMultiplier();

        return drivers.stream()
            .map(driver -> {
                // 在高峰期，优先考虑愿意接受溢价订单的司机
                double score = calculateSurgeScore(driver, surgeMultiplier);
                return MatchingCandidate.builder()
                    .driverId(driver.getDriverId())
                    .driver(driver)
                    .score(score)
                    .estimatedArrivalTime(calculateETA(driver, request))
                    .surgeMultiplier(surgeMultiplier)
                    .build();
            })
            .sorted(Comparator.comparingDouble(MatchingCandidate::getScore).reversed())
            .collect(Collectors.toList());
    }

    private double calculateSurgeScore(DriverInfo driver, double surgeMultiplier) {
        // 基础分数
        double baseScore = 1.0 / (1.0 + driver.getDistance());

        // 司机对溢价的敏感度（基于历史数据）
        double surgeSensitivity = getDriverSurgeSensitivity(driver.getDriverId());

        // 溢价倍数越高，对司机吸引力越大
        double surgeBonus = Math.log(surgeMultiplier) * surgeSensitivity;

        return baseScore + surgeBonus;
    }

    private double getDriverSurgeSensitivity(String driverId) {
        // 查询司机对溢价订单的偏好度
        return 0.3; // 示例值
    }
}
```

### 4.2 供需平衡与动态定价

#### 4.2.1 供需监控服务

```java
/**
 * 供需平衡监控服务
 */
@Service
public class SupplyDemandMonitorService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private LocationService locationService;

    @Scheduled(fixedRate = 30000) // 每30秒更新一次
    public void updateSupplyDemandMetrics() {
        List<String> regions = getAllRegions();

        for (String region : regions) {
            SupplyDemandMetrics metrics = calculateRegionMetrics(region);
            updateRegionMetrics(region, metrics);

            // 触发动态定价调整
            if (shouldTriggerSurge(metrics)) {
                triggerSurgePricing(region, metrics);
            }
        }
    }

    /**
     * 计算区域供需指标
     */
    private SupplyDemandMetrics calculateRegionMetrics(String regionId) {
        // 1. 统计可用司机数量
        int availableDrivers = countAvailableDrivers(regionId);

        // 2. 统计待匹配订单数量
        int pendingOrders = countPendingOrders(regionId);

        // 3. 计算平均等待时间
        double avgWaitTime = calculateAverageWaitTime(regionId);

        // 4. 计算匹配成功率
        double matchSuccessRate = calculateMatchSuccessRate(regionId);

        // 5. 计算供需比
        double supplyDemandRatio = pendingOrders > 0 ?
            (double) availableDrivers / pendingOrders : Double.MAX_VALUE;

        return SupplyDemandMetrics.builder()
            .regionId(regionId)
            .availableDrivers(availableDrivers)
            .pendingOrders(pendingOrders)
            .supplyDemandRatio(supplyDemandRatio)
            .averageWaitTime(avgWaitTime)
            .matchSuccessRate(matchSuccessRate)
            .timestamp(System.currentTimeMillis())
            .build();
    }

    /**
     * 统计可用司机数量
     */
    private int countAvailableDrivers(String regionId) {
        // 从Redis Geo中查询区域内的在线司机
        String key = "region:drivers:" + regionId;
        Set<String> driverIds = redisTemplate.opsForSet().members(key);

        if (driverIds == null) return 0;

        // 过滤出真正可用的司机
        return (int) driverIds.stream()
            .map(this::getDriverInfo)
            .filter(Objects::nonNull)
            .filter(driver -> driver.getStatus() == DriverStatus.ONLINE)
            .count();
    }

    /**
     * 统计待匹配订单数量
     */
    private int countPendingOrders(String regionId) {
        String key = "region:pending_orders:" + regionId;
        Set<String> orderIds = redisTemplate.opsForSet().members(key);
        return orderIds != null ? orderIds.size() : 0;
    }

    /**
     * 计算平均等待时间
     */
    private double calculateAverageWaitTime(String regionId) {
        String key = "region:wait_times:" + regionId;
        List<Object> waitTimes = redisTemplate.opsForList().range(key, 0, -1);

        if (waitTimes == null || waitTimes.isEmpty()) {
            return 0.0;
        }

        return waitTimes.stream()
            .mapToDouble(obj -> Double.parseDouble(obj.toString()))
            .average()
            .orElse(0.0);
    }

    /**
     * 判断是否应该触发动态定价
     */
    private boolean shouldTriggerSurge(SupplyDemandMetrics metrics) {
        // 供需比小于0.5且平均等待时间超过5分钟
        return metrics.getSupplyDemandRatio() < 0.5 && metrics.getAverageWaitTime() > 300;
    }

    /**
     * 触发动态定价
     */
    private void triggerSurgePricing(String regionId, SupplyDemandMetrics metrics) {
        double surgeMultiplier = calculateSurgeMultiplier(metrics);

        SurgePricingEvent event = SurgePricingEvent.builder()
            .regionId(regionId)
            .surgeMultiplier(surgeMultiplier)
            .duration(Duration.ofMinutes(15)) // 持续15分钟
            .reason("供需失衡")
            .metrics(metrics)
            .build();

        // 应用动态定价
        applySurgePricing(event);

        // 通知相关用户
        notifyUsersAboutSurge(event);
    }

    /**
     * 计算动态定价倍数
     */
    private double calculateSurgeMultiplier(SupplyDemandMetrics metrics) {
        double ratio = metrics.getSupplyDemandRatio();
        double waitTime = metrics.getAverageWaitTime();

        // 基于供需比的倍数
        double ratioMultiplier = 1.0;
        if (ratio < 0.3) ratioMultiplier = 3.0;
        else if (ratio < 0.5) ratioMultiplier = 2.5;
        else if (ratio < 0.7) ratioMultiplier = 2.0;
        else if (ratio < 1.0) ratioMultiplier = 1.5;

        // 基于等待时间的调整
        double waitTimeMultiplier = 1.0;
        if (waitTime > 600) waitTimeMultiplier = 1.5; // 超过10分钟
        else if (waitTime > 300) waitTimeMultiplier = 1.3; // 超过5分钟
        else if (waitTime > 180) waitTimeMultiplier = 1.2; // 超过3分钟

        // 综合计算，最高不超过5倍
        return Math.min(ratioMultiplier * waitTimeMultiplier, 5.0);
    }

    @Data
    @Builder
    public static class SupplyDemandMetrics {
        private String regionId;
        private int availableDrivers;
        private int pendingOrders;
        private double supplyDemandRatio;
        private double averageWaitTime;      // 秒
        private double matchSuccessRate;     // 0-1
        private long timestamp;
    }

    @Data
    @Builder
    public static class SurgePricingEvent {
        private String regionId;
        private double surgeMultiplier;
        private Duration duration;
        private String reason;
        private SupplyDemandMetrics metrics;
        private long startTime;
        private long endTime;
    }
}
```

#### 4.2.2 智能调度优化

```java
/**
 * 智能调度服务
 */
@Service
public class IntelligentDispatchService {

    @Autowired
    private LocationService locationService;

    @Autowired
    private PredictionService predictionService;

    /**
     * 全局调度优化
     */
    public DispatchPlan optimizeGlobalDispatch(DispatchContext context) {
        // 1. 分析当前态势
        DispatchSituation situation = analyzeSituation(context);

        // 2. 预测未来需求
        DemandForecast forecast = predictionService.forecastDemand(
            context.getRegion(), Duration.ofMinutes(30));

        // 3. 生成调度方案
        DispatchPlan plan = generateDispatchPlan(situation, forecast);

        // 4. 执行调度
        executeDispatchPlan(plan);

        return plan;
    }

    /**
     * 分析调度态势
     */
    private DispatchSituation analyzeSituation(DispatchContext context) {
        Map<String, RegionStatus> regionStatuses = new HashMap<>();

        for (String regionId : context.getRegions()) {
            RegionStatus status = analyzeRegionStatus(regionId);
            regionStatuses.put(regionId, status);
        }

        return DispatchSituation.builder()
            .regionStatuses(regionStatuses)
            .totalDrivers(context.getAvailableDrivers().size())
            .totalOrders(context.getPendingOrders().size())
            .timestamp(System.currentTimeMillis())
            .build();
    }

    /**
     * 分析单个区域状态
     */
    private RegionStatus analyzeRegionStatus(String regionId) {
        SupplyDemandMetrics metrics = getRegionMetrics(regionId);

        RegionStatusType statusType;
        if (metrics.getSupplyDemandRatio() > 2.0) {
            statusType = RegionStatusType.OVERSUPPLY;
        } else if (metrics.getSupplyDemandRatio() < 0.5) {
            statusType = RegionStatusType.SHORTAGE;
        } else {
            statusType = RegionStatusType.BALANCED;
        }

        return RegionStatus.builder()
            .regionId(regionId)
            .statusType(statusType)
            .metrics(metrics)
            .priority(calculateRegionPriority(metrics))
            .build();
    }

    /**
     * 生成调度计划
     */
    private DispatchPlan generateDispatchPlan(DispatchSituation situation, DemandForecast forecast) {
        List<DispatchAction> actions = new ArrayList<>();

        // 1. 识别需要调度的区域
        List<String> shortageRegions = situation.getRegionStatuses().entrySet().stream()
            .filter(entry -> entry.getValue().getStatusType() == RegionStatusType.SHORTAGE)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());

        List<String> oversupplyRegions = situation.getRegionStatuses().entrySet().stream()
            .filter(entry -> entry.getValue().getStatusType() == RegionStatusType.OVERSUPPLY)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());

        // 2. 计算司机重新分配
        for (String shortageRegion : shortageRegions) {
            for (String oversupplyRegion : oversupplyRegions) {
                DispatchAction action = calculateDriverReallocation(oversupplyRegion, shortageRegion);
                if (action != null && action.getExpectedBenefit() > 0) {
                    actions.add(action);
                }
            }
        }

        // 3. 根据预测调整司机分布
        actions.addAll(generateProactiveDispatchActions(forecast));

        // 4. 按收益排序
        actions.sort(Comparator.comparingDouble(DispatchAction::getExpectedBenefit).reversed());

        return DispatchPlan.builder()
            .actions(actions)
            .expectedImprovement(calculateExpectedImprovement(actions))
            .createTime(System.currentTimeMillis())
            .build();
    }

    /**
     * 计算司机重新分配
     */
    private DispatchAction calculateDriverReallocation(String fromRegion, String toRegion) {
        // 计算调度成本和收益
        double distance = calculateRegionDistance(fromRegion, toRegion);
        double cost = distance * 0.5; // 假设每公里成本0.5元

        RegionStatus fromStatus = getRegionStatus(fromRegion);
        RegionStatus toStatus = getRegionStatus(toRegion);

        // 计算预期收益
        double benefit = calculateDispatchBenefit(fromStatus, toStatus);

        if (benefit > cost) {
            return DispatchAction.builder()
                .type(DispatchActionType.DRIVER_REALLOCATION)
                .fromRegion(fromRegion)
                .toRegion(toRegion)
                .driverCount(calculateOptimalDriverCount(fromStatus, toStatus))
                .expectedCost(cost)
                .expectedBenefit(benefit)
                .priority(calculateActionPriority(benefit, cost))
                .build();
        }

        return null;
    }

    /**
     * 生成主动调度行动
     */
    private List<DispatchAction> generateProactiveDispatchActions(DemandForecast forecast) {
        List<DispatchAction> actions = new ArrayList<>();

        for (RegionDemandPrediction prediction : forecast.getRegionPredictions()) {
            if (prediction.getPredictedDemandIncrease() > 0.3) { // 预测需求增长超过30%
                DispatchAction action = DispatchAction.builder()
                    .type(DispatchActionType.PROACTIVE_POSITIONING)
                    .toRegion(prediction.getRegionId())
                    .driverCount(calculateProactiveDriverCount(prediction))
                    .expectedBenefit(prediction.getPredictedDemandIncrease() * 100)
                    .priority(DispatchPriority.HIGH)
                    .build();

                actions.add(action);
            }
        }

        return actions;
    }

    /**
     * 执行调度计划
     */
    private void executeDispatchPlan(DispatchPlan plan) {
        for (DispatchAction action : plan.getActions()) {
            try {
                executeDispatchAction(action);
            } catch (Exception e) {
                log.error("调度行动执行失败: {}", action, e);
            }
        }
    }

    /**
     * 执行单个调度行动
     */
    private void executeDispatchAction(DispatchAction action) {
        switch (action.getType()) {
            case DRIVER_REALLOCATION:
                executeDriverReallocation(action);
                break;
            case PROACTIVE_POSITIONING:
                executeProactivePositioning(action);
                break;
            case SURGE_PRICING:
                executeSurgePricing(action);
                break;
        }
    }

    /**
     * 执行司机重新分配
     */
    private void executeDriverReallocation(DispatchAction action) {
        // 1. 选择要调度的司机
        List<String> candidateDrivers = selectDriversForReallocation(
            action.getFromRegion(), action.getDriverCount());

        // 2. 发送调度指令
        for (String driverId : candidateDrivers) {
            sendDispatchInstruction(driverId, action.getToRegion());
        }

        // 3. 记录调度结果
        recordDispatchAction(action, candidateDrivers);
    }

    // 数据模型类
    @Data
    @Builder
    public static class DispatchContext {
        private List<String> regions;
        private List<DriverInfo> availableDrivers;
        private List<OrderInfo> pendingOrders;
        private Map<String, SupplyDemandMetrics> regionMetrics;
    }

    @Data
    @Builder
    public static class RegionStatus {
        private String regionId;
        private RegionStatusType statusType;
        private SupplyDemandMetrics metrics;
        private int priority;
    }

    @Data
    @Builder
    public static class DispatchAction {
        private DispatchActionType type;
        private String fromRegion;
        private String toRegion;
        private int driverCount;
        private double expectedCost;
        private double expectedBenefit;
        private DispatchPriority priority;
    }

    public enum RegionStatusType {
        SHORTAGE,      // 供不应求
        BALANCED,      // 供需平衡
        OVERSUPPLY     // 供过于求
    }

    public enum DispatchActionType {
        DRIVER_REALLOCATION,    // 司机重新分配
        PROACTIVE_POSITIONING,  // 主动定位
        SURGE_PRICING          // 动态定价
    }

    public enum DispatchPriority {
        LOW, MEDIUM, HIGH, URGENT
    }
}
```

### 4.3 匹配冲突处理

#### 4.3.1 分布式锁与并发控制

```java
/**
 * 匹配冲突解决服务
 */
@Service
public class MatchingConflictResolver {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private MatchingStateManager stateManager;

    /**
     * 分布式锁实现
     */
    @Component
    public static class DistributedMatchingLock {

        private final RedisTemplate<String, Object> redisTemplate;
        private static final String LOCK_PREFIX = "matching:lock:driver:";
        private static final String ORDER_LOCK_PREFIX = "matching:lock:order:";

        public DistributedMatchingLock(RedisTemplate<String, Object> redisTemplate) {
            this.redisTemplate = redisTemplate;
        }

        /**
         * 尝试锁定司机进行匹配
         */
        public MatchingLockResult tryLockDriver(String driverId, String orderId, Duration timeout) {
            String lockKey = LOCK_PREFIX + driverId;
            String lockValue = orderId + ":" + System.currentTimeMillis();

            Boolean success = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, timeout);

            if (Boolean.TRUE.equals(success)) {
                return MatchingLockResult.success(lockKey, lockValue);
            }

            // 检查是否是同一订单的重复锁定
            String existingValue = (String) redisTemplate.opsForValue().get(lockKey);
            if (existingValue != null && existingValue.startsWith(orderId + ":")) {
                return MatchingLockResult.success(lockKey, existingValue);
            }

            return MatchingLockResult.failure("司机已被其他订单锁定");
        }

        /**
         * 释放司机锁
         */
        public boolean releaseLock(String lockKey, String lockValue) {
            String script =
                "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                "    return redis.call('del', KEYS[1]) " +
                "else " +
                "    return 0 " +
                "end";

            Long result = redisTemplate.execute(
                new DefaultRedisScript<>(script, Long.class),
                Collections.singletonList(lockKey),
                lockValue
            );

            return result != null && result > 0;
        }

        /**
         * 双重锁定：同时锁定订单和司机
         */
        public DualLockResult tryDualLock(String orderId, String driverId, Duration timeout) {
            String orderLockKey = ORDER_LOCK_PREFIX + orderId;
            String driverLockKey = LOCK_PREFIX + driverId;
            String lockValue = generateLockValue(orderId, driverId);

            // 使用Lua脚本确保原子性
            String script =
                "local orderLock = redis.call('SET', KEYS[1], ARGV[1], 'NX', 'EX', ARGV[2]) " +
                "if orderLock then " +
                "    local driverLock = redis.call('SET', KEYS[2], ARGV[1], 'NX', 'EX', ARGV[2]) " +
                "    if driverLock then " +
                "        return 1 " +
                "    else " +
                "        redis.call('DEL', KEYS[1]) " +
                "        return 0 " +
                "    end " +
                "else " +
                "    return 0 " +
                "end";

            Long result = redisTemplate.execute(
                new DefaultRedisScript<>(script, Long.class),
                Arrays.asList(orderLockKey, driverLockKey),
                lockValue,
                String.valueOf(timeout.getSeconds())
            );

            if (result != null && result > 0) {
                return DualLockResult.success(orderLockKey, driverLockKey, lockValue);
            }

            return DualLockResult.failure();
        }

        private String generateLockValue(String orderId, String driverId) {
            return orderId + ":" + driverId + ":" + System.currentTimeMillis();
        }
    }

    /**
     * 匹配状态管理器
     */
    @Component
    public static class MatchingStateManager {

        private final RedisTemplate<String, Object> redisTemplate;
        private static final String STATE_PREFIX = "matching:state:";

        public MatchingStateManager(RedisTemplate<String, Object> redisTemplate) {
            this.redisTemplate = redisTemplate;
        }

        /**
         * 更新匹配状态
         */
        public void updateMatchingState(String orderId, MatchingState state) {
            String key = STATE_PREFIX + orderId;
            redisTemplate.opsForValue().set(key, state, Duration.ofMinutes(30));
        }

        /**
         * 获取匹配状态
         */
        public MatchingState getMatchingState(String orderId) {
            String key = STATE_PREFIX + orderId;
            return (MatchingState) redisTemplate.opsForValue().get(key);
        }

        /**
         * 原子性状态更新
         */
        public boolean compareAndSetState(String orderId, MatchingState expected, MatchingState newState) {
            String key = STATE_PREFIX + orderId;

            String script =
                "local current = redis.call('GET', KEYS[1]) " +
                "if current == ARGV[1] then " +
                "    redis.call('SET', KEYS[1], ARGV[2], 'EX', 1800) " +
                "    return 1 " +
                "else " +
                "    return 0 " +
                "end";

            Long result = redisTemplate.execute(
                new DefaultRedisScript<>(script, Long.class),
                Collections.singletonList(key),
                expected.toString(),
                newState.toString()
            );

            return result != null && result > 0;
        }
    }

    /**
     * 处理司机拒单场景
     */
    public void handleDriverRejection(String orderId, String driverId, String rejectionReason) {
        // 1. 记录拒单信息
        recordDriverRejection(orderId, driverId, rejectionReason);

        // 2. 释放司机锁
        releaseDriverLock(driverId);

        // 3. 更新订单状态
        stateManager.updateMatchingState(orderId, MatchingState.DRIVER_REJECTED);

        // 4. 触发重新匹配
        triggerRematch(orderId);

        // 5. 更新司机信誉分
        updateDriverReputationScore(driverId, -5); // 拒单扣分
    }

    /**
     * 处理乘客取消场景
     */
    public void handlePassengerCancellation(String orderId, String reason) {
        MatchingState currentState = stateManager.getMatchingState(orderId);

        if (currentState == MatchingState.DRIVER_MATCHED) {
            // 已匹配司机，需要释放司机并补偿
            String driverId = getMatchedDriverId(orderId);
            releaseDriverLock(driverId);
            compensateDriver(driverId, orderId);
        }

        // 更新订单状态
        stateManager.updateMatchingState(orderId, MatchingState.PASSENGER_CANCELLED);

        // 记录取消原因
        recordCancellationReason(orderId, reason);
    }

    /**
     * 处理匹配超时
     */
    public void handleMatchingTimeout(String orderId) {
        MatchingState currentState = stateManager.getMatchingState(orderId);

        if (currentState == MatchingState.MATCHING) {
            // 1. 扩大搜索范围
            expandSearchRadius(orderId);

            // 2. 提高价格激励
            increasePriceIncentive(orderId);

            // 3. 触发重新匹配
            triggerRematch(orderId);

        } else if (currentState == MatchingState.DRIVER_MATCHED) {
            // 司机超时未响应
            handleDriverTimeout(orderId);
        }
    }

    /**
     * 处理司机超时未响应
     */
    private void handleDriverTimeout(String orderId) {
        String driverId = getMatchedDriverId(orderId);

        // 1. 释放司机锁
        releaseDriverLock(driverId);

        // 2. 降低司机信誉分
        updateDriverReputationScore(driverId, -10); // 超时不响应重扣

        // 3. 重新匹配
        stateManager.updateMatchingState(orderId, MatchingState.DRIVER_TIMEOUT);
        triggerRematch(orderId);
    }

    /**
     * 触发重新匹配
     */
    private void triggerRematch(String orderId) {
        // 增加重试计数
        incrementRetryCount(orderId);

        // 获取重试次数
        int retryCount = getRetryCount(orderId);

        if (retryCount > 5) {
            // 超过最大重试次数，标记为匹配失败
            stateManager.updateMatchingState(orderId, MatchingState.MATCH_FAILED);
            notifyPassengerMatchFailed(orderId);
        } else {
            // 延迟重新匹配，避免频繁重试
            scheduleRematch(orderId, Duration.ofSeconds(retryCount * 10));
        }
    }

    // 数据模型类
    @Data
    @Builder
    public static class MatchingLockResult {
        private boolean success;
        private String lockKey;
        private String lockValue;
        private String errorMessage;

        public static MatchingLockResult success(String lockKey, String lockValue) {
            return MatchingLockResult.builder()
                .success(true)
                .lockKey(lockKey)
                .lockValue(lockValue)
                .build();
        }

        public static MatchingLockResult failure(String errorMessage) {
            return MatchingLockResult.builder()
                .success(false)
                .errorMessage(errorMessage)
                .build();
        }
    }

    @Data
    @Builder
    public static class DualLockResult {
        private boolean success;
        private String orderLockKey;
        private String driverLockKey;
        private String lockValue;

        public static DualLockResult success(String orderLockKey, String driverLockKey, String lockValue) {
            return DualLockResult.builder()
                .success(true)
                .orderLockKey(orderLockKey)
                .driverLockKey(driverLockKey)
                .lockValue(lockValue)
                .build();
        }

        public static DualLockResult failure() {
            return DualLockResult.builder()
                .success(false)
                .build();
        }
    }

    public enum MatchingState {
        CREATED,           // 订单已创建
        MATCHING,          // 匹配中
        DRIVER_MATCHED,    // 已匹配司机
        DRIVER_REJECTED,   // 司机拒绝
        DRIVER_TIMEOUT,    // 司机超时
        PASSENGER_CANCELLED, // 乘客取消
        MATCH_FAILED,      // 匹配失败
        COMPLETED          // 匹配完成
    }
}
```

## 5. 路径规划与导航

### 5.1 路径规划架构

```java
@Service
public class RouteCalculationService {

    @Autowired
    private GraphService graphService;

    @Autowired
    private TrafficService trafficService;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // 多算法路径计算
    public RouteResult calculateRoute(RouteRequest request) {
        // 选择最优算法
        RoutingStrategy strategy = selectStrategy(request);

        // 获取实时路网数据
        RoadNetwork network = graphService.getNetwork(request.getBounds());

        // 应用实时交通数据
        applyTrafficData(network, request.getStartTime());

        // 执行路径计算
        return strategy.calculate(network, request);
    }

    private RoutingStrategy selectStrategy(RouteRequest request) {
        if (request.getDistance() > 50000) { // 50km以上长距离
            return new HierarchicalAStarStrategy();
        } else if (request.isRealTimeOptimization()) {
            return new DynamicDijkstraStrategy();
        } else {
            return new StandardAStarStrategy();
        }
    }
}

// 路径计算请求
@Data
public class RouteRequest {
    private GeoPoint origin;
    private GeoPoint destination;
    private LocalDateTime startTime;
    private RoutePreference preference; // FASTEST, SHORTEST, BALANCED
    private VehicleType vehicleType;
    private boolean avoidTolls;
    private boolean avoidHighways;
    private boolean isRealTimeOptimization;

    public BoundingBox getBounds() {
        return BoundingBox.fromPoints(Arrays.asList(origin, destination))
                         .expand(0.1); // 扩展10%确保覆盖所有可能路径
    }

    public double getDistance() {
        return GeoUtils.haversineDistance(origin, destination);
    }
}
```

### 5.2 多层级路径算法

```java
// A*算法实现
@Component
public class StandardAStarStrategy implements RoutingStrategy {

    @Override
    public RouteResult calculate(RoadNetwork network, RouteRequest request) {
        PriorityQueue<AStarNode> openSet = new PriorityQueue<>(
            Comparator.comparing(AStarNode::getTotalCost)
        );

        Map<String, AStarNode> allNodes = new HashMap<>();
        Set<String> closedSet = new HashSet<>();

        // 初始化起点
        AStarNode startNode = new AStarNode(
            request.getOrigin(),
            0,
            heuristic(request.getOrigin(), request.getDestination())
        );

        openSet.offer(startNode);
        allNodes.put(startNode.getNodeId(), startNode);

        while (!openSet.isEmpty()) {
            AStarNode current = openSet.poll();

            if (isDestination(current, request.getDestination())) {
                return reconstructPath(current, request);
            }

            closedSet.add(current.getNodeId());

            // 扩展邻居节点
            for (RoadSegment segment : network.getOutgoingSegments(current.getNodeId())) {
                String neighborId = segment.getToNodeId();

                if (closedSet.contains(neighborId)) {
                    continue;
                }

                double tentativeG = current.getGCost() + calculateSegmentCost(segment, request);
                AStarNode neighbor = allNodes.computeIfAbsent(neighborId,
                    id -> new AStarNode(segment.getToPoint(), Double.MAX_VALUE,
                                       heuristic(segment.getToPoint(), request.getDestination())));

                if (tentativeG < neighbor.getGCost()) {
                    neighbor.setGCost(tentativeG);
                    neighbor.setParent(current);
                    neighbor.setSegment(segment);

                    if (!openSet.contains(neighbor)) {
                        openSet.offer(neighbor);
                    }
                }
            }
        }

        throw new RouteNotFoundException("No route found from " + request.getOrigin() +
                                       " to " + request.getDestination());
    }

    private double heuristic(GeoPoint a, GeoPoint b) {
        // 使用曼哈顿距离作为启发函数，保证可采纳性
        return GeoUtils.manhattanDistance(a, b) * 1.1; // 稍微高估以提高搜索效率
    }

    private double calculateSegmentCost(RoadSegment segment, RouteRequest request) {
        double baseCost = segment.getLength();

        // 根据偏好调整成本
        switch (request.getPreference()) {
            case FASTEST:
                return segment.getTravelTime(); // 考虑实时速度
            case SHORTEST:
                return baseCost;
            case BALANCED:
                return baseCost + segment.getTravelTime() * 0.5;
            default:
                return baseCost;
        }
    }
}

// 层次化A*算法用于长距离路径
@Component
public class HierarchicalAStarStrategy implements RoutingStrategy {

    @Override
    public RouteResult calculate(RoadNetwork network, RouteRequest request) {
        // 第一阶段：在高层级路网中找粗糙路径
        List<GeoPoint> coarseRoute = calculateCoarseRoute(network.getHighwayNetwork(), request);

        // 第二阶段：在详细路网中细化每个段
        List<RouteSegment> detailedSegments = new ArrayList<>();

        for (int i = 0; i < coarseRoute.size() - 1; i++) {
            RouteRequest segmentRequest = RouteRequest.builder()
                .origin(coarseRoute.get(i))
                .destination(coarseRoute.get(i + 1))
                .preference(request.getPreference())
                .build();

            RouteResult segmentResult = new StandardAStarStrategy()
                .calculate(network.getLocalNetwork(segmentRequest.getBounds()), segmentRequest);

            detailedSegments.addAll(segmentResult.getSegments());
        }

        return RouteResult.builder()
            .segments(detailedSegments)
            .totalDistance(calculateTotalDistance(detailedSegments))
            .estimatedDuration(calculateTotalDuration(detailedSegments))
            .build();
    }

    private List<GeoPoint> calculateCoarseRoute(HighwayNetwork highwayNetwork, RouteRequest request) {
        // 在高速公路网络中使用简化的A*算法
        return new StandardAStarStrategy().calculate(highwayNetwork, request)
               .getSegments().stream()
               .map(RouteSegment::getEndPoint)
               .collect(Collectors.toList());
    }
}
```

### 5.3 实时交通集成

```java
@Service
public class TrafficService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    // 实时交通数据处理
    public void updateTrafficData(TrafficUpdate update) {
        String key = "traffic:" + update.getSegmentId();

        // 更新Redis中的实时数据
        TrafficData trafficData = TrafficData.builder()
            .segmentId(update.getSegmentId())
            .currentSpeed(update.getCurrentSpeed())
            .freeFlowSpeed(update.getFreeFlowSpeed())
            .congestionLevel(calculateCongestionLevel(update))
            .timestamp(LocalDateTime.now())
            .build();

        redisTemplate.opsForValue().set(key, trafficData, Duration.ofMinutes(5));

        // 如果拥堵程度显著变化，触发路径重计算
        if (isSignificantChange(update)) {
            triggerRouteRecalculation(update.getSegmentId());
        }
    }

    public Map<String, TrafficData> getTrafficData(Set<String> segmentIds) {
        List<String> keys = segmentIds.stream()
            .map(id -> "traffic:" + id)
            .collect(Collectors.toList());

        List<Object> trafficDataList = redisTemplate.opsForValue().multiGet(keys);

        Map<String, TrafficData> result = new HashMap<>();
        for (int i = 0; i < segmentIds.size(); i++) {
            if (trafficDataList.get(i) != null) {
                String segmentId = segmentIds.stream().skip(i).findFirst().get();
                result.put(segmentId, (TrafficData) trafficDataList.get(i));
            }
        }

        return result;
    }

    private CongestionLevel calculateCongestionLevel(TrafficUpdate update) {
        double ratio = update.getCurrentSpeed() / update.getFreeFlowSpeed();

        if (ratio >= 0.8) return CongestionLevel.FREE_FLOW;
        if (ratio >= 0.6) return CongestionLevel.LIGHT;
        if (ratio >= 0.4) return CongestionLevel.MODERATE;
        if (ratio >= 0.2) return CongestionLevel.HEAVY;
        return CongestionLevel.SEVERE;
    }

    private void triggerRouteRecalculation(String segmentId) {
        // 找到受影响的活跃订单
        Set<String> affectedOrders = findAffectedOrders(segmentId);

        for (String orderId : affectedOrders) {
            RouteRecalculationEvent event = RouteRecalculationEvent.builder()
                .orderId(orderId)
                .reason("Traffic condition changed on segment: " + segmentId)
                .priority(CalculationPriority.HIGH)
                .build();

            kafkaTemplate.send("route-recalculation", event);
        }
    }
}

// 动态路径调整
@Service
public class DynamicRouteAdjustmentService {

    @KafkaListener(topics = "route-recalculation")
    public void handleRouteRecalculation(RouteRecalculationEvent event) {
        try {
            Order order = orderService.getOrder(event.getOrderId());

            if (order.getStatus() == OrderStatus.IN_PROGRESS) {
                // 获取司机当前位置
                LocationData currentLocation = locationService.getDriverLocation(order.getDriverId());

                // 重新计算从当前位置到目的地的路径
                RouteRequest newRequest = RouteRequest.builder()
                    .origin(currentLocation.toGeoPoint())
                    .destination(order.getDestination())
                    .preference(RoutePreference.FASTEST)
                    .isRealTimeOptimization(true)
                    .build();

                RouteResult newRoute = routeCalculationService.calculateRoute(newRequest);

                // 比较新旧路径
                if (shouldUpdateRoute(order.getCurrentRoute(), newRoute)) {
                    updateOrderRoute(order, newRoute);
                    notifyDriverOfRouteChange(order.getDriverId(), newRoute);
                }
            }

        } catch (Exception e) {
            log.error("Failed to recalculate route for order: " + event.getOrderId(), e);
        }
    }

    private boolean shouldUpdateRoute(RouteResult oldRoute, RouteResult newRoute) {
        // 如果新路径能节省超过2分钟或10%的时间，则更新
        double timeSaved = oldRoute.getEstimatedDuration() - newRoute.getEstimatedDuration();
        double percentageSaved = timeSaved / oldRoute.getEstimatedDuration();

        return timeSaved > 120 || percentageSaved > 0.1;
    }
}
```

### 5.4 导航服务

```java
@Service
public class NavigationService {

    @Autowired
    private RouteCalculationService routeService;

    @Autowired
    private WebSocketTemplate webSocketTemplate;

    // 开始导航
    public NavigationSession startNavigation(String driverId, String orderId) {
        Order order = orderService.getOrder(orderId);

        RouteRequest request = RouteRequest.builder()
            .origin(order.getPickupLocation())
            .destination(order.getDestination())
            .preference(RoutePreference.FASTEST)
            .build();

        RouteResult route = routeService.calculateRoute(request);

        NavigationSession session = NavigationSession.builder()
            .sessionId(UUID.randomUUID().toString())
            .driverId(driverId)
            .orderId(orderId)
            .route(route)
            .currentSegmentIndex(0)
            .status(NavigationStatus.ACTIVE)
            .startTime(LocalDateTime.now())
            .build();

        // 缓存导航会话
        redisTemplate.opsForValue().set(
            "navigation:" + session.getSessionId(),
            session,
            Duration.ofHours(2)
        );

        return session;
    }

    // 处理位置更新
    public NavigationUpdate processLocationUpdate(String sessionId, LocationData location) {
        NavigationSession session = getNavigationSession(sessionId);

        if (session == null || session.getStatus() != NavigationStatus.ACTIVE) {
            return null;
        }

        // 地图匹配 - 将GPS位置匹配到路网
        MapMatchingResult matchResult = mapMatchingService.matchToRoute(
            location, session.getRoute()
        );

        // 计算导航指令
        NavigationInstruction instruction = calculateInstruction(session, matchResult);

        // 检查是否偏离路径
        if (matchResult.isOffRoute()) {
            handleOffRoute(session, location);
        }

        // 更新会话状态
        session.setCurrentSegmentIndex(matchResult.getSegmentIndex());
        session.setLastUpdate(LocalDateTime.now());
        updateNavigationSession(session);

        return NavigationUpdate.builder()
            .instruction(instruction)
            .remainingDistance(calculateRemainingDistance(session, matchResult))
            .estimatedTimeToArrival(calculateETA(session, matchResult))
            .nextManeuver(getNextManeuver(session, matchResult))
            .build();
    }

    private NavigationInstruction calculateInstruction(NavigationSession session, MapMatchingResult matchResult) {
        RouteSegment currentSegment = session.getRoute().getSegments().get(matchResult.getSegmentIndex());

        // 检查是否需要转向指令
        if (isApproachingManeuver(matchResult, currentSegment)) {
            RouteSegment nextSegment = getNextSegment(session, matchResult.getSegmentIndex());
            return generateTurnInstruction(currentSegment, nextSegment);
        }

        // 直行指令
        return NavigationInstruction.builder()
            .type(InstructionType.CONTINUE)
            .text("继续直行 " + currentSegment.getStreetName())
            .distance(currentSegment.getLength() - matchResult.getDistanceAlongSegment())
            .build();
    }

    private void handleOffRoute(NavigationSession session, LocationData location) {
        log.info("Driver {} is off route, recalculating...", session.getDriverId());

        // 从当前位置重新计算路径
        RouteRequest request = RouteRequest.builder()
            .origin(location.toGeoPoint())
            .destination(session.getRoute().getDestination())
            .preference(RoutePreference.FASTEST)
            .isRealTimeOptimization(true)
            .build();

        RouteResult newRoute = routeService.calculateRoute(request);
        session.setRoute(newRoute);
        session.setCurrentSegmentIndex(0);

        // 通知司机路径已更新
        webSocketTemplate.convertAndSendToUser(
            session.getDriverId(),
            "/queue/navigation",
            NavigationEvent.builder()
                .type(NavigationEventType.ROUTE_UPDATED)
                .message("路径已重新规划")
                .newRoute(newRoute)
                .build()
        );
    }
}

// 地图匹配服务
@Service
public class MapMatchingService {

    public MapMatchingResult matchToRoute(LocationData location, RouteResult route) {
        double minDistance = Double.MAX_VALUE;
        int bestSegmentIndex = 0;
        double bestDistanceAlong = 0;
        boolean isOffRoute = false;

        GeoPoint gpsPoint = location.toGeoPoint();

        // 在路径的所有段中寻找最近匹配点
        for (int i = 0; i < route.getSegments().size(); i++) {
            RouteSegment segment = route.getSegments().get(i);

            // 计算点到线段的最短距离
            PointToLineResult result = GeoUtils.pointToLineDistance(
                gpsPoint, segment.getStartPoint(), segment.getEndPoint()
            );

            if (result.getDistance() < minDistance) {
                minDistance = result.getDistance();
                bestSegmentIndex = i;
                bestDistanceAlong = result.getDistanceAlong();
            }
        }

        // 判断是否偏离路径（距离超过50米认为偏离）
        if (minDistance > 50) {
            isOffRoute = true;
        }

        return MapMatchingResult.builder()
            .segmentIndex(bestSegmentIndex)
            .distanceAlongSegment(bestDistanceAlong)
            .matchedPoint(calculateMatchedPoint(route.getSegments().get(bestSegmentIndex), bestDistanceAlong))
            .distanceFromRoute(minDistance)
            .isOffRoute(isOffRoute)
            .confidence(calculateMatchingConfidence(minDistance, location.getAccuracy()))
            .build();
    }

    private double calculateMatchingConfidence(double distance, double gpsAccuracy) {
        // 基于距离和GPS精度计算匹配置信度
        double normalizedDistance = Math.min(distance / 100.0, 1.0); // 100米外置信度为0
        double normalizedAccuracy = Math.min(gpsAccuracy / 20.0, 1.0); // 20米精度为基准

        return Math.max(0, 1.0 - normalizedDistance - normalizedAccuracy * 0.5);
    }
}
```

## 6. 订单状态管理

### 6.1 订单状态机设计

```java
@Component
public class OrderStateMachine {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private PaymentService paymentService;

    // 状态转换核心方法
    public boolean transitionState(String orderId, OrderStatus targetStatus, StateTransitionContext context) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException("Order not found: " + orderId));

        OrderStatus currentStatus = order.getStatus();

        // 验证状态转换是否合法
        if (!isValidTransition(currentStatus, targetStatus)) {
            throw new InvalidStateTransitionException(
                String.format("Invalid transition from %s to %s for order %s",
                             currentStatus, targetStatus, orderId));
        }

        // 执行状态转换前的检查
        StateTransitionValidation validation = validateTransition(order, targetStatus, context);
        if (!validation.isValid()) {
            throw new StateTransitionValidationException(validation.getErrorMessage());
        }

        // 执行状态转换
        Order updatedOrder = executeTransition(order, targetStatus, context);

        // 触发状态转换后的行为
        executePostTransitionActions(updatedOrder, currentStatus, targetStatus, context);

        return true;
    }

    private boolean isValidTransition(OrderStatus from, OrderStatus to) {
        return VALID_TRANSITIONS.getOrDefault(from, Collections.emptySet()).contains(to);
    }

    // 定义状态转换规则
    private static final Map<OrderStatus, Set<OrderStatus>> VALID_TRANSITIONS = Map.of(
        OrderStatus.CREATED, Set.of(OrderStatus.MATCHING, OrderStatus.CANCELLED_BY_PASSENGER),
        OrderStatus.MATCHING, Set.of(OrderStatus.DRIVER_ASSIGNED, OrderStatus.MATCH_TIMEOUT, OrderStatus.CANCELLED_BY_PASSENGER),
        OrderStatus.DRIVER_ASSIGNED, Set.of(OrderStatus.DRIVER_ARRIVING, OrderStatus.DRIVER_CANCELLED, OrderStatus.CANCELLED_BY_PASSENGER),
        OrderStatus.DRIVER_ARRIVING, Set.of(OrderStatus.DRIVER_ARRIVED, OrderStatus.DRIVER_CANCELLED, OrderStatus.CANCELLED_BY_PASSENGER),
        OrderStatus.DRIVER_ARRIVED, Set.of(OrderStatus.PICKUP_CONFIRMED, OrderStatus.DRIVER_CANCELLED, OrderStatus.CANCELLED_BY_PASSENGER),
        OrderStatus.PICKUP_CONFIRMED, Set.of(OrderStatus.IN_TRANSIT, OrderStatus.DRIVER_CANCELLED),
        OrderStatus.IN_TRANSIT, Set.of(OrderStatus.ARRIVED_DESTINATION, OrderStatus.EMERGENCY_STOP),
        OrderStatus.ARRIVED_DESTINATION, Set.of(OrderStatus.PAYMENT_PENDING),
        OrderStatus.PAYMENT_PENDING, Set.of(OrderStatus.PAYMENT_COMPLETED, OrderStatus.PAYMENT_FAILED),
        OrderStatus.PAYMENT_COMPLETED, Set.of(OrderStatus.COMPLETED),
        OrderStatus.PAYMENT_FAILED, Set.of(OrderStatus.PAYMENT_PENDING, OrderStatus.COMPLETED),
        OrderStatus.EMERGENCY_STOP, Set.of(OrderStatus.IN_TRANSIT, OrderStatus.COMPLETED),
        OrderStatus.CANCELLED_BY_PASSENGER, Set.of(),
        OrderStatus.DRIVER_CANCELLED, Set.of(),
        OrderStatus.MATCH_TIMEOUT, Set.of(OrderStatus.MATCHING, OrderStatus.CANCELLED_BY_PASSENGER),
        OrderStatus.COMPLETED, Set.of()
    );

    private StateTransitionValidation validateTransition(Order order, OrderStatus targetStatus, StateTransitionContext context) {
        switch (targetStatus) {
            case DRIVER_ASSIGNED:
                return validateDriverAssignment(order, context);
            case PICKUP_CONFIRMED:
                return validatePickupConfirmation(order, context);
            case PAYMENT_COMPLETED:
                return validatePaymentCompletion(order, context);
            default:
                return StateTransitionValidation.valid();
        }
    }

    private StateTransitionValidation validateDriverAssignment(Order order, StateTransitionContext context) {
        String driverId = context.getDriverId();
        if (driverId == null) {
            return StateTransitionValidation.invalid("Driver ID is required for assignment");
        }

        // 检查司机状态
        DriverStatus driverStatus = driverService.getDriverStatus(driverId);
        if (driverStatus != DriverStatus.AVAILABLE) {
            return StateTransitionValidation.invalid("Driver is not available");
        }

        // 检查距离限制
        double distance = calculateDistance(order.getPickupLocation(), context.getDriverLocation());
        if (distance > MAX_PICKUP_DISTANCE) {
            return StateTransitionValidation.invalid("Driver is too far from pickup location");
        }

        return StateTransitionValidation.valid();
    }
}

// 状态转换上下文
@Data
@Builder
public class StateTransitionContext {
    private String driverId;
    private GeoPoint driverLocation;
    private String cancellationReason;
    private PaymentInfo paymentInfo;
    private String emergencyReason;
    private Map<String, Object> additionalData;
}

// 状态转换后的行为处理
@Component
public class OrderStateActionHandler {

    @EventListener
    public void handleDriverAssigned(OrderStateTransitionEvent event) {
        if (event.getNewStatus() == OrderStatus.DRIVER_ASSIGNED) {
            Order order = event.getOrder();

            // 通知乘客
            notificationService.notifyPassenger(order.getPassengerId(),
                NotificationMessage.builder()
                    .type(NotificationType.DRIVER_ASSIGNED)
                    .title("司机已接单")
                    .content(String.format("司机 %s 已接受您的订单，预计 %d 分钟到达",
                                         order.getDriverName(), order.getEstimatedArrivalTime()))
                    .build());

            // 通知司机
            notificationService.notifyDriver(order.getDriverId(),
                NotificationMessage.builder()
                    .type(NotificationType.NEW_ORDER_ACCEPTED)
                    .title("新订单已接受")
                    .content("请前往乘客上车地点: " + order.getPickupAddress())
                    .build());

            // 开始导航
            navigationService.startNavigation(order.getDriverId(), order.getId());

            // 设置超时监控
            timeoutService.scheduleTimeout(order.getId(), OrderTimeoutType.DRIVER_ARRIVAL,
                                         Duration.ofMinutes(10));
        }
    }

    @EventListener
    public void handlePickupConfirmed(OrderStateTransitionEvent event) {
        if (event.getNewStatus() == OrderStatus.PICKUP_CONFIRMED) {
            Order order = event.getOrder();

            // 开始行程计费
            billingService.startTrip(order.getId());

            // 更新导航目的地
            navigationService.updateDestination(order.getDriverId(), order.getDestination());

            // 通知乘客
            notificationService.notifyPassenger(order.getPassengerId(),
                NotificationMessage.builder()
                    .type(NotificationType.TRIP_STARTED)
                    .title("行程开始")
                    .content("司机已确认接到您，行程开始")
                    .build());
        }
    }

    @EventListener
    public void handlePaymentCompleted(OrderStateTransitionEvent event) {
        if (event.getNewStatus() == OrderStatus.PAYMENT_COMPLETED) {
            Order order = event.getOrder();

            // 结算司机费用
            settlementService.settleDriverEarnings(order);

            // 发送发票
            invoiceService.generateInvoice(order);

            // 请求评价
            ratingService.requestRating(order);
        }
    }
}
```

### 6.2 超时管理机制

```java
@Service
public class OrderTimeoutService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private ScheduledExecutorService scheduledExecutor;

    @Autowired
    private OrderStateMachine orderStateMachine;

    // 设置超时监控
    public void scheduleTimeout(String orderId, OrderTimeoutType timeoutType, Duration timeout) {
        String timeoutKey = String.format("timeout:%s:%s", orderId, timeoutType.name());

        // 在Redis中设置超时
        redisTemplate.opsForValue().set(timeoutKey, System.currentTimeMillis() + timeout.toMillis(), timeout);

        // 调度超时检查任务
        scheduledExecutor.schedule(() -> {
            handleTimeout(orderId, timeoutType);
        }, timeout.toMillis(), TimeUnit.MILLISECONDS);
    }

    // 取消超时监控
    public void cancelTimeout(String orderId, OrderTimeoutType timeoutType) {
        String timeoutKey = String.format("timeout:%s:%s", orderId, timeoutType.name());
        redisTemplate.delete(timeoutKey);
    }

    private void handleTimeout(String orderId, OrderTimeoutType timeoutType) {
        String timeoutKey = String.format("timeout:%s:%s", orderId, timeoutType.name());

        // 检查超时是否仍然有效（可能已被取消）
        if (!redisTemplate.hasKey(timeoutKey)) {
            return;
        }

        try {
            Order order = orderService.getOrder(orderId);

            switch (timeoutType) {
                case DRIVER_ACCEPTANCE:
                    handleDriverAcceptanceTimeout(order);
                    break;
                case DRIVER_ARRIVAL:
                    handleDriverArrivalTimeout(order);
                    break;
                case PICKUP_WAITING:
                    handlePickupWaitingTimeout(order);
                    break;
                case PAYMENT:
                    handlePaymentTimeout(order);
                    break;
            }

        } catch (Exception e) {
            log.error("Failed to handle timeout for order: " + orderId, e);
        } finally {
            // 清理超时记录
            redisTemplate.delete(timeoutKey);
        }
    }

    private void handleDriverAcceptanceTimeout(Order order) {
        if (order.getStatus() == OrderStatus.DRIVER_ASSIGNED) {
            // 司机接单后超时未到达
            orderStateMachine.transitionState(order.getId(), OrderStatus.DRIVER_CANCELLED,
                StateTransitionContext.builder()
                    .cancellationReason("Driver failed to arrive within timeout")
                    .build());

            // 重新匹配
            matchingService.rematchOrder(order.getId());
        }
    }

    private void handleDriverArrivalTimeout(Order order) {
        if (order.getStatus() == OrderStatus.DRIVER_ARRIVING) {
            // 通知双方并给予额外等待时间
            notificationService.notifyBoth(order,
                "司机到达时间超过预期，请耐心等待或联系客服");

            // 延长等待时间
            scheduleTimeout(order.getId(), OrderTimeoutType.DRIVER_ARRIVAL, Duration.ofMinutes(5));
        }
    }

    private void handlePickupWaitingTimeout(Order order) {
        if (order.getStatus() == OrderStatus.DRIVER_ARRIVED) {
            // 司机等待乘客超时
            orderStateMachine.transitionState(order.getId(), OrderStatus.CANCELLED_BY_PASSENGER,
                StateTransitionContext.builder()
                    .cancellationReason("Passenger failed to show up within waiting period")
                    .build());

            // 向乘客收取等待费
            billingService.chargeWaitingFee(order);
        }
    }
}

// 超时类型枚举
public enum OrderTimeoutType {
    DRIVER_ACCEPTANCE(Duration.ofMinutes(30)),    // 司机接单超时
    DRIVER_ARRIVAL(Duration.ofMinutes(15)),       // 司机到达超时
    PICKUP_WAITING(Duration.ofMinutes(5)),        // 乘客上车等待超时
    PAYMENT(Duration.ofMinutes(10));              // 支付超时

    private final Duration defaultTimeout;

    OrderTimeoutType(Duration defaultTimeout) {
        this.defaultTimeout = defaultTimeout;
    }

    public Duration getDefaultTimeout() {
        return defaultTimeout;
    }
}
```

### 6.3 并发状态控制

```java
@Service
public class ConcurrentOrderStateController {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private OrderRepository orderRepository;

    // 使用分布式锁确保状态转换的原子性
    public boolean safeStateTransition(String orderId, OrderStatus targetStatus, StateTransitionContext context) {
        String lockKey = "order_state_lock:" + orderId;
        String lockValue = UUID.randomUUID().toString();

        try {
            // 获取分布式锁
            boolean acquired = acquireLock(lockKey, lockValue, Duration.ofSeconds(10));
            if (!acquired) {
                throw new StateTransitionException("Failed to acquire lock for order: " + orderId);
            }

            // 重新读取最新状态
            Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found: " + orderId));

            // 检查状态是否已被其他操作修改
            if (order.getVersion() != context.getExpectedVersion()) {
                throw new OptimisticLockException("Order state has been modified by another operation");
            }

            // 执行状态转换
            return orderStateMachine.transitionState(orderId, targetStatus, context);

        } finally {
            // 释放锁
            releaseLock(lockKey, lockValue);
        }
    }

    private boolean acquireLock(String lockKey, String lockValue, Duration timeout) {
        return redisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, timeout);
    }

    private void releaseLock(String lockKey, String lockValue) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "  return redis.call('del', KEYS[1]) " +
            "else " +
            "  return 0 " +
            "end";

        redisTemplate.execute(
            RedisScript.of(script, Long.class),
            Collections.singletonList(lockKey),
            lockValue
        );
    }

    // 批量状态转换
    @Transactional
    public void batchStateTransition(List<BatchStateTransition> transitions) {
        // 按订单ID排序，避免死锁
        transitions.sort(Comparator.comparing(BatchStateTransition::getOrderId));

        List<String> lockedOrders = new ArrayList<>();

        try {
            // 依次获取所有订单的锁
            for (BatchStateTransition transition : transitions) {
                String lockKey = "order_state_lock:" + transition.getOrderId();
                String lockValue = UUID.randomUUID().toString();

                boolean acquired = acquireLock(lockKey, lockValue, Duration.ofSeconds(30));
                if (!acquired) {
                    throw new StateTransitionException("Failed to acquire batch lock");
                }

                lockedOrders.add(transition.getOrderId());
            }

            // 执行批量状态转换
            for (BatchStateTransition transition : transitions) {
                orderStateMachine.transitionState(
                    transition.getOrderId(),
                    transition.getTargetStatus(),
                    transition.getContext()
                );
            }

        } finally {
            // 释放所有锁
            for (String orderId : lockedOrders) {
                String lockKey = "order_state_lock:" + orderId;
                redisTemplate.delete(lockKey);
            }
        }
    }
}

// 订单状态审计
@Component
public class OrderStateAuditLogger {

    @Autowired
    private AuditRepository auditRepository;

    @EventListener
    @Async
    public void logStateTransition(OrderStateTransitionEvent event) {
        OrderStateAudit audit = OrderStateAudit.builder()
            .orderId(event.getOrder().getId())
            .previousStatus(event.getPreviousStatus())
            .newStatus(event.getNewStatus())
            .transitionTime(LocalDateTime.now())
            .operatorId(event.getOperatorId())
            .operatorType(event.getOperatorType())
            .reason(event.getReason())
            .contextData(event.getContext())
            .build();

        auditRepository.save(audit);

        // 异常状态转换告警
        if (isAbnormalTransition(event)) {
            alertService.sendAlert(
                AlertType.ABNORMAL_STATE_TRANSITION,
                String.format("Abnormal state transition detected for order %s: %s -> %s",
                             event.getOrder().getId(),
                             event.getPreviousStatus(),
                             event.getNewStatus())
            );
        }
    }

    private boolean isAbnormalTransition(OrderStateTransitionEvent event) {
        // 检测异常状态转换模式
        switch (event.getNewStatus()) {
            case DRIVER_CANCELLED:
            case CANCELLED_BY_PASSENGER:
                return event.getPreviousStatus() == OrderStatus.IN_TRANSIT;
            case EMERGENCY_STOP:
                return true;
            case PAYMENT_FAILED:
                return event.getContext().containsKey("retry_count") &&
                       (Integer) event.getContext().get("retry_count") > 3;
            default:
                return false;
        }
    }
}
```

### 6.4 状态同步机制

```java
@Component
public class OrderStateSynchronizer {

    @Autowired
    private WebSocketTemplate webSocketTemplate;

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // 实时状态同步到客户端
    @EventListener
    public void syncStateToClients(OrderStateTransitionEvent event) {
        Order order = event.getOrder();

        // 构建状态更新消息
        OrderStatusUpdate statusUpdate = OrderStatusUpdate.builder()
            .orderId(order.getId())
            .status(order.getStatus())
            .timestamp(System.currentTimeMillis())
            .estimatedArrival(order.getEstimatedArrivalTime())
            .driverLocation(order.getDriverLocation())
            .build();

        // 发送给乘客
        webSocketTemplate.convertAndSendToUser(
            order.getPassengerId(),
            "/queue/order-status",
            statusUpdate
        );

        // 发送给司机
        if (order.getDriverId() != null) {
            webSocketTemplate.convertAndSendToUser(
                order.getDriverId(),
                "/queue/order-status",
                statusUpdate
            );
        }

        // 缓存最新状态
        redisTemplate.opsForValue().set(
            "order_status:" + order.getId(),
            statusUpdate,
            Duration.ofHours(24)
        );
    }

    // 状态变更事件广播
    @EventListener
    public void broadcastStateChange(OrderStateTransitionEvent event) {
        OrderStateChangeEvent changeEvent = OrderStateChangeEvent.builder()
            .orderId(event.getOrder().getId())
            .passengerId(event.getOrder().getPassengerId())
            .driverId(event.getOrder().getDriverId())
            .previousStatus(event.getPreviousStatus())
            .newStatus(event.getNewStatus())
            .timestamp(System.currentTimeMillis())
            .build();

        // 发布到Kafka进行异步处理
        kafkaTemplate.send("order-state-changes", changeEvent);
    }

    // 处理状态同步失败的补偿机制
    @KafkaListener(topics = "order-state-sync-failed")
    public void handleSyncFailure(OrderStateSyncFailureEvent event) {
        try {
            // 重新获取订单状态
            Order order = orderService.getOrder(event.getOrderId());

            // 重新同步状态
            OrderStateTransitionEvent retryEvent = OrderStateTransitionEvent.builder()
                .order(order)
                .previousStatus(event.getFailedStatus())
                .newStatus(order.getStatus())
                .build();

            syncStateToClients(retryEvent);

        } catch (Exception e) {
            log.error("Failed to handle state sync failure for order: " + event.getOrderId(), e);

            // 如果重试也失败，记录到死信队列
            kafkaTemplate.send("order-state-sync-dead-letter", event);
        }
    }
}
```

## 7. 定价与支付系统

### 7.1 动态定价引擎

```java
@Service
public class DynamicPricingEngine {

    @Autowired
    private SupplyDemandAnalyzer supplyDemandAnalyzer;

    @Autowired
    private WeatherService weatherService;

    @Autowired
    private EventService eventService;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // 计算订单价格
    public PricingResult calculatePrice(PricingRequest request) {
        // 基础定价
        BasePricing basePricing = calculateBasePricing(request);

        // 动态调价因子
        List<PricingFactor> factors = collectPricingFactors(request);

        // 应用调价策略
        PricingResult result = applyPricingStrategy(basePricing, factors, request);

        // 缓存价格结果
        cachePricingResult(request, result);

        return result;
    }

    private BasePricing calculateBasePricing(PricingRequest request) {
        // 基础距离费用
        double distance = request.getDistance();
        double distanceFee = calculateDistanceFee(distance, request.getVehicleType());

        // 基础时间费用
        double estimatedDuration = request.getEstimatedDuration();
        double timeFee = calculateTimeFee(estimatedDuration, request.getVehicleType());

        // 起步价
        double baseFare = getBaseFare(request.getVehicleType(), request.getTimeOfDay());

        return BasePricing.builder()
            .baseFare(baseFare)
            .distanceFee(distanceFee)
            .timeFee(timeFee)
            .totalBaseFee(baseFare + distanceFee + timeFee)
            .build();
    }

    private List<PricingFactor> collectPricingFactors(PricingRequest request) {
        List<PricingFactor> factors = new ArrayList<>();

        // 供需比例因子
        SupplyDemandRatio ratio = supplyDemandAnalyzer.getSupplyDemandRatio(
            request.getPickupLocation(), request.getRequestTime()
        );
        factors.add(PricingFactor.builder()
            .type(PricingFactorType.SUPPLY_DEMAND)
            .multiplier(calculateSupplyDemandMultiplier(ratio))
            .description("供需比例调整: " + ratio.getRatio())
            .build());

        // 时间段因子
        TimeBasedFactor timeBasedFactor = calculateTimeBasedFactor(request.getRequestTime());
        factors.add(PricingFactor.builder()
            .type(PricingFactorType.TIME_BASED)
            .multiplier(timeBasedFactor.getMultiplier())
            .description(timeBasedFactor.getDescription())
            .build());

        // 天气因子
        WeatherCondition weather = weatherService.getCurrentWeather(request.getPickupLocation());
        if (weather.isBadWeather()) {
            factors.add(PricingFactor.builder()
                .type(PricingFactorType.WEATHER)
                .multiplier(1.2)
                .description("恶劣天气调价")
                .build());
        }

        // 特殊事件因子
        List<SpecialEvent> events = eventService.getActiveEvents(
            request.getPickupLocation(), request.getRequestTime()
        );
        for (SpecialEvent event : events) {
            factors.add(PricingFactor.builder()
                .type(PricingFactorType.SPECIAL_EVENT)
                .multiplier(event.getPriceMultiplier())
                .description("特殊事件调价: " + event.getName())
                .build());
        }

        // 路况因子
        TrafficCondition traffic = trafficService.getTrafficCondition(
            request.getPickupLocation(), request.getDestination()
        );
        if (traffic.getCongestionLevel() == CongestionLevel.HEAVY) {
            factors.add(PricingFactor.builder()
                .type(PricingFactorType.TRAFFIC)
                .multiplier(1.15)
                .description("严重拥堵调价")
                .build());
        }

        return factors;
    }

    private PricingResult applyPricingStrategy(BasePricing basePricing, List<PricingFactor> factors, PricingRequest request) {
        double finalPrice = basePricing.getTotalBaseFee();
        double totalMultiplier = 1.0;

        // 应用所有调价因子
        for (PricingFactor factor : factors) {
            finalPrice *= factor.getMultiplier();
            totalMultiplier *= factor.getMultiplier();
        }

        // 应用价格上限
        double maxPrice = basePricing.getTotalBaseFee() * getMaxPriceMultiplier(request.getVehicleType());
        finalPrice = Math.min(finalPrice, maxPrice);

        // 应用价格下限
        double minPrice = basePricing.getTotalBaseFee() * 0.8;
        finalPrice = Math.max(finalPrice, minPrice);

        return PricingResult.builder()
            .basePrice(basePricing.getTotalBaseFee())
            .finalPrice(finalPrice)
            .totalMultiplier(totalMultiplier)
            .factors(factors)
            .currency("CNY")
            .validUntil(LocalDateTime.now().plusMinutes(10))
            .breakdown(buildPriceBreakdown(basePricing, factors, finalPrice))
            .build();
    }

    // 供需比例计算
    private double calculateSupplyDemandMultiplier(SupplyDemandRatio ratio) {
        double supplyDemandRatio = ratio.getRatio();

        if (supplyDemandRatio >= 1.5) {
            return 0.9; // 供大于求，降价
        } else if (supplyDemandRatio >= 1.0) {
            return 1.0; // 供需平衡
        } else if (supplyDemandRatio >= 0.7) {
            return 1.2; // 轻微供不应求
        } else if (supplyDemandRatio >= 0.5) {
            return 1.5; // 中度供不应求
        } else {
            return 2.0; // 严重供不应求
        }
    }

    // 时间段调价
    private TimeBasedFactor calculateTimeBasedFactor(LocalDateTime requestTime) {
        int hour = requestTime.getHour();
        DayOfWeek dayOfWeek = requestTime.getDayOfWeek();

        // 工作日早高峰 (7-9点)
        if (isWeekday(dayOfWeek) && hour >= 7 && hour <= 9) {
            return TimeBasedFactor.builder()
                .multiplier(1.5)
                .description("工作日早高峰")
                .build();
        }

        // 工作日晚高峰 (17-20点)
        if (isWeekday(dayOfWeek) && hour >= 17 && hour <= 20) {
            return TimeBasedFactor.builder()
                .multiplier(1.3)
                .description("工作日晚高峰")
                .build();
        }

        // 周末夜间 (21-2点)
        if (isWeekend(dayOfWeek) && (hour >= 21 || hour <= 2)) {
            return TimeBasedFactor.builder()
                .multiplier(1.2)
                .description("周末夜间")
                .build();
        }

        // 深夜时段 (23-6点)
        if (hour >= 23 || hour <= 6) {
            return TimeBasedFactor.builder()
                .multiplier(1.4)
                .description("深夜时段")
                .build();
        }

        return TimeBasedFactor.builder()
            .multiplier(1.0)
            .description("正常时段")
            .build();
    }
}

// 供需分析器
@Service
public class SupplyDemandAnalyzer {

    @Autowired
    private LocationStorageService locationService;

    @Autowired
    private OrderService orderService;

    public SupplyDemandRatio getSupplyDemandRatio(GeoPoint location, LocalDateTime time) {
        // 在指定位置周围3公里范围内分析
        double radius = 3000; // 3km

        // 获取供给侧数据（可用司机数量）
        List<LocationData> availableDrivers = locationService.getNearbyDrivers(
            location, radius, DriverStatus.AVAILABLE
        );

        // 获取需求侧数据（等待中的订单数量）
        List<Order> pendingOrders = orderService.getPendingOrdersInArea(location, radius);

        // 计算历史同时段数据
        HistoricalSupplyDemand historical = getHistoricalData(location, time);

        // 计算当前供需比例
        double currentSupply = availableDrivers.size();
        double currentDemand = pendingOrders.size() + predictShortTermDemand(location, time);

        double ratio = currentSupply / Math.max(currentDemand, 1.0);

        return SupplyDemandRatio.builder()
            .location(location)
            .timestamp(time)
            .supply(currentSupply)
            .demand(currentDemand)
            .ratio(ratio)
            .historicalRatio(historical.getAverageRatio())
            .trend(calculateTrend(ratio, historical.getAverageRatio()))
            .build();
    }

    private double predictShortTermDemand(GeoPoint location, LocalDateTime time) {
        // 使用机器学习模型预测未来15分钟的需求
        DemandPredictionRequest request = DemandPredictionRequest.builder()
            .location(location)
            .timestamp(time)
            .timeWindow(Duration.ofMinutes(15))
            .weatherCondition(weatherService.getCurrentWeather(location))
            .build();

        return demandPredictionService.predictDemand(request);
    }
}
```

### 7.2 支付处理系统

```java
@Service
public class PaymentProcessingService {

    @Autowired
    private PaymentGatewayFactory gatewayFactory;

    @Autowired
    private RiskControlService riskControlService;

    @Autowired
    private WalletService walletService;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // 发起支付
    public PaymentResult initiatePayment(PaymentRequest request) {
        // 风险控制检查
        RiskAssessment riskAssessment = riskControlService.assessPaymentRisk(request);
        if (riskAssessment.getRiskLevel() == RiskLevel.HIGH) {
            return PaymentResult.failed("支付风险过高，请联系客服");
        }

        // 选择支付方式
        PaymentMethod method = selectPaymentMethod(request);

        try {
            PaymentResult result;

            switch (method.getType()) {
                case WALLET:
                    result = processWalletPayment(request, method);
                    break;
                case CREDIT_CARD:
                    result = processCreditCardPayment(request, method);
                    break;
                case WECHAT_PAY:
                    result = processWeChatPayment(request, method);
                    break;
                case ALIPAY:
                    result = processAliPayment(request, method);
                    break;
                default:
                    throw new UnsupportedPaymentMethodException("Unsupported payment method: " + method.getType());
            }

            // 记录支付日志
            logPaymentAttempt(request, result);

            return result;

        } catch (Exception e) {
            log.error("Payment processing failed for order: " + request.getOrderId(), e);
            return PaymentResult.failed("支付处理失败: " + e.getMessage());
        }
    }

    private PaymentMethod selectPaymentMethod(PaymentRequest request) {
        List<PaymentMethod> availableMethods = getAvailablePaymentMethods(request.getUserId());

        // 优先使用用户指定的支付方式
        if (request.getPreferredPaymentMethodId() != null) {
            return availableMethods.stream()
                .filter(method -> method.getId().equals(request.getPreferredPaymentMethodId()))
                .findFirst()
                .orElse(availableMethods.get(0));
        }

        // 智能推荐支付方式
        return recommendPaymentMethod(availableMethods, request);
    }

    private PaymentMethod recommendPaymentMethod(List<PaymentMethod> methods, PaymentRequest request) {
        // 根据用户历史偏好、支付金额、可用余额等因素推荐
        for (PaymentMethod method : methods) {
            if (method.getType() == PaymentMethodType.WALLET) {
                WalletBalance balance = walletService.getBalance(request.getUserId());
                if (balance.getAvailableAmount() >= request.getAmount()) {
                    return method; // 优先使用钱包支付
                }
            }
        }

        // 回退到默认支付方式
        return methods.stream()
            .filter(method -> method.isDefault())
            .findFirst()
            .orElse(methods.get(0));
    }

    // 钱包支付处理
    private PaymentResult processWalletPayment(PaymentRequest request, PaymentMethod method) {
        try {
            WalletTransaction transaction = walletService.debit(
                request.getUserId(),
                request.getAmount(),
                TransactionType.RIDE_PAYMENT,
                request.getOrderId()
            );

            return PaymentResult.builder()
                .success(true)
                .transactionId(transaction.getId())
                .amount(request.getAmount())
                .currency(request.getCurrency())
                .paymentMethod(method)
                .processedAt(LocalDateTime.now())
                .build();

        } catch (InsufficientBalanceException e) {
            return PaymentResult.failed("钱包余额不足");
        } catch (Exception e) {
            return PaymentResult.failed("钱包支付失败: " + e.getMessage());
        }
    }

    // 信用卡支付处理
    private PaymentResult processCreditCardPayment(PaymentRequest request, PaymentMethod method) {
        PaymentGateway gateway = gatewayFactory.getGateway(method.getGatewayProvider());

        GatewayPaymentRequest gatewayRequest = GatewayPaymentRequest.builder()
            .amount(request.getAmount())
            .currency(request.getCurrency())
            .cardToken(method.getToken())
            .merchantOrderId(request.getOrderId())
            .description("打车费用支付")
            .build();

        GatewayPaymentResponse response = gateway.processPayment(gatewayRequest);

        if (response.isSuccess()) {
            return PaymentResult.builder()
                .success(true)
                .transactionId(response.getTransactionId())
                .amount(request.getAmount())
                .currency(request.getCurrency())
                .paymentMethod(method)
                .gatewayResponse(response)
                .processedAt(LocalDateTime.now())
                .build();
        } else {
            return PaymentResult.failed("银行卡支付失败: " + response.getErrorMessage());
        }
    }

    // 微信支付处理
    private PaymentResult processWeChatPayment(PaymentRequest request, PaymentMethod method) {
        WeChatPayGateway wechatGateway = (WeChatPayGateway) gatewayFactory.getGateway("wechat");

        WeChatPayRequest wechatRequest = WeChatPayRequest.builder()
            .openId(method.getExternalUserId())
            .amount((int) (request.getAmount() * 100)) // 转换为分
            .description("打车费用")
            .tradeNo(generateTradeNo(request.getOrderId()))
            .notifyUrl("https://api.ride-app.com/payment/wechat/notify")
            .build();

        WeChatPayResponse response = wechatGateway.createPayment(wechatRequest);

        if (response.isSuccess()) {
            return PaymentResult.builder()
                .success(true)
                .transactionId(response.getPrepayId())
                .amount(request.getAmount())
                .currency(request.getCurrency())
                .paymentMethod(method)
                .wechatPayInfo(response.getPaymentInfo())
                .processedAt(LocalDateTime.now())
                .build();
        } else {
            return PaymentResult.failed("微信支付创建失败: " + response.getErrorMsg());
        }
    }

    // 支付回调处理
    @PostMapping("/payment/wechat/notify")
    public ResponseEntity<String> handleWeChatNotify(@RequestBody String notifyData) {
        try {
            WeChatPayNotification notification = wechatPayGateway.parseNotification(notifyData);

            if (notification.isSuccess()) {
                // 更新订单支付状态
                orderService.updatePaymentStatus(
                    notification.getOutTradeNo(),
                    PaymentStatus.COMPLETED,
                    notification.getTransactionId()
                );

                // 触发支付成功事件
                paymentEventPublisher.publishPaymentSuccessEvent(
                    notification.getOutTradeNo(),
                    notification.getTotalFee() / 100.0
                );
            }

            return ResponseEntity.ok("SUCCESS");

        } catch (Exception e) {
            log.error("Failed to process WeChat payment notification", e);
            return ResponseEntity.status(500).body("FAIL");
        }
    }
}

// 钱包服务
@Service
public class WalletService {

    @Autowired
    private WalletRepository walletRepository;

    @Autowired
    private TransactionRepository transactionRepository;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // 扣款操作
    @Transactional
    public WalletTransaction debit(String userId, double amount, TransactionType type, String orderId) {
        String lockKey = "wallet_lock:" + userId;
        String lockValue = UUID.randomUUID().toString();

        try {
            // 获取钱包锁
            boolean acquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(10));

            if (!acquired) {
                throw new WalletOperationException("无法获取钱包锁");
            }

            Wallet wallet = walletRepository.findByUserId(userId)
                .orElseThrow(() -> new WalletNotFoundException("钱包不存在"));

            if (wallet.getBalance() < amount) {
                throw new InsufficientBalanceException("余额不足");
            }

            // 更新钱包余额
            wallet.setBalance(wallet.getBalance() - amount);
            wallet.setUpdateTime(LocalDateTime.now());
            walletRepository.save(wallet);

            // 创建交易记录
            WalletTransaction transaction = WalletTransaction.builder()
                .userId(userId)
                .amount(-amount)
                .type(type)
                .orderId(orderId)
                .balanceAfter(wallet.getBalance())
                .status(TransactionStatus.COMPLETED)
                .createTime(LocalDateTime.now())
                .build();

            transactionRepository.save(transaction);

            // 更新缓存
            updateWalletCache(userId, wallet);

            return transaction;

        } finally {
            // 释放锁
            releaseLock(lockKey, lockValue);
        }
    }

    // 充值操作
    @Transactional
    public WalletTransaction credit(String userId, double amount, TransactionType type, String externalTransactionId) {
        String lockKey = "wallet_lock:" + userId;
        String lockValue = UUID.randomUUID().toString();

        try {
            boolean acquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(10));

            if (!acquired) {
                throw new WalletOperationException("无法获取钱包锁");
            }

            Wallet wallet = walletRepository.findByUserId(userId)
                .orElseGet(() -> createWallet(userId));

            // 更新钱包余额
            wallet.setBalance(wallet.getBalance() + amount);
            wallet.setUpdateTime(LocalDateTime.now());
            walletRepository.save(wallet);

            // 创建交易记录
            WalletTransaction transaction = WalletTransaction.builder()
                .userId(userId)
                .amount(amount)
                .type(type)
                .externalTransactionId(externalTransactionId)
                .balanceAfter(wallet.getBalance())
                .status(TransactionStatus.COMPLETED)
                .createTime(LocalDateTime.now())
                .build();

            transactionRepository.save(transaction);

            // 更新缓存
            updateWalletCache(userId, wallet);

            return transaction;

        } finally {
            releaseLock(lockKey, lockValue);
        }
    }

    // 获取钱包余额
    public WalletBalance getBalance(String userId) {
        String cacheKey = "wallet_balance:" + userId;

        WalletBalance cached = (WalletBalance) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }

        Wallet wallet = walletRepository.findByUserId(userId)
            .orElseGet(() -> createWallet(userId));

        WalletBalance balance = WalletBalance.builder()
            .userId(userId)
            .totalAmount(wallet.getBalance())
            .availableAmount(wallet.getBalance() - wallet.getFrozenAmount())
            .frozenAmount(wallet.getFrozenAmount())
            .updateTime(wallet.getUpdateTime())
            .build();

        // 缓存余额信息
        redisTemplate.opsForValue().set(cacheKey, balance, Duration.ofMinutes(5));

        return balance;
    }
}
```

### 7.3 费用结算系统

```java
@Service
public class SettlementService {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private DriverAccountService driverAccountService;

    @Autowired
    private PlatformAccountService platformAccountService;

    @Autowired
    private TaxService taxService;

    // 司机费用结算
    @Transactional
    public SettlementResult settleDriverEarnings(Order order) {
        // 计算司机收入
        DriverEarningsCalculation earnings = calculateDriverEarnings(order);

        // 创建结算记录
        Settlement settlement = Settlement.builder()
            .orderId(order.getId())
            .driverId(order.getDriverId())
            .totalAmount(order.getFinalPrice())
            .driverEarnings(earnings.getNetEarnings())
            .platformFee(earnings.getPlatformFee())
            .taxes(earnings.getTaxes())
            .settlementTime(LocalDateTime.now())
            .status(SettlementStatus.PENDING)
            .build();

        settlementRepository.save(settlement);

        try {
            // 转账到司机账户
            TransferResult transferResult = driverAccountService.transfer(
                order.getDriverId(),
                earnings.getNetEarnings(),
                TransferType.RIDE_EARNINGS,
                order.getId()
            );

            // 更新结算状态
            settlement.setStatus(SettlementStatus.COMPLETED);
            settlement.setTransactionId(transferResult.getTransactionId());
            settlementRepository.save(settlement);

            // 记录平台收入
            platformAccountService.recordRevenue(
                earnings.getPlatformFee(),
                RevenueType.COMMISSION,
                order.getId()
            );

            // 处理税务
            if (earnings.getTaxes() > 0) {
                taxService.recordTaxLiability(order.getDriverId(), earnings.getTaxes(), order.getId());
            }

            return SettlementResult.success(settlement, transferResult);

        } catch (Exception e) {
            // 结算失败，标记状态
            settlement.setStatus(SettlementStatus.FAILED);
            settlement.setErrorMessage(e.getMessage());
            settlementRepository.save(settlement);

            log.error("Driver settlement failed for order: " + order.getId(), e);
            return SettlementResult.failed(e.getMessage());
        }
    }

    private DriverEarningsCalculation calculateDriverEarnings(Order order) {
        double totalAmount = order.getFinalPrice();

        // 计算平台佣金
        double commissionRate = getCommissionRate(order.getDriverId(), order.getVehicleType());
        double platformFee = totalAmount * commissionRate;

        // 计算税费
        double taxRate = taxService.getTaxRate(order.getDriverId());
        double grossEarnings = totalAmount - platformFee;
        double taxes = grossEarnings * taxRate;

        // 计算净收入
        double netEarnings = grossEarnings - taxes;

        return DriverEarningsCalculation.builder()
            .totalAmount(totalAmount)
            .platformFee(platformFee)
            .grossEarnings(grossEarnings)
            .taxes(taxes)
            .netEarnings(netEarnings)
            .commissionRate(commissionRate)
            .taxRate(taxRate)
            .build();
    }

    // 获取司机佣金率
    private double getCommissionRate(String driverId, VehicleType vehicleType) {
        // 基础佣金率
        double baseRate = 0.20; // 20%

        // 根据车型调整
        switch (vehicleType) {
            case ECONOMY:
                baseRate = 0.20;
                break;
            case COMFORT:
                baseRate = 0.18;
                break;
            case BUSINESS:
                baseRate = 0.15;
                break;
            case LUXURY:
                baseRate = 0.12;
                break;
        }

        // 根据司机等级调整
        DriverLevel driverLevel = driverService.getDriverLevel(driverId);
        double levelDiscount = driverLevel.getCommissionDiscount();

        return Math.max(baseRate - levelDiscount, 0.10); // 最低10%佣金
    }

    // 批量结算
    @Scheduled(fixedDelay = 300000) // 每5分钟执行一次
    public void batchSettlement() {
        // 获取待结算的已完成订单
        List<Order> pendingOrders = orderRepository.findPendingSettlementOrders(
            OrderStatus.COMPLETED,
            LocalDateTime.now().minusMinutes(10)
        );

        if (pendingOrders.isEmpty()) {
            return;
        }

        log.info("Processing batch settlement for {} orders", pendingOrders.size());

        // 按司机分组批量处理
        Map<String, List<Order>> ordersByDriver = pendingOrders.stream()
            .collect(Collectors.groupingBy(Order::getDriverId));

        for (Map.Entry<String, List<Order>> entry : ordersByDriver.entrySet()) {
            try {
                processBatchSettlementForDriver(entry.getKey(), entry.getValue());
            } catch (Exception e) {
                log.error("Batch settlement failed for driver: " + entry.getKey(), e);
            }
        }
    }

    private void processBatchSettlementForDriver(String driverId, List<Order> orders) {
        double totalEarnings = 0;
        List<Settlement> settlements = new ArrayList<>();

        // 计算总收入
        for (Order order : orders) {
            DriverEarningsCalculation earnings = calculateDriverEarnings(order);
            totalEarnings += earnings.getNetEarnings();

            Settlement settlement = Settlement.builder()
                .orderId(order.getId())
                .driverId(driverId)
                .totalAmount(order.getFinalPrice())
                .driverEarnings(earnings.getNetEarnings())
                .platformFee(earnings.getPlatformFee())
                .taxes(earnings.getTaxes())
                .settlementTime(LocalDateTime.now())
                .status(SettlementStatus.PENDING)
                .build();

            settlements.add(settlement);
        }

        // 批量转账
        if (totalEarnings > 0) {
            try {
                TransferResult transferResult = driverAccountService.batchTransfer(
                    driverId,
                    totalEarnings,
                    TransferType.BATCH_RIDE_EARNINGS,
                    orders.stream().map(Order::getId).collect(Collectors.toList())
                );

                // 更新所有结算记录状态
                settlements.forEach(settlement -> {
                    settlement.setStatus(SettlementStatus.COMPLETED);
                    settlement.setTransactionId(transferResult.getTransactionId());
                });

                settlementRepository.saveAll(settlements);

                log.info("Batch settlement completed for driver: {}, amount: {}", driverId, totalEarnings);

            } catch (Exception e) {
                // 批量转账失败，回退到单笔处理
                log.warn("Batch transfer failed for driver: " + driverId + ", falling back to individual transfers");

                for (Order order : orders) {
                    try {
                        settleDriverEarnings(order);
                    } catch (Exception ex) {
                        log.error("Individual settlement failed for order: " + order.getId(), ex);
                    }
                }
            }
        }
    }
}

// 发票服务
@Service
public class InvoiceService {

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private EmailService emailService;

    // 生成发票
    public Invoice generateInvoice(Order order) {
        Invoice invoice = Invoice.builder()
            .orderId(order.getId())
            .passengerId(order.getPassengerId())
            .invoiceNumber(generateInvoiceNumber())
            .amount(order.getFinalPrice())
            .currency(order.getCurrency())
            .issueDate(LocalDate.now())
            .dueDate(LocalDate.now().plusDays(30))
            .status(InvoiceStatus.ISSUED)
            .build();

        // 生成发票项目明细
        List<InvoiceItem> items = buildInvoiceItems(order);
        invoice.setItems(items);

        // 保存发票
        invoiceRepository.save(invoice);

        // 生成PDF
        byte[] pdfContent = generateInvoicePdf(invoice);
        invoice.setPdfContent(pdfContent);
        invoiceRepository.save(invoice);

        // 发送邮件
        sendInvoiceEmail(order.getPassengerEmail(), invoice);

        return invoice;
    }

    private List<InvoiceItem> buildInvoiceItems(Order order) {
        List<InvoiceItem> items = new ArrayList<>();

        // 基础费用
        items.add(InvoiceItem.builder()
            .description("打车服务费")
            .quantity(1)
            .unitPrice(order.getBasePrice())
            .totalPrice(order.getBasePrice())
            .build());

        // 动态调价
        if (order.getFinalPrice() > order.getBasePrice()) {
            double surcharge = order.getFinalPrice() - order.getBasePrice();
            items.add(InvoiceItem.builder()
                .description("动态调价")
                .quantity(1)
                .unitPrice(surcharge)
                .totalPrice(surcharge)
                .build());
        }

        return items;
    }
}
```

## 8. 实时通信机制

### 8.1 WebSocket通信架构

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Autowired
    private WebSocketConnectionManager connectionManager;

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new RideWebSocketHandler(), "/ws/ride")
                .setAllowedOrigins("*")
                .addInterceptors(new WebSocketAuthInterceptor())
                .withSockJS();
    }

    @Bean
    public WebSocketConnectionManager webSocketConnectionManager() {
        return new WebSocketConnectionManager();
    }
}

// WebSocket处理器
@Component
public class RideWebSocketHandler extends TextWebSocketHandler {

    @Autowired
    private WebSocketConnectionManager connectionManager;

    @Autowired
    private MessageProcessor messageProcessor;

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String userId = getUserId(session);
        String userType = getUserType(session); // PASSENGER or DRIVER

        // 注册连接
        connectionManager.registerConnection(userId, userType, session);

        // 发送连接确认
        sendMessage(session, ConnectConfirmMessage.builder()
            .type(MessageType.CONNECT_CONFIRM)
            .userId(userId)
            .timestamp(System.currentTimeMillis())
            .build());

        log.info("WebSocket connection established for user: {} ({})", userId, userType);
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        try {
            String userId = getUserId(session);
            IncomingMessage incomingMessage = parseMessage(message.getPayload());

            // 处理消息
            OutgoingMessage response = messageProcessor.processMessage(userId, incomingMessage);

            if (response != null) {
                sendMessage(session, response);
            }

        } catch (Exception e) {
            log.error("Error handling WebSocket message", e);
            sendErrorMessage(session, "消息处理失败: " + e.getMessage());
        }
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        String userId = getUserId(session);
        connectionManager.removeConnection(userId);

        log.info("WebSocket connection closed for user: {}", userId);
    }

    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        log.error("WebSocket transport error for session: " + session.getId(), exception);

        String userId = getUserId(session);
        connectionManager.handleConnectionError(userId, exception);
    }

    private void sendMessage(WebSocketSession session, Object message) {
        try {
            String jsonMessage = objectMapper.writeValueAsString(message);
            session.sendMessage(new TextMessage(jsonMessage));
        } catch (Exception e) {
            log.error("Failed to send WebSocket message", e);
        }
    }
}

// WebSocket连接管理器
@Component
public class WebSocketConnectionManager {

    private final ConcurrentHashMap<String, UserConnection> connections = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, Set<String>> usersByType = new ConcurrentHashMap<>();

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    public void registerConnection(String userId, String userType, WebSocketSession session) {
        UserConnection connection = UserConnection.builder()
            .userId(userId)
            .userType(UserType.valueOf(userType))
            .session(session)
            .connectedAt(LocalDateTime.now())
            .lastHeartbeat(LocalDateTime.now())
            .build();

        connections.put(userId, connection);

        // 按类型分组管理
        usersByType.computeIfAbsent(userType, k -> ConcurrentHashMap.newKeySet()).add(userId);

        // 在Redis中记录连接状态
        redisTemplate.opsForValue().set(
            "ws_connection:" + userId,
            ConnectionStatus.builder()
                .userId(userId)
                .userType(userType)
                .serverId(getServerId())
                .connectedAt(LocalDateTime.now())
                .build(),
            Duration.ofHours(24)
        );

        log.info("Registered WebSocket connection for user: {} ({})", userId, userType);
    }

    public void removeConnection(String userId) {
        UserConnection connection = connections.remove(userId);
        if (connection != null) {
            String userType = connection.getUserType().name();
            Set<String> typeUsers = usersByType.get(userType);
            if (typeUsers != null) {
                typeUsers.remove(userId);
            }

            // 清理Redis状态
            redisTemplate.delete("ws_connection:" + userId);
        }
    }

    public boolean sendToUser(String userId, Object message) {
        UserConnection connection = connections.get(userId);
        if (connection != null && connection.getSession().isOpen()) {
            try {
                String jsonMessage = objectMapper.writeValueAsString(message);
                connection.getSession().sendMessage(new TextMessage(jsonMessage));
                return true;
            } catch (Exception e) {
                log.error("Failed to send message to user: " + userId, e);
                removeConnection(userId);
                return false;
            }
        }

        // 尝试通过集群发送
        return sendToUserViaCluster(userId, message);
    }

    public void broadcastToDrivers(Object message, GeoPoint location, double radius) {
        Set<String> driverIds = usersByType.get(UserType.DRIVER.name());
        if (driverIds != null) {
            for (String driverId : driverIds) {
                // 检查司机是否在指定范围内
                if (isDriverInRange(driverId, location, radius)) {
                    sendToUser(driverId, message);
                }
            }
        }
    }

    // 心跳检测
    @Scheduled(fixedDelay = 30000) // 每30秒检查一次
    public void heartbeatCheck() {
        LocalDateTime cutoff = LocalDateTime.now().minusMinutes(2);

        connections.entrySet().removeIf(entry -> {
            UserConnection connection = entry.getValue();
            if (connection.getLastHeartbeat().isBefore(cutoff)) {
                try {
                    connection.getSession().close(CloseStatus.GOING_AWAY);
                } catch (Exception e) {
                    log.warn("Error closing stale connection for user: " + entry.getKey());
                }
                return true;
            }
            return false;
        });
    }

    private boolean sendToUserViaCluster(String userId, Object message) {
        // 查询用户连接在哪个服务器上
        ConnectionStatus status = (ConnectionStatus) redisTemplate.opsForValue()
            .get("ws_connection:" + userId);

        if (status != null && !status.getServerId().equals(getServerId())) {
            // 通过Redis发布订阅转发消息
            ClusterMessage clusterMessage = ClusterMessage.builder()
                .targetUserId(userId)
                .targetServerId(status.getServerId())
                .message(message)
                .timestamp(System.currentTimeMillis())
                .build();

            redisTemplate.convertAndSend("ws_cluster_message", clusterMessage);
            return true;
        }

        return false;
    }
}
```

### 8.2 消息处理系统

```java
@Service
public class MessageProcessor {

    @Autowired
    private OrderService orderService;

    @Autowired
    private LocationService locationService;

    @Autowired
    private NotificationService notificationService;

    public OutgoingMessage processMessage(String userId, IncomingMessage message) {
        try {
            switch (message.getType()) {
                case LOCATION_UPDATE:
                    return handleLocationUpdate(userId, (LocationUpdateMessage) message);
                case ORDER_STATUS_REQUEST:
                    return handleOrderStatusRequest(userId, (OrderStatusRequestMessage) message);
                case CHAT_MESSAGE:
                    return handleChatMessage(userId, (ChatMessage) message);
                case DRIVER_RESPONSE:
                    return handleDriverResponse(userId, (DriverResponseMessage) message);
                case HEARTBEAT:
                    return handleHeartbeat(userId);
                default:
                    return ErrorMessage.builder()
                        .error("Unsupported message type: " + message.getType())
                        .build();
            }
        } catch (Exception e) {
            log.error("Error processing message from user: " + userId, e);
            return ErrorMessage.builder()
                .error("消息处理失败: " + e.getMessage())
                .build();
        }
    }

    private OutgoingMessage handleLocationUpdate(String userId, LocationUpdateMessage message) {
        LocationData locationData = LocationData.builder()
            .userId(userId)
            .latitude(message.getLatitude())
            .longitude(message.getLongitude())
            .accuracy(message.getAccuracy())
            .speed(message.getSpeed())
            .heading(message.getHeading())
            .timestamp(message.getTimestamp())
            .build();

        // 更新位置信息
        locationService.updateLocation(locationData);

        // 如果是司机，检查是否有相关订单需要更新
        if (isDriver(userId)) {
            List<Order> activeOrders = orderService.getActiveOrdersByDriver(userId);
            for (Order order : activeOrders) {
                // 通知乘客司机位置更新
                notifyPassengerLocationUpdate(order, locationData);

                // 检查是否到达接客点或目的地
                checkArrivalStatus(order, locationData);
            }
        }

        return LocationUpdateConfirmMessage.builder()
            .type(MessageType.LOCATION_UPDATE_CONFIRM)
            .timestamp(System.currentTimeMillis())
            .build();
    }

    private OutgoingMessage handleChatMessage(String userId, ChatMessage message) {
        // 验证消息内容
        if (message.getContent().length() > 500) {
            return ErrorMessage.builder()
                .error("消息内容过长")
                .build();
        }

        // 获取订单信息
        Order order = orderService.getOrder(message.getOrderId());
        if (order == null) {
            return ErrorMessage.builder()
                .error("订单不存在")
                .build();
        }

        // 验证用户是否参与此订单
        if (!userId.equals(order.getPassengerId()) && !userId.equals(order.getDriverId())) {
            return ErrorMessage.builder()
                .error("无权限发送消息")
                .build();
        }

        // 确定接收方
        String recipientId = userId.equals(order.getPassengerId()) ?
            order.getDriverId() : order.getPassengerId();

        // 构建聊天消息
        ChatMessage chatMessage = ChatMessage.builder()
            .type(MessageType.CHAT_MESSAGE)
            .orderId(order.getId())
            .senderId(userId)
            .senderType(getUserType(userId))
            .content(message.getContent())
            .messageType(message.getMessageType())
            .timestamp(System.currentTimeMillis())
            .build();

        // 发送给接收方
        connectionManager.sendToUser(recipientId, chatMessage);

        // 存储消息记录
        chatService.saveMessage(chatMessage);

        return MessageSentConfirmMessage.builder()
            .type(MessageType.MESSAGE_SENT_CONFIRM)
            .messageId(chatMessage.getMessageId())
            .timestamp(System.currentTimeMillis())
            .build();
    }

    private OutgoingMessage handleDriverResponse(String userId, DriverResponseMessage message) {
        Order order = orderService.getOrder(message.getOrderId());
        if (order == null) {
            return ErrorMessage.builder()
                .error("订单不存在")
                .build();
        }

        if (!userId.equals(order.getDriverId())) {
            return ErrorMessage.builder()
                .error("无权限操作此订单")
                .build();
        }

        try {
            switch (message.getAction()) {
                case ACCEPT:
                    orderService.acceptOrder(order.getId(), userId);
                    break;
                case REJECT:
                    orderService.rejectOrder(order.getId(), userId, message.getReason());
                    break;
                case ARRIVE:
                    orderService.confirmArrival(order.getId(), userId);
                    break;
                case PICKUP:
                    orderService.confirmPickup(order.getId(), userId);
                    break;
                case COMPLETE:
                    orderService.completeOrder(order.getId(), userId);
                    break;
                default:
                    return ErrorMessage.builder()
                        .error("未知操作类型")
                        .build();
            }

            return ActionConfirmMessage.builder()
                .type(MessageType.ACTION_CONFIRM)
                .orderId(order.getId())
                .action(message.getAction())
                .timestamp(System.currentTimeMillis())
                .build();

        } catch (Exception e) {
            return ErrorMessage.builder()
                .error("操作失败: " + e.getMessage())
                .build();
        }
    }

    private void notifyPassengerLocationUpdate(Order order, LocationData driverLocation) {
        LocationUpdateNotification notification = LocationUpdateNotification.builder()
            .type(MessageType.DRIVER_LOCATION_UPDATE)
            .orderId(order.getId())
            .driverLocation(driverLocation)
            .estimatedArrival(calculateETA(order, driverLocation))
            .timestamp(System.currentTimeMillis())
            .build();

        connectionManager.sendToUser(order.getPassengerId(), notification);
    }

    private void checkArrivalStatus(Order order, LocationData driverLocation) {
        GeoPoint driverPoint = GeoPoint.builder()
            .latitude(driverLocation.getLatitude())
            .longitude(driverLocation.getLongitude())
            .build();

        double pickupDistance = GeoUtils.calculateDistance(driverPoint, order.getPickupLocation());
        double destinationDistance = GeoUtils.calculateDistance(driverPoint, order.getDestination());

        // 检查是否到达接客点
        if (order.getStatus() == OrderStatus.DRIVER_ARRIVING && pickupDistance <= 100) { // 100米内
            ArrivalNotification notification = ArrivalNotification.builder()
                .type(MessageType.DRIVER_ARRIVED_PICKUP)
                .orderId(order.getId())
                .message("司机已到达接客点")
                .timestamp(System.currentTimeMillis())
                .build();

            connectionManager.sendToUser(order.getPassengerId(), notification);
            connectionManager.sendToUser(order.getDriverId(), notification);

            // 自动更新订单状态
            orderService.updateOrderStatus(order.getId(), OrderStatus.DRIVER_ARRIVED);
        }

        // 检查是否到达目的地
        if (order.getStatus() == OrderStatus.IN_TRANSIT && destinationDistance <= 100) {
            ArrivalNotification notification = ArrivalNotification.builder()
                .type(MessageType.ARRIVED_DESTINATION)
                .orderId(order.getId())
                .message("已到达目的地")
                .timestamp(System.currentTimeMillis())
                .build();

            connectionManager.sendToUser(order.getPassengerId(), notification);
            connectionManager.sendToUser(order.getDriverId(), notification);

            // 自动更新订单状态
            orderService.updateOrderStatus(order.getId(), OrderStatus.ARRIVED_DESTINATION);
        }
    }
}

// 消息广播服务
@Service
public class MessageBroadcastService {

    @Autowired
    private WebSocketConnectionManager connectionManager;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // 广播新订单给附近司机
    public void broadcastNewOrder(Order order) {
        NewOrderBroadcast broadcast = NewOrderBroadcast.builder()
            .type(MessageType.NEW_ORDER_BROADCAST)
            .orderId(order.getId())
            .pickupLocation(order.getPickupLocation())
            .destination(order.getDestination())
            .estimatedPrice(order.getEstimatedPrice())
            .passengerRating(order.getPassengerRating())
            .distance(order.getDistance())
            .estimatedDuration(order.getEstimatedDuration())
            .timestamp(System.currentTimeMillis())
            .validUntil(System.currentTimeMillis() + 30000) // 30秒有效期
            .build();

        // 广播给附近的可用司机
        connectionManager.broadcastToDrivers(
            broadcast,
            order.getPickupLocation(),
            NEARBY_DRIVER_RADIUS
        );

        // 记录广播日志
        logOrderBroadcast(order.getId(), broadcast);
    }

    // 发送系统通知
    public void sendSystemNotification(String userId, String title, String content, NotificationType type) {
        SystemNotification notification = SystemNotification.builder()
            .type(MessageType.SYSTEM_NOTIFICATION)
            .title(title)
            .content(content)
            .notificationType(type)
            .timestamp(System.currentTimeMillis())
            .build();

        boolean sent = connectionManager.sendToUser(userId, notification);

        // 如果WebSocket发送失败，使用推送通知
        if (!sent) {
            pushNotificationService.sendPushNotification(userId, title, content);
        }
    }

    // 紧急广播
    public void emergencyBroadcast(String message, EmergencyLevel level) {
        EmergencyBroadcast broadcast = EmergencyBroadcast.builder()
            .type(MessageType.EMERGENCY_BROADCAST)
            .level(level)
            .message(message)
            .timestamp(System.currentTimeMillis())
            .build();

        // 广播给所有在线用户
        connectionManager.broadcastToAll(broadcast);

        // 记录紧急广播
        emergencyLogService.logEmergencyBroadcast(broadcast);
    }
}
```

### 8.3 推送通知系统

```java
@Service
public class PushNotificationService {

    @Autowired
    private ApnsService apnsService;

    @Autowired
    private FcmService fcmService;

    @Autowired
    private DeviceTokenService deviceTokenService;

    @Autowired
    private NotificationTemplateService templateService;

    // 发送推送通知
    public void sendPushNotification(String userId, String title, String content) {
        try {
            List<DeviceToken> tokens = deviceTokenService.getUserDeviceTokens(userId);

            for (DeviceToken token : tokens) {
                switch (token.getPlatform()) {
                    case IOS:
                        sendApnsNotification(token, title, content);
                        break;
                    case ANDROID:
                        sendFcmNotification(token, title, content);
                        break;
                }
            }

            // 记录推送日志
            logPushNotification(userId, title, content, tokens.size());

        } catch (Exception e) {
            log.error("Failed to send push notification to user: " + userId, e);
        }
    }

    // 发送订单相关推送
    public void sendOrderNotification(String userId, Order order, OrderNotificationType notificationType) {
        NotificationTemplate template = templateService.getTemplate(notificationType);

        Map<String, String> variables = Map.of(
            "orderId", order.getId(),
            "driverName", order.getDriverName(),
            "pickupAddress", order.getPickupAddress(),
            "destinationAddress", order.getDestinationAddress(),
            "estimatedPrice", String.format("%.2f", order.getEstimatedPrice())
        );

        String title = templateService.render(template.getTitle(), variables);
        String content = templateService.render(template.getContent(), variables);

        sendPushNotification(userId, title, content);
    }

    // 批量推送
    public void sendBatchNotification(List<String> userIds, String title, String content) {
        // 按设备平台分组
        Map<Platform, List<DeviceToken>> tokensByPlatform = new HashMap<>();

        for (String userId : userIds) {
            List<DeviceToken> tokens = deviceTokenService.getUserDeviceTokens(userId);
            for (DeviceToken token : tokens) {
                tokensByPlatform.computeIfAbsent(token.getPlatform(), k -> new ArrayList<>())
                              .add(token);
            }
        }

        // 分平台批量发送
        for (Map.Entry<Platform, List<DeviceToken>> entry : tokensByPlatform.entrySet()) {
            switch (entry.getKey()) {
                case IOS:
                    sendBatchApnsNotification(entry.getValue(), title, content);
                    break;
                case ANDROID:
                    sendBatchFcmNotification(entry.getValue(), title, content);
                    break;
            }
        }
    }

    private void sendApnsNotification(DeviceToken token, String title, String content) {
        try {
            ApnsPayloadBuilder payloadBuilder = new ApnsPayloadBuilder();
            payloadBuilder.setAlertTitle(title);
            payloadBuilder.setAlertBody(content);
            payloadBuilder.setSoundFileName("default");
            payloadBuilder.setBadgeNumber(1);

            SimpleApnsPushNotification pushNotification = new SimpleApnsPushNotification(
                token.getToken(),
                "com.rideapp.mobile",
                payloadBuilder.build()
            );

            PushNotificationResponse<SimpleApnsPushNotification> response =
                apnsService.sendNotification(pushNotification).get();

            if (!response.isAccepted()) {
                log.warn("APNS notification rejected: " + response.getRejectionReason());

                // 处理无效token
                if (response.getRejectionReason() == RejectionReason.INVALID_TOKEN) {
                    deviceTokenService.markTokenAsInvalid(token.getToken());
                }
            }

        } catch (Exception e) {
            log.error("Failed to send APNS notification", e);
        }
    }

    private void sendFcmNotification(DeviceToken token, String title, String content) {
        try {
            Message message = Message.builder()
                .setToken(token.getToken())
                .setNotification(Notification.builder()
                    .setTitle(title)
                    .setBody(content)
                    .build())
                .setAndroidConfig(AndroidConfig.builder()
                    .setNotification(AndroidNotification.builder()
                        .setSound("default")
                        .setChannelId("ride_notifications")
                        .build())
                    .build())
                .build();

            String response = fcmService.send(message);
            log.debug("FCM notification sent successfully: " + response);

        } catch (FirebaseMessagingException e) {
            log.error("Failed to send FCM notification", e);

            // 处理无效token
            if (e.getErrorCode().equals("UNREGISTERED")) {
                deviceTokenService.markTokenAsInvalid(token.getToken());
            }
        }
    }

    // 地理位置定向推送
    public void sendLocationBasedNotification(GeoPoint center, double radius, String title, String content) {
        // 获取范围内的用户
        List<String> userIds = locationService.getUsersInRange(center, radius);

        // 分批发送推送
        int batchSize = 100;
        for (int i = 0; i < userIds.size(); i += batchSize) {
            List<String> batch = userIds.subList(i, Math.min(i + batchSize, userIds.size()));
            sendBatchNotification(batch, title, content);
        }
    }
}

// 推送通知模板服务
@Service
public class NotificationTemplateService {

    private final Map<OrderNotificationType, NotificationTemplate> templates = Map.of(
        OrderNotificationType.DRIVER_ASSIGNED, NotificationTemplate.builder()
            .title("司机已接单")
            .content("司机${driverName}已接受您的订单，正在前往接客点")
            .build(),

        OrderNotificationType.DRIVER_ARRIVING, NotificationTemplate.builder()
            .title("司机即将到达")
            .content("司机${driverName}即将到达接客点，请准备上车")
            .build(),

        OrderNotificationType.TRIP_STARTED, NotificationTemplate.builder()
            .title("行程开始")
            .content("司机已确认接到您，行程开始")
            .build(),

        OrderNotificationType.TRIP_COMPLETED, NotificationTemplate.builder()
            .title("行程结束")
            .content("您的行程已结束，费用为￥${estimatedPrice}")
            .build()
    );

    public NotificationTemplate getTemplate(OrderNotificationType type) {
        return templates.get(type);
    }

    public String render(String template, Map<String, String> variables) {
        String result = template;
        for (Map.Entry<String, String> entry : variables.entrySet()) {
            result = result.replace("${" + entry.getKey() + "}", entry.getValue());
        }
        return result;
    }
}

// 设备Token管理服务
@Service
public class DeviceTokenService {

    @Autowired
    private DeviceTokenRepository deviceTokenRepository;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    public void registerDeviceToken(String userId, String token, Platform platform, String appVersion) {
        DeviceToken deviceToken = DeviceToken.builder()
            .userId(userId)
            .token(token)
            .platform(platform)
            .appVersion(appVersion)
            .isActive(true)
            .registeredAt(LocalDateTime.now())
            .lastUsedAt(LocalDateTime.now())
            .build();

        deviceTokenRepository.save(deviceToken);

        // 缓存用户的设备Token
        cacheUserTokens(userId);

        log.info("Device token registered for user: {} ({})", userId, platform);
    }

    public List<DeviceToken> getUserDeviceTokens(String userId) {
        String cacheKey = "user_tokens:" + userId;

        @SuppressWarnings("unchecked")
        List<DeviceToken> cached = (List<DeviceToken>) redisTemplate.opsForValue().get(cacheKey);

        if (cached != null) {
            return cached;
        }

        List<DeviceToken> tokens = deviceTokenRepository.findByUserIdAndIsActiveTrue(userId);

        // 缓存结果
        redisTemplate.opsForValue().set(cacheKey, tokens, Duration.ofMinutes(30));

        return tokens;
    }

    public void markTokenAsInvalid(String token) {
        deviceTokenRepository.updateTokenStatus(token, false);

        // 清理相关缓存
        DeviceToken deviceToken = deviceTokenRepository.findByToken(token);
        if (deviceToken != null) {
            redisTemplate.delete("user_tokens:" + deviceToken.getUserId());
        }
    }

    private void cacheUserTokens(String userId) {
        List<DeviceToken> tokens = deviceTokenRepository.findByUserIdAndIsActiveTrue(userId);
        redisTemplate.opsForValue().set("user_tokens:" + userId, tokens, Duration.ofMinutes(30));
    }
}
```

### 8.4 集群消息同步

```java
// Redis消息监听器
@Component
public class ClusterMessageListener {

    @Autowired
    private WebSocketConnectionManager connectionManager;

    @RedisStreamListener
    public void handleClusterMessage(ClusterMessage message) {
        try {
            // 检查消息是否发送给当前服务器
            if (message.getTargetServerId().equals(getServerId())) {
                connectionManager.sendToUser(message.getTargetUserId(), message.getMessage());
            }
        } catch (Exception e) {
            log.error("Failed to handle cluster message", e);
        }
    }

    @RedisStreamListener
    public void handleBroadcastMessage(BroadcastMessage message) {
        try {
            switch (message.getType()) {
                case ALL_USERS:
                    connectionManager.broadcastToAll(message.getContent());
                    break;
                case DRIVERS_ONLY:
                    connectionManager.broadcastToDrivers(message.getContent());
                    break;
                case PASSENGERS_ONLY:
                    connectionManager.broadcastToPassengers(message.getContent());
                    break;
                case LOCATION_BASED:
                    connectionManager.broadcastToLocation(
                        message.getContent(),
                        message.getLocation(),
                        message.getRadius()
                    );
                    break;
            }
        } catch (Exception e) {
            log.error("Failed to handle broadcast message", e);
        }
    }

    private String getServerId() {
        return System.getProperty("server.id", InetAddress.getLocalHost().getHostName());
    }
}

// 消息可靠性保证
@Service
public class MessageReliabilityService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private MessageRetryService retryService;

    // 消息确认机制
    public void sendReliableMessage(String userId, ReliableMessage message) {
        String messageId = UUID.randomUUID().toString();
        message.setMessageId(messageId);

        // 存储消息用于重试
        storeMessageForRetry(messageId, userId, message);

        // 发送消息
        boolean sent = connectionManager.sendToUser(userId, message);

        if (sent) {
            // 设置确认超时
            scheduleAckTimeout(messageId, userId, message);
        } else {
            // 立即重试
            retryService.scheduleRetry(messageId, userId, message);
        }
    }

    public void handleMessageAck(String messageId) {
        // 清理重试记录
        redisTemplate.delete("message_retry:" + messageId);
        redisTemplate.delete("message_ack_timeout:" + messageId);
    }

    private void storeMessageForRetry(String messageId, String userId, ReliableMessage message) {
        MessageRetryInfo retryInfo = MessageRetryInfo.builder()
            .messageId(messageId)
            .userId(userId)
            .message(message)
            .attempts(0)
            .maxAttempts(3)
            .nextRetryAt(LocalDateTime.now().plusSeconds(30))
            .build();

        redisTemplate.opsForValue().set(
            "message_retry:" + messageId,
            retryInfo,
            Duration.ofHours(1)
        );
    }

    private void scheduleAckTimeout(String messageId, String userId, ReliableMessage message) {
        // 30秒后检查是否收到确认
        redisTemplate.opsForValue().set(
            "message_ack_timeout:" + messageId,
            AckTimeoutInfo.builder()
                .messageId(messageId)
                .userId(userId)
                .message(message)
                .sentAt(LocalDateTime.now())
                .build(),
            Duration.ofSeconds(30)
        );
    }

    @Scheduled(fixedDelay = 10000) // 每10秒检查一次
    public void processRetries() {
        Set<String> retryKeys = redisTemplate.keys("message_retry:*");

        for (String key : retryKeys) {
            MessageRetryInfo retryInfo = (MessageRetryInfo) redisTemplate.opsForValue().get(key);

            if (retryInfo != null && retryInfo.getNextRetryAt().isBefore(LocalDateTime.now())) {
                if (retryInfo.getAttempts() < retryInfo.getMaxAttempts()) {
                    // 重试发送
                    boolean sent = connectionManager.sendToUser(retryInfo.getUserId(), retryInfo.getMessage());

                    if (sent) {
                        retryInfo.setAttempts(retryInfo.getAttempts() + 1);
                        retryInfo.setNextRetryAt(LocalDateTime.now().plusSeconds(30 * retryInfo.getAttempts()));
                        redisTemplate.opsForValue().set(key, retryInfo, Duration.ofHours(1));
                    }
                } else {
                    // 超过最大重试次数，记录失败
                    log.warn("Message delivery failed after {} attempts: {}",
                            retryInfo.getMaxAttempts(), retryInfo.getMessageId());
                    redisTemplate.delete(key);
                }
            }
        }
    }

    @Scheduled(fixedDelay = 15000) // 每15秒检查一次
    public void processAckTimeouts() {
        Set<String> timeoutKeys = redisTemplate.keys("message_ack_timeout:*");

        for (String key : timeoutKeys) {
            AckTimeoutInfo timeoutInfo = (AckTimeoutInfo) redisTemplate.opsForValue().get(key);

            if (timeoutInfo != null) {
                // 触发重试机制
                retryService.scheduleRetry(
                    timeoutInfo.getMessageId(),
                    timeoutInfo.getUserId(),
                    timeoutInfo.getMessage()
                );

                redisTemplate.delete(key);
            }
        }
    }
}
```

## 9. 性能优化与扩展性

### 9.1 缓存策略优化

```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration());

        // 为不同类型的数据设置不同的缓存策略
        Map<String, RedisCacheConfiguration> cacheConfigurations = Map.of(
            "drivers", locationCacheConfig(Duration.ofSeconds(30)),      // 司机位置缓存30秒
            "orders", orderCacheConfig(Duration.ofMinutes(10)),          // 订单缓存10分钟
            "pricing", pricingCacheConfig(Duration.ofMinutes(5)),        // 价格缓存5分钟
            "routes", routeCacheConfig(Duration.ofHours(1)),             // 路径缓存1小时
            "users", userCacheConfig(Duration.ofMinutes(30))             // 用户信息缓存30分钟
        );

        return builder.withInitialCacheConfigurations(cacheConfigurations).build();
    }

    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
}

// 多层缓存策略
@Service
public class MultiLevelCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private final LoadingCache<String, Object> localCache;

    public MultiLevelCacheService() {
        this.localCache = Caffeine.newBuilder()
            .maximumSize(10_000)
            .expireAfterWrite(Duration.ofMinutes(5))
            .recordStats()
            .build(key -> loadFromRedis(key));
    }

    // 三级缓存获取数据
    public <T> T getWithMultiLevelCache(String key, Class<T> type, Supplier<T> dataLoader) {
        try {
            // L1: 本地缓存
            @SuppressWarnings("unchecked")
            T cached = (T) localCache.get(key);
            if (cached != null) {
                return cached;
            }

            // L2: Redis缓存
            Object redisValue = redisTemplate.opsForValue().get(key);
            if (redisValue != null) {
                @SuppressWarnings("unchecked")
                T value = (T) redisValue;
                localCache.put(key, value);
                return value;
            }

            // L3: 数据源
            T data = dataLoader.get();
            if (data != null) {
                // 写入Redis和本地缓存
                redisTemplate.opsForValue().set(key, data, Duration.ofMinutes(10));
                localCache.put(key, data);
            }

            return data;

        } catch (Exception e) {
            log.error("Error in multi-level cache for key: " + key, e);
            return dataLoader.get();
        }
    }

    // 缓存预热
    @EventListener
    @Async
    public void preloadCache(ApplicationReadyEvent event) {
        log.info("Starting cache preload...");

        // 预加载热点数据
        preloadHotDrivers();
        preloadPopularRoutes();
        preloadPricingRules();

        log.info("Cache preload completed");
    }

    private void preloadHotDrivers() {
        // 预加载活跃司机的位置信息
        List<String> activeDrivers = driverService.getActiveDriverIds();

        for (String driverId : activeDrivers) {
            try {
                LocationData location = locationService.getDriverLocation(driverId);
                String key = "driver_location:" + driverId;
                redisTemplate.opsForValue().set(key, location, Duration.ofMinutes(5));
            } catch (Exception e) {
                log.warn("Failed to preload driver location: " + driverId);
            }
        }
    }

    private void preloadPopularRoutes() {
        // 预加载热门路线
        List<RoutePattern> popularRoutes = routeAnalyzer.getPopularRoutes(24); // 过去24小时

        for (RoutePattern pattern : popularRoutes) {
            try {
                RouteResult route = routeService.calculateRoute(pattern.toRouteRequest());
                String key = "route:" + pattern.getRouteId();
                redisTemplate.opsForValue().set(key, route, Duration.ofHours(2));
            } catch (Exception e) {
                log.warn("Failed to preload route: " + pattern.getRouteId());
            }
        }
    }
}

// 缓存穿透和雪崩防护
@Component
public class CacheProtectionService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private final BloomFilter<String> bloomFilter;

    public CacheProtectionService() {
        // 布隆过滤器防缓存穿透
        this.bloomFilter = BloomFilter.create(
            Funnels.stringFunnel(Charset.defaultCharset()),
            1_000_000, // 预期插入100万个元素
            0.001      // 误报率0.1%
        );

        // 初始化布隆过滤器
        initializeBloomFilter();
    }

    // 防缓存穿透
    public <T> T getWithBloomFilter(String key, Class<T> type, Supplier<T> dataLoader) {
        // 先检查布隆过滤器
        if (!bloomFilter.mightContain(key)) {
            return null; // 数据肯定不存在
        }

        // 检查缓存
        Object cached = redisTemplate.opsForValue().get(key);
        if (cached != null) {
            if (cached.equals("NULL")) {
                return null; // 空值缓存
            }
            @SuppressWarnings("unchecked")
            T value = (T) cached;
            return value;
        }

        // 加载数据
        T data = dataLoader.get();

        if (data != null) {
            // 添加随机过期时间防雪崩
            Duration ttl = Duration.ofMinutes(10 + ThreadLocalRandom.current().nextInt(5));
            redisTemplate.opsForValue().set(key, data, ttl);
        } else {
            // 缓存空值防穿透
            redisTemplate.opsForValue().set(key, "NULL", Duration.ofMinutes(1));
        }

        return data;
    }

    // 分布式锁防热点数据缓存击穿
    public <T> T getWithDistributedLock(String key, Class<T> type, Supplier<T> dataLoader) {
        Object cached = redisTemplate.opsForValue().get(key);
        if (cached != null) {
            @SuppressWarnings("unchecked")
            T value = (T) cached;
            return value;
        }

        String lockKey = "lock:" + key;
        String lockValue = UUID.randomUUID().toString();

        try {
            // 尝试获取分布式锁
            Boolean acquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(30));

            if (Boolean.TRUE.equals(acquired)) {
                // 获得锁，加载数据
                T data = dataLoader.get();
                if (data != null) {
                    redisTemplate.opsForValue().set(key, data, Duration.ofMinutes(10));
                }
                return data;
            } else {
                // 未获得锁，等待后重试
                Thread.sleep(100);
                return getWithDistributedLock(key, type, dataLoader);
            }

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return dataLoader.get();
        } finally {
            // 释放锁
            releaseLock(lockKey, lockValue);
        }
    }
}
```

### 9.2 数据库分片策略

```java
@Configuration
public class ShardingConfig {

    @Bean
    public DataSource dataSource() {
        ShardingRuleConfiguration shardingRule = new ShardingRuleConfiguration();

        // 订单表分片规则
        shardingRule.getTableRuleConfigs().add(orderTableRule());

        // 司机位置表分片规则
        shardingRule.getTableRuleConfigs().add(driverLocationTableRule());

        // 用户表分片规则
        shardingRule.getTableRuleConfigs().add(userTableRule());

        // 分库策略
        shardingRule.setDefaultDatabaseShardingStrategyConfig(
            new StandardShardingStrategyConfiguration("user_id", new DatabaseShardingAlgorithm())
        );

        Map<String, DataSource> dataSourceMap = createDataSourceMap();

        return ShardingDataSourceFactory.createDataSource(dataSourceMap, shardingRule, new Properties());
    }

    private TableRuleConfiguration orderTableRule() {
        TableRuleConfiguration config = new TableRuleConfiguration("orders");

        // 分表策略: 按订单创建时间分表，每月一个表
        config.setActualDataNodes("ds${0..3}.orders_${202401..202412}");

        // 分表策略
        config.setTableShardingStrategyConfig(
            new StandardShardingStrategyConfiguration("created_date", new OrderTableShardingAlgorithm())
        );

        // 分库策略
        config.setDatabaseShardingStrategyConfig(
            new StandardShardingStrategyConfiguration("user_id", new DatabaseShardingAlgorithm())
        );

        return config;
    }

    private TableRuleConfiguration driverLocationTableRule() {
        TableRuleConfiguration config = new TableRuleConfiguration("driver_locations");

        // 按司机ID哈希分表
        config.setActualDataNodes("ds${0..3}.driver_locations_${0..15}");

        config.setTableShardingStrategyConfig(
            new StandardShardingStrategyConfiguration("driver_id", new HashShardingAlgorithm())
        );

        return config;
    }
}

// 订单表分片算法
public class OrderTableShardingAlgorithm implements PreciseShardingAlgorithm<Date> {

    @Override
    public String doSharding(Collection<String> availableTargetNames, PreciseShardingValue<Date> shardingValue) {
        Date createDate = shardingValue.getValue();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(createDate);

        int year = calendar.get(Calendar.YEAR);
        int month = calendar.get(Calendar.MONTH) + 1;

        String tableSuffix = String.format("%04d%02d", year, month);
        String targetTable = "orders_" + tableSuffix;

        // 确保目标表存在于可用表列表中
        return availableTargetNames.stream()
            .filter(name -> name.endsWith(targetTable))
            .findFirst()
            .orElse(availableTargetNames.iterator().next());
    }
}

// 数据库分片算法
public class DatabaseShardingAlgorithm implements PreciseShardingAlgorithm<String> {

    @Override
    public String doSharding(Collection<String> availableTargetNames, PreciseShardingValue<String> shardingValue) {
        String userId = shardingValue.getValue();

        // 使用用户ID的哈希值决定分库
        int hash = Math.abs(userId.hashCode());
        int dbIndex = hash % availableTargetNames.size();

        String targetDb = "ds" + dbIndex;

        return availableTargetNames.stream()
            .filter(name -> name.equals(targetDb))
            .findFirst()
            .orElse(availableTargetNames.iterator().next());
    }
}

// 读写分离配置
@Configuration
public class ReadWriteSplitConfig {

    @Bean
    @Primary
    public DataSource readWriteSplitDataSource() {
        Map<String, DataSource> dataSourceMap = new HashMap<>();

        // 主库 - 写库
        dataSourceMap.put("master", masterDataSource());

        // 从库 - 读库
        dataSourceMap.put("slave0", slaveDataSource0());
        dataSourceMap.put("slave1", slaveDataSource1());

        // 读写分离规则
        ReadwriteSplittingRuleConfiguration ruleConfig = new ReadwriteSplittingRuleConfiguration();
        ruleConfig.getDataSources().put("readwrite_ds",
            new ReadwriteSplittingDataSourceRuleConfiguration(
                "readwrite_ds",
                "",  // 自动发现主库
                Arrays.asList("slave0", "slave1"),
                new RandomReplicaLoadBalanceAlgorithm()
            )
        );

        return ReadwriteSplittingDataSourceFactory.createDataSource(dataSourceMap, ruleConfig, new Properties());
    }

    // 动态数据源切换
    @Bean
    public DataSourceTransactionManager transactionManager() {
        return new DataSourceTransactionManager(readWriteSplitDataSource());
    }
}

// 数据归档策略
@Service
public class DataArchiveService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private ArchiveStorageService archiveStorage;

    // 归档历史订单数据
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void archiveHistoricalOrders() {
        LocalDate cutoffDate = LocalDate.now().minusMonths(6); // 6个月前的数据

        try {
            // 查询需要归档的数据
            List<Order> ordersToArchive = jdbcTemplate.query(
                "SELECT * FROM orders WHERE created_date < ? AND status IN ('COMPLETED', 'CANCELLED')",
                new Object[]{cutoffDate},
                new OrderRowMapper()
            );

            if (!ordersToArchive.isEmpty()) {
                // 归档到冷存储
                archiveStorage.archiveOrders(ordersToArchive);

                // 删除原始数据
                jdbcTemplate.update(
                    "DELETE FROM orders WHERE created_date < ? AND status IN ('COMPLETED', 'CANCELLED')",
                    cutoffDate
                );

                log.info("Archived {} orders older than {}", ordersToArchive.size(), cutoffDate);
            }

        } catch (Exception e) {
            log.error("Failed to archive historical orders", e);
        }
    }

    // 分批归档以避免长时间锁表
    private void batchArchive(List<Order> orders) {
        int batchSize = 1000;

        for (int i = 0; i < orders.size(); i += batchSize) {
            List<Order> batch = orders.subList(i, Math.min(i + batchSize, orders.size()));

            try {
                // 在事务中处理批次
                TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
                transactionTemplate.execute(status -> {
                    archiveStorage.archiveOrders(batch);

                    List<String> orderIds = batch.stream()
                        .map(Order::getId)
                        .collect(Collectors.toList());

                    jdbcTemplate.update(
                        "DELETE FROM orders WHERE id IN (" +
                        orderIds.stream().map(id -> "?").collect(Collectors.joining(",")) + ")",
                        orderIds.toArray()
                    );

                    return null;
                });

                // 短暂休眠以减少系统压力
                Thread.sleep(100);

            } catch (Exception e) {
                log.error("Failed to archive batch starting at index " + i, e);
            }
        }
    }
}
```

### 9.3 微服务拆分与治理

```java
// 服务网关配置
@Configuration
@EnableZuulProxy
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-service", r -> r.path("/api/users/**")
                .filters(f -> f.circuitBreaker(c -> c.setName("user-service-cb")
                                               .setFallbackUri("forward:/fallback/user"))
                           .requestRateLimiter(rl -> rl.setRateLimiter(redisRateLimiter())
                                                      .setKeyResolver(userKeyResolver())))
                .uri("lb://user-service"))

            .route("order-service", r -> r.path("/api/orders/**")
                .filters(f -> f.circuitBreaker(c -> c.setName("order-service-cb")
                                               .setFallbackUri("forward:/fallback/order"))
                           .requestRateLimiter(rl -> rl.setRateLimiter(redisRateLimiter())
                                                      .setKeyResolver(userKeyResolver())))
                .uri("lb://order-service"))

            .route("location-service", r -> r.path("/api/locations/**")
                .filters(f -> f.circuitBreaker(c -> c.setName("location-service-cb")
                                               .setFallbackUri("forward:/fallback/location"))
                           .requestRateLimiter(rl -> rl.setRateLimiter(redisRateLimiter())
                                                      .setKeyResolver(userKeyResolver())))
                .uri("lb://location-service"))

            .route("payment-service", r -> r.path("/api/payments/**")
                .filters(f -> f.circuitBreaker(c -> c.setName("payment-service-cb")
                                               .setFallbackUri("forward:/fallback/payment"))
                           .requestRateLimiter(rl -> rl.setRateLimiter(redisRateLimiter())
                                                      .setKeyResolver(userKeyResolver())))
                .uri("lb://payment-service"))
            .build();
    }

    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(100, 200); // 每秒100个请求，突发200个
    }

    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -> exchange.getRequest().getHeaders().getFirst("userId");
    }
}

// 服务熔断器
@Component
public class ServiceCircuitBreaker {

    private final CircuitBreakerRegistry circuitBreakerRegistry;

    public ServiceCircuitBreaker() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)                    // 失败率阈值50%
            .waitDurationInOpenState(Duration.ofSeconds(30))  // 熔断器打开30秒后尝试半开
            .slidingWindowSize(10)                       // 滑动窗口大小10个请求
            .minimumNumberOfCalls(5)                     // 最小调用次数5次
            .permittedNumberOfCallsInHalfOpenState(3)    // 半开状态允许3次调用
            .automaticTransitionFromOpenToHalfOpenEnabled(true)
            .build();

        this.circuitBreakerRegistry = CircuitBreakerRegistry.of(config);
    }

    public <T> T executeWithCircuitBreaker(String serviceName, Supplier<T> operation, Supplier<T> fallback) {
        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(serviceName);

        return circuitBreaker.executeSupplier(operation);
    }

    @EventListener
    public void handleCircuitBreakerEvent(CircuitBreakerOnStateTransitionEvent event) {
        log.info("Circuit breaker {} transitioned from {} to {}",
                event.getCircuitBreakerName(),
                event.getStateTransition().getFromState(),
                event.getStateTransition().getToState());

        // 发送告警
        if (event.getStateTransition().getToState() == CircuitBreaker.State.OPEN) {
            alertService.sendAlert(
                AlertType.CIRCUIT_BREAKER_OPEN,
                "Circuit breaker opened for service: " + event.getCircuitBreakerName()
            );
        }
    }
}

// 分布式事务管理
@Service
public class DistributedTransactionService {

    @Autowired
    private OrderService orderService;

    @Autowired
    private PaymentService paymentService;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private SagaManager sagaManager;

    // 使用Saga模式处理分布式事务
    @SagaOrchestrationStart
    public void processRidePayment(String orderId, PaymentRequest paymentRequest) {
        SagaTransaction saga = SagaTransaction.builder()
            .sagaId(UUID.randomUUID().toString())
            .orderId(orderId)
            .build();

        try {
            // 步骤1: 创建支付记录
            PaymentResult paymentResult = sagaManager.executeStep(
                saga,
                "create-payment",
                () -> paymentService.createPayment(paymentRequest),
                () -> paymentService.cancelPayment(paymentRequest.getPaymentId())
            );

            // 步骤2: 更新订单状态
            sagaManager.executeStep(
                saga,
                "update-order",
                () -> orderService.updatePaymentStatus(orderId, PaymentStatus.PROCESSING),
                () -> orderService.updatePaymentStatus(orderId, PaymentStatus.FAILED)
            );

            // 步骤3: 处理支付
            sagaManager.executeStep(
                saga,
                "process-payment",
                () -> paymentService.processPayment(paymentResult.getTransactionId()),
                () -> paymentService.refundPayment(paymentResult.getTransactionId())
            );

            // 步骤4: 确认订单完成
            sagaManager.executeStep(
                saga,
                "complete-order",
                () -> orderService.completeOrder(orderId),
                () -> orderService.cancelOrder(orderId, "Payment processing failed")
            );

            // 步骤5: 发送通知
            sagaManager.executeStep(
                saga,
                "send-notification",
                () -> notificationService.sendPaymentSuccessNotification(orderId),
                () -> {} // 通知失败不需要回滚
            );

            sagaManager.completeSaga(saga);

        } catch (Exception e) {
            log.error("Saga transaction failed for order: " + orderId, e);
            sagaManager.compensateSaga(saga);
        }
    }
}

// 服务监控
@Component
public class ServiceMonitor {

    private final MeterRegistry meterRegistry;
    private final Timer.Sample sample;

    public ServiceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.sample = Timer.start(meterRegistry);
    }

    // 方法调用监控
    @Around("@annotation(Monitored)")
    public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        Timer.Sample sample = Timer.start(meterRegistry);

        try {
            Object result = joinPoint.proceed();

            // 记录成功指标
            meterRegistry.counter("method.calls",
                    "class", className,
                    "method", methodName,
                    "status", "success")
                .increment();

            return result;

        } catch (Exception e) {
            // 记录失败指标
            meterRegistry.counter("method.calls",
                    "class", className,
                    "method", methodName,
                    "status", "error",
                    "exception", e.getClass().getSimpleName())
                .increment();

            throw e;

        } finally {
            // 记录执行时间
            sample.stop(Timer.builder("method.duration")
                    .tag("class", className)
                    .tag("method", methodName)
                    .register(meterRegistry));
        }
    }

    // 自定义业务指标
    @EventListener
    public void recordOrderMetrics(OrderStateTransitionEvent event) {
        meterRegistry.counter("orders.state.transitions",
                "from", event.getPreviousStatus().name(),
                "to", event.getNewStatus().name())
            .increment();

        if (event.getNewStatus() == OrderStatus.COMPLETED) {
            Timer.Sample orderProcessingTime = Timer.start(meterRegistry);
            Duration processingDuration = Duration.between(
                event.getOrder().getCreatedTime(),
                LocalDateTime.now()
            );

            meterRegistry.timer("orders.processing.duration")
                .record(processingDuration);
        }
    }

    // 系统健康检查
    @Component
    public class HealthIndicators {

        @Autowired
        private DataSource dataSource;

        @Autowired
        private RedisTemplate<String, Object> redisTemplate;

        @Bean
        public HealthIndicator databaseHealthIndicator() {
            return () -> {
                try {
                    Connection connection = dataSource.getConnection();
                    PreparedStatement statement = connection.prepareStatement("SELECT 1");
                    ResultSet resultSet = statement.executeQuery();

                    if (resultSet.next()) {
                        return Health.up()
                            .withDetail("database", "Available")
                            .build();
                    } else {
                        return Health.down()
                            .withDetail("database", "Query failed")
                            .build();
                    }

                } catch (SQLException e) {
                    return Health.down()
                        .withDetail("database", "Connection failed")
                        .withException(e)
                        .build();
                }
            };
        }

        @Bean
        public HealthIndicator redisHealthIndicator() {
            return () -> {
                try {
                    redisTemplate.opsForValue().get("health_check");
                    return Health.up()
                        .withDetail("redis", "Available")
                        .build();

                } catch (Exception e) {
                    return Health.down()
                        .withDetail("redis", "Connection failed")
                        .withException(e)
                        .build();
                }
            };
        }
    }
}
```

### 9.4 容器化部署与自动扩缩容

```yaml
# Kubernetes部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ride-service
  labels:
    app: ride-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ride-service
  template:
    metadata:
      labels:
        app: ride-service
    spec:
      containers:
      - name: ride-service
        image: ride-app/ride-service:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: ride-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: ride-secrets
              key: redis-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10

---
apiVersion: v1
kind: Service
metadata:
  name: ride-service
spec:
  selector:
    app: ride-service
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP

---
# 水平自动扩缩容配置
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: ride-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: ride-service
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60

---
# Redis集群配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-config
data:
  redis.conf: |
    cluster-enabled yes
    cluster-require-full-coverage no
    cluster-node-timeout 15000
    cluster-config-file nodes.conf
    cluster-migration-barrier 1
    appendonly yes
    save 900 1
    save 300 10
    save 60 10000

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
spec:
  serviceName: redis-cluster
  replicas: 6
  selector:
    matchLabels:
      app: redis-cluster
  template:
    metadata:
      labels:
        app: redis-cluster
    spec:
      containers:
      - name: redis
        image: redis:7.0-alpine
        ports:
        - containerPort: 6379
        - containerPort: 16379
        command:
        - redis-server
        - /etc/redis/redis.conf
        volumeMounts:
        - name: redis-config
          mountPath: /etc/redis
        - name: redis-data
          mountPath: /data
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
      volumes:
      - name: redis-config
        configMap:
          name: redis-config
  volumeClaimTemplates:
  - metadata:
      name: redis-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 20Gi
```

```java
// 自定义扩缩容控制器
@Component
public class CustomAutoscaler {

    @Autowired
    private KubernetesClient kubernetesClient;

    @Autowired
    private MetricsService metricsService;

    @Scheduled(fixedDelay = 30000) // 每30秒检查一次
    public void checkAndScale() {
        try {
            // 获取当前系统负载指标
            SystemMetrics metrics = metricsService.getCurrentMetrics();

            // 根据业务指标决定扩缩容
            ScalingDecision decision = makeScalingDecision(metrics);

            if (decision.shouldScale()) {
                executeScaling(decision);
            }

        } catch (Exception e) {
            log.error("Error in custom autoscaler", e);
        }
    }

    private ScalingDecision makeScalingDecision(SystemMetrics metrics) {
        ScalingDecision.Builder builder = ScalingDecision.builder();

        // 基于队列长度扩缩容
        if (metrics.getOrderQueueLength() > 100) {
            builder.scaleUp("order-service", 2)
                   .reason("Order queue length exceeded threshold");
        }

        // 基于响应时间扩缩容
        if (metrics.getAverageResponseTime() > Duration.ofSeconds(2)) {
            builder.scaleUp("all-services", 1)
                   .reason("Response time degraded");
        }

        // 基于司机在线数量扩缩容位置服务
        if (metrics.getOnlineDriverCount() > 10000) {
            builder.scaleUp("location-service", 2)
                   .reason("High number of online drivers");
        }

        // 夜间缩容
        LocalTime now = LocalTime.now();
        if (now.isAfter(LocalTime.of(1, 0)) && now.isBefore(LocalTime.of(6, 0))) {
            if (metrics.getCurrentRequestRate() < 10) {
                builder.scaleDown("all-services", 1)
                       .reason("Low traffic during night hours");
            }
        }

        return builder.build();
    }

    private void executeScaling(ScalingDecision decision) {
        for (ScalingAction action : decision.getActions()) {
            try {
                Deployment deployment = kubernetesClient.apps().deployments()
                    .inNamespace("default")
                    .withName(action.getServiceName())
                    .get();

                if (deployment != null) {
                    int currentReplicas = deployment.getSpec().getReplicas();
                    int newReplicas = calculateNewReplicas(currentReplicas, action);

                    kubernetesClient.apps().deployments()
                        .inNamespace("default")
                        .withName(action.getServiceName())
                        .patch(new DeploymentBuilder()
                            .editSpec()
                            .withReplicas(newReplicas)
                            .endSpec()
                            .build());

                    log.info("Scaled {} from {} to {} replicas. Reason: {}",
                            action.getServiceName(),
                            currentReplicas,
                            newReplicas,
                            action.getReason());
                }

            } catch (Exception e) {
                log.error("Failed to scale service: " + action.getServiceName(), e);
            }
        }
    }
}
```