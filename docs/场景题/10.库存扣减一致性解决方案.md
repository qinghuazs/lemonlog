# 库存扣减一致性解决方案详解

## 1. 问题背景分析

### 1.1 核心问题

在高并发场景下，多个用户同时购买同一商品时，如何确保：
1. **不超卖**：实际销售数量不超过库存数量
2. **不少卖**：有库存时不能因为并发问题导致购买失败
3. **数据一致性**：库存数据在分布式环境下保持一致
4. **高性能**：在保证一致性的前提下尽可能提高性能

### 1.2 典型场景

```java
// 简化的库存扣减伪代码
public boolean deductStock(Long productId, Integer quantity) {
    // 1. 查询当前库存
    Integer currentStock = stockMapper.getStock(productId);

    // 2. 判断库存是否充足
    if (currentStock >= quantity) {
        // 3. 扣减库存
        Integer newStock = currentStock - quantity;
        stockMapper.updateStock(productId, newStock);
        return true;
    }

    return false;
}
```

**并发问题分析：**
- 线程A查询库存：100
- 线程B查询库存：100
- 线程A扣减：100-50=50
- 线程B扣减：100-30=70
- 结果：实际扣减了80，但库存显示70，出现超卖

## 2. 数据库层面解决方案

### 2.1 悲观锁方案

#### 2.1.1 FOR UPDATE 行锁

```java
@Service
@Transactional
public class PessimisticLockStockService {

    @Autowired
    private StockMapper stockMapper;

    /**
     * 使用悲观锁扣减库存
     */
    public boolean deductStock(Long productId, Integer quantity) {
        try {
            // 1. 使用FOR UPDATE锁定记录
            Stock stock = stockMapper.selectForUpdate(productId);

            if (stock == null) {
                throw new BusinessException("商品不存在");
            }

            // 2. 检查库存是否充足
            if (stock.getQuantity() < quantity) {
                log.warn("库存不足: productId={}, current={}, required={}",
                        productId, stock.getQuantity(), quantity);
                return false;
            }

            // 3. 扣减库存
            int updatedRows = stockMapper.deductStock(productId, quantity);

            if (updatedRows != 1) {
                throw new BusinessException("库存扣减失败");
            }

            log.info("库存扣减成功: productId={}, quantity={}, remaining={}",
                    productId, quantity, stock.getQuantity() - quantity);

            return true;

        } catch (Exception e) {
            log.error("库存扣减异常: productId={}, quantity={}", productId, quantity, e);
            throw new BusinessException("库存扣减失败", e);
        }
    }
}
```

```xml
<!-- MyBatis Mapper -->
<select id="selectForUpdate" resultType="Stock">
    SELECT id, product_id, quantity, version, update_time
    FROM stock
    WHERE product_id = #{productId}
    FOR UPDATE
</select>

<update id="deductStock">
    UPDATE stock
    SET quantity = quantity - #{quantity},
        update_time = NOW()
    WHERE product_id = #{productId}
    AND quantity >= #{quantity}
</update>
```

**优点：**
- 实现简单，容易理解
- 强一致性保证
- 不会出现超卖问题

**缺点：**
- 性能较差，并发度低
- 容易产生死锁
- 长时间持有锁影响系统吞吐量

### 2.2 乐观锁方案

#### 2.2.1 基于版本号的乐观锁

```java
@Service
public class OptimisticLockStockService {

    @Autowired
    private StockMapper stockMapper;

    private static final int MAX_RETRY_TIMES = 3;

    /**
     * 使用乐观锁扣减库存（带重试）
     */
    public boolean deductStock(Long productId, Integer quantity) {
        for (int i = 0; i < MAX_RETRY_TIMES; i++) {
            try {
                if (deductStockOnce(productId, quantity)) {
                    return true;
                }

                // 短暂等待后重试
                Thread.sleep(10 + i * 5);

            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("库存扣减异常: productId={}, quantity={}, retry={}",
                         productId, quantity, i, e);
            }
        }

        return false;
    }

    /**
     * 单次乐观锁尝试
     */
    private boolean deductStockOnce(Long productId, Integer quantity) {
        // 1. 查询当前库存和版本号
        Stock stock = stockMapper.selectByProductId(productId);

        if (stock == null) {
            throw new BusinessException("商品不存在");
        }

        // 2. 检查库存是否充足
        if (stock.getQuantity() < quantity) {
            log.warn("库存不足: productId={}, current={}, required={}",
                    productId, stock.getQuantity(), quantity);
            return false;
        }

        // 3. 使用版本号更新库存
        int updatedRows = stockMapper.deductStockWithVersion(
            productId, quantity, stock.getVersion()
        );

        if (updatedRows == 1) {
            log.info("库存扣减成功: productId={}, quantity={}, version={}",
                    productId, quantity, stock.getVersion());
            return true;
        } else {
            log.debug("乐观锁冲突，准备重试: productId={}, version={}",
                     productId, stock.getVersion());
            return false;
        }
    }
}
```

```xml
<!-- MyBatis Mapper -->
<select id="selectByProductId" resultType="Stock">
    SELECT id, product_id, quantity, version, update_time
    FROM stock
    WHERE product_id = #{productId}
</select>

<update id="deductStockWithVersion">
    UPDATE stock
    SET quantity = quantity - #{quantity},
        version = version + 1,
        update_time = NOW()
    WHERE product_id = #{productId}
    AND version = #{version}
    AND quantity >= #{quantity}
</update>
```

**优点：**
- 性能较好，支持高并发
- 不会产生死锁
- 适合读多写少的场景

**缺点：**
- 在高并发下重试次数较多
- 可能出现ABA问题
- 需要业务层处理重试逻辑

### 2.3 原子操作方案

#### 2.3.1 SQL原子更新

```java
@Service
public class AtomicStockService {

    @Autowired
    private StockMapper stockMapper;

    /**
     * 原子操作扣减库存
     */
    public boolean deductStock(Long productId, Integer quantity) {
        try {
            // 直接使用SQL原子操作扣减库存
            int updatedRows = stockMapper.atomicDeductStock(productId, quantity);

            if (updatedRows == 1) {
                log.info("库存扣减成功: productId={}, quantity={}", productId, quantity);
                return true;
            } else {
                log.warn("库存扣减失败: productId={}, quantity={}", productId, quantity);
                return false;
            }

        } catch (Exception e) {
            log.error("库存扣减异常: productId={}, quantity={}", productId, quantity, e);
            return false;
        }
    }

    /**
     * 查询当前库存
     */
    public Integer getCurrentStock(Long productId) {
        return stockMapper.getStock(productId);
    }

    /**
     * 批量扣减库存
     */
    @Transactional
    public boolean batchDeductStock(List<StockDeductRequest> requests) {
        try {
            for (StockDeductRequest request : requests) {
                int updatedRows = stockMapper.atomicDeductStock(
                    request.getProductId(), request.getQuantity()
                );

                if (updatedRows != 1) {
                    throw new BusinessException(
                        "商品库存不足: " + request.getProductId()
                    );
                }
            }

            return true;

        } catch (Exception e) {
            log.error("批量库存扣减失败", e);
            throw e;
        }
    }
}
```

```xml
<!-- 原子操作SQL -->
<update id="atomicDeductStock">
    UPDATE stock
    SET quantity = quantity - #{quantity},
        update_time = NOW()
    WHERE product_id = #{productId}
    AND quantity >= #{quantity}
</update>

<select id="getStock" resultType="java.lang.Integer">
    SELECT quantity
    FROM stock
    WHERE product_id = #{productId}
</select>
```

**优点：**
- 实现简单，代码量少
- 性能较好
- 天然防止超卖

**缺点：**
- 无法获知具体失败原因
- 难以实现复杂的业务逻辑
- 缺乏灵活性

## 3. 缓存层面解决方案

### 3.1 Redis Lua脚本方案

#### 3.1.1 Lua脚本实现原子操作

```lua
-- stock_deduct.lua
-- KEYS[1]: 库存key (stock:product:123)
-- ARGV[1]: 扣减数量
-- ARGV[2]: 过期时间（秒）

local stock_key = KEYS[1]
local deduct_quantity = tonumber(ARGV[1])
local expire_time = tonumber(ARGV[2])

-- 获取当前库存
local current_stock = redis.call('GET', stock_key)

if current_stock == false then
    -- 库存key不存在，返回错误码 -1
    return -1
end

current_stock = tonumber(current_stock)

-- 检查库存是否充足
if current_stock < deduct_quantity then
    -- 库存不足，返回当前库存
    return current_stock
end

-- 扣减库存
local new_stock = current_stock - deduct_quantity
redis.call('SET', stock_key, new_stock)

-- 设置过期时间
if expire_time > 0 then
    redis.call('EXPIRE', stock_key, expire_time)
end

-- 返回扣减后的库存
return new_stock
```

```java
@Service
public class RedisStockService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    private static final String STOCK_KEY_PREFIX = "stock:product:";
    private static final String LUA_SCRIPT = """
        local stock_key = KEYS[1]
        local deduct_quantity = tonumber(ARGV[1])
        local expire_time = tonumber(ARGV[2])

        local current_stock = redis.call('GET', stock_key)

        if current_stock == false then
            return -1
        end

        current_stock = tonumber(current_stock)

        if current_stock < deduct_quantity then
            return current_stock
        end

        local new_stock = current_stock - deduct_quantity
        redis.call('SET', stock_key, new_stock)

        if expire_time > 0 then
            redis.call('EXPIRE', stock_key, expire_time)
        end

        return new_stock
        """;

    private DefaultRedisScript<Long> deductScript;

    @PostConstruct
    public void init() {
        deductScript = new DefaultRedisScript<>();
        deductScript.setScriptText(LUA_SCRIPT);
        deductScript.setResultType(Long.class);
    }

    /**
     * Redis库存扣减
     */
    public StockDeductResult deductStock(Long productId, Integer quantity) {
        String stockKey = STOCK_KEY_PREFIX + productId;

        try {
            Long result = redisTemplate.execute(
                deductScript,
                Collections.singletonList(stockKey),
                quantity.toString(),
                "3600" // 1小时过期
            );

            if (result == null) {
                return StockDeductResult.error("Redis执行异常");
            }

            if (result == -1) {
                return StockDeductResult.error("库存数据不存在");
            }

            if (result < 0) {
                return StockDeductResult.insufficient(Math.abs(result.intValue()));
            }

            return StockDeductResult.success(result.intValue());

        } catch (Exception e) {
            log.error("Redis库存扣减异常: productId={}, quantity={}", productId, quantity, e);
            return StockDeductResult.error("系统异常");
        }
    }

    /**
     * 初始化库存到Redis
     */
    public void initStock(Long productId, Integer quantity) {
        String stockKey = STOCK_KEY_PREFIX + productId;
        redisTemplate.opsForValue().set(stockKey, quantity.toString(), Duration.ofHours(1));
    }

    /**
     * 获取当前库存
     */
    public Integer getCurrentStock(Long productId) {
        String stockKey = STOCK_KEY_PREFIX + productId;
        String stock = redisTemplate.opsForValue().get(stockKey);
        return stock != null ? Integer.parseInt(stock) : null;
    }

    /**
     * 补充库存
     */
    public boolean addStock(Long productId, Integer quantity) {
        String addStockScript = """
            local stock_key = KEYS[1]
            local add_quantity = tonumber(ARGV[1])

            local current_stock = redis.call('GET', stock_key)
            if current_stock == false then
                redis.call('SET', stock_key, add_quantity)
                return add_quantity
            end

            local new_stock = tonumber(current_stock) + add_quantity
            redis.call('SET', stock_key, new_stock)
            return new_stock
            """;

        DefaultRedisScript<Long> addScript = new DefaultRedisScript<>();
        addScript.setScriptText(addStockScript);
        addScript.setResultType(Long.class);

        String stockKey = STOCK_KEY_PREFIX + productId;
        Long result = redisTemplate.execute(
            addScript,
            Collections.singletonList(stockKey),
            quantity.toString()
        );

        return result != null && result >= 0;
    }
}

@Data
@Builder
@AllArgsConstructor
public class StockDeductResult {
    private boolean success;
    private Integer remainingStock;
    private String errorMessage;
    private StockDeductStatus status;

    public static StockDeductResult success(Integer remainingStock) {
        return StockDeductResult.builder()
                .success(true)
                .remainingStock(remainingStock)
                .status(StockDeductStatus.SUCCESS)
                .build();
    }

    public static StockDeductResult insufficient(Integer currentStock) {
        return StockDeductResult.builder()
                .success(false)
                .remainingStock(currentStock)
                .status(StockDeductStatus.INSUFFICIENT)
                .errorMessage("库存不足")
                .build();
    }

    public static StockDeductResult error(String message) {
        return StockDeductResult.builder()
                .success(false)
                .status(StockDeductStatus.ERROR)
                .errorMessage(message)
                .build();
    }
}

public enum StockDeductStatus {
    SUCCESS,      // 成功
    INSUFFICIENT, // 库存不足
    ERROR        // 系统错误
}
```

### 3.2 Redis分布式锁方案

#### 3.2.1 基于SET NX的分布式锁

```java
@Service
public class RedisDistributedLockStockService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    private static final String LOCK_KEY_PREFIX = "lock:stock:";
    private static final String STOCK_KEY_PREFIX = "stock:product:";
    private static final int LOCK_EXPIRE_TIME = 10; // 锁过期时间（秒）

    /**
     * 使用分布式锁保证库存扣减一致性
     */
    public StockDeductResult deductStockWithLock(Long productId, Integer quantity) {
        String lockKey = LOCK_KEY_PREFIX + productId;
        String lockValue = UUID.randomUUID().toString();

        try {
            // 1. 获取分布式锁
            if (!acquireLock(lockKey, lockValue, LOCK_EXPIRE_TIME)) {
                return StockDeductResult.error("获取锁失败，请稍后重试");
            }

            // 2. 执行库存扣减逻辑
            StockDeductResult result = doDeductStock(productId, quantity);

            return result;

        } finally {
            // 3. 释放锁
            releaseLock(lockKey, lockValue);
        }
    }

    /**
     * 获取分布式锁
     */
    private boolean acquireLock(String lockKey, String lockValue, int expireSeconds) {
        String script = """
            if redis.call('SET', KEYS[1], ARGV[1], 'NX', 'EX', ARGV[2]) then
                return 1
            else
                return 0
            end
            """;

        DefaultRedisScript<Long> lockScript = new DefaultRedisScript<>();
        lockScript.setScriptText(script);
        lockScript.setResultType(Long.class);

        Long result = redisTemplate.execute(
            lockScript,
            Collections.singletonList(lockKey),
            lockValue,
            String.valueOf(expireSeconds)
        );

        return result != null && result == 1;
    }

    /**
     * 释放分布式锁
     */
    private void releaseLock(String lockKey, String lockValue) {
        String script = """
            if redis.call('GET', KEYS[1]) == ARGV[1] then
                return redis.call('DEL', KEYS[1])
            else
                return 0
            end
            """;

        DefaultRedisScript<Long> unlockScript = new DefaultRedisScript<>();
        unlockScript.setScriptText(script);
        unlockScript.setResultType(Long.class);

        redisTemplate.execute(
            unlockScript,
            Collections.singletonList(lockKey),
            lockValue
        );
    }

    /**
     * 执行库存扣减
     */
    private StockDeductResult doDeductStock(Long productId, Integer quantity) {
        String stockKey = STOCK_KEY_PREFIX + productId;

        // 获取当前库存
        String currentStockStr = redisTemplate.opsForValue().get(stockKey);
        if (currentStockStr == null) {
            return StockDeductResult.error("库存数据不存在");
        }

        Integer currentStock = Integer.parseInt(currentStockStr);

        // 检查库存是否充足
        if (currentStock < quantity) {
            return StockDeductResult.insufficient(currentStock);
        }

        // 扣减库存
        Integer newStock = currentStock - quantity;
        redisTemplate.opsForValue().set(stockKey, newStock.toString());

        return StockDeductResult.success(newStock);
    }
}
```

## 4. 消息队列异步方案

### 4.1 基于RocketMQ的异步库存扣减

```java
@Service
public class AsyncStockService {

    @Autowired
    private RocketMQTemplate rocketMQTemplate;

    @Autowired
    private RedisStockService redisStockService;

    @Autowired
    private StockMapper stockMapper;

    /**
     * 异步库存扣减
     */
    public CompletableFuture<StockDeductResult> deductStockAsync(Long productId, Integer quantity, String orderId) {
        // 1. 先在Redis中预扣减
        StockDeductResult redisResult = redisStockService.deductStock(productId, quantity);

        if (!redisResult.isSuccess()) {
            return CompletableFuture.completedFuture(redisResult);
        }

        // 2. 发送消息到MQ进行数据库扣减
        StockDeductMessage message = StockDeductMessage.builder()
                .productId(productId)
                .quantity(quantity)
                .orderId(orderId)
                .timestamp(System.currentTimeMillis())
                .build();

        // 3. 异步发送消息
        return CompletableFuture.supplyAsync(() -> {
            try {
                SendResult sendResult = rocketMQTemplate.syncSend(
                    "stock-deduct-topic", message, 3000
                );

                if (sendResult.getSendStatus() == SendStatus.SEND_OK) {
                    return StockDeductResult.success(redisResult.getRemainingStock());
                } else {
                    // 发送失败，回滚Redis库存
                    redisStockService.addStock(productId, quantity);
                    return StockDeductResult.error("消息发送失败");
                }

            } catch (Exception e) {
                log.error("发送库存扣减消息失败", e);
                // 发送失败，回滚Redis库存
                redisStockService.addStock(productId, quantity);
                return StockDeductResult.error("系统异常");
            }
        });
    }
}

/**
 * 库存扣减消息消费者
 */
@Component
@RocketMQMessageListener(
    topic = "stock-deduct-topic",
    consumerGroup = "stock-deduct-consumer",
    selectorExpression = "*"
)
public class StockDeductMessageConsumer implements RocketMQListener<StockDeductMessage> {

    @Autowired
    private StockMapper stockMapper;

    @Autowired
    private RedisStockService redisStockService;

    @Override
    public void onMessage(StockDeductMessage message) {
        try {
            // 1. 数据库库存扣减
            int updatedRows = stockMapper.atomicDeductStock(
                message.getProductId(),
                message.getQuantity()
            );

            if (updatedRows == 1) {
                log.info("数据库库存扣减成功: {}", message);
            } else {
                // 2. 数据库扣减失败，回滚Redis库存
                log.error("数据库库存扣减失败，回滚Redis库存: {}", message);
                redisStockService.addStock(message.getProductId(), message.getQuantity());

                // 3. 发送库存不足通知
                sendStockInsufficientNotification(message);
            }

        } catch (Exception e) {
            log.error("库存扣减消息处理异常: {}", message, e);

            // 异常情况下回滚Redis库存
            redisStockService.addStock(message.getProductId(), message.getQuantity());

            // 重试机制由RocketMQ自动处理
            throw new RuntimeException("库存扣减处理失败", e);
        }
    }

    /**
     * 发送库存不足通知
     */
    private void sendStockInsufficientNotification(StockDeductMessage message) {
        // 发送消息通知订单服务库存不足
        // 可以通过MQ或直接调用订单服务API
    }
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class StockDeductMessage {
    private Long productId;
    private Integer quantity;
    private String orderId;
    private Long timestamp;
}
```

## 5. 分布式事务方案

### 5.1 TCC模式实现

```java
/**
 * TCC模式库存服务
 */
@Service
public class TccStockService {

    @Autowired
    private StockMapper stockMapper;

    @Autowired
    private StockReserveMapper stockReserveMapper;

    /**
     * Try阶段：预留库存
     */
    @Transactional
    public boolean tryReserveStock(String xid, Long productId, Integer quantity) {
        try {
            // 1. 检查库存是否充足
            Integer availableStock = stockMapper.getAvailableStock(productId);
            if (availableStock < quantity) {
                log.warn("库存不足: productId={}, available={}, required={}",
                        productId, availableStock, quantity);
                return false;
            }

            // 2. 预留库存（冻结）
            int frozenRows = stockMapper.freezeStock(productId, quantity);
            if (frozenRows != 1) {
                return false;
            }

            // 3. 记录预留信息
            StockReserve reserve = StockReserve.builder()
                    .xid(xid)
                    .productId(productId)
                    .quantity(quantity)
                    .status(TccStatus.TRYING)
                    .createTime(LocalDateTime.now())
                    .build();

            stockReserveMapper.insert(reserve);

            log.info("库存预留成功: xid={}, productId={}, quantity={}", xid, productId, quantity);
            return true;

        } catch (Exception e) {
            log.error("库存预留失败: xid={}, productId={}, quantity={}", xid, productId, quantity, e);
            return false;
        }
    }

    /**
     * Confirm阶段：确认扣减
     */
    @Transactional
    public boolean confirmDeductStock(String xid) {
        try {
            // 1. 查询预留记录
            StockReserve reserve = stockReserveMapper.selectByXid(xid);
            if (reserve == null || reserve.getStatus() != TccStatus.TRYING) {
                log.warn("预留记录不存在或状态异常: xid={}", xid);
                return false;
            }

            // 2. 确认扣减库存（将冻结库存转为实际扣减）
            int confirmedRows = stockMapper.confirmDeductStock(
                reserve.getProductId(),
                reserve.getQuantity()
            );

            if (confirmedRows != 1) {
                log.error("确认库存扣减失败: xid={}", xid);
                return false;
            }

            // 3. 更新预留记录状态
            stockReserveMapper.updateStatus(xid, TccStatus.CONFIRMED);

            log.info("库存扣减确认成功: xid={}", xid);
            return true;

        } catch (Exception e) {
            log.error("库存扣减确认失败: xid={}", xid, e);
            return false;
        }
    }

    /**
     * Cancel阶段：释放预留库存
     */
    @Transactional
    public boolean cancelReserveStock(String xid) {
        try {
            // 1. 查询预留记录
            StockReserve reserve = stockReserveMapper.selectByXid(xid);
            if (reserve == null) {
                log.warn("预留记录不存在: xid={}", xid);
                return true; // 幂等处理
            }

            if (reserve.getStatus() == TccStatus.CANCELLED) {
                log.info("预留库存已取消: xid={}", xid);
                return true; // 幂等处理
            }

            // 2. 释放冻结库存
            int releasedRows = stockMapper.releaseStock(
                reserve.getProductId(),
                reserve.getQuantity()
            );

            if (releasedRows != 1) {
                log.error("释放预留库存失败: xid={}", xid);
                return false;
            }

            // 3. 更新预留记录状态
            stockReserveMapper.updateStatus(xid, TccStatus.CANCELLED);

            log.info("预留库存释放成功: xid={}", xid);
            return true;

        } catch (Exception e) {
            log.error("预留库存释放失败: xid={}", xid, e);
            return false;
        }
    }
}

/**
 * 库存表结构需要支持冻结库存
 */
/*
CREATE TABLE stock (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT NOT NULL,
    total_stock INT NOT NULL COMMENT '总库存',
    available_stock INT NOT NULL COMMENT '可用库存',
    frozen_stock INT NOT NULL DEFAULT 0 COMMENT '冻结库存',
    version INT NOT NULL DEFAULT 0,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_product_id (product_id)
);

CREATE TABLE stock_reserve (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    xid VARCHAR(128) NOT NULL COMMENT '事务ID',
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    status TINYINT NOT NULL COMMENT '状态：1-尝试中,2-已确认,3-已取消',
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_xid (xid),
    INDEX idx_product_id (product_id)
);
*/
```

### 5.2 Seata AT模式

```java
@Service
public class SeataStockService {

    @Autowired
    private StockMapper stockMapper;

    /**
     * 使用Seata AT模式的库存扣减
     */
    @GlobalTransactional(timeoutMills = 30000, name = "stock-deduct")
    public void deductStock(Long productId, Integer quantity, String orderId) {
        try {
            // 1. 原子操作扣减库存
            int updatedRows = stockMapper.atomicDeductStock(productId, quantity);

            if (updatedRows != 1) {
                throw new BusinessException("库存扣减失败，可能库存不足");
            }

            // 2. 记录库存变更日志
            StockChangeLog changeLog = StockChangeLog.builder()
                    .productId(productId)
                    .quantity(-quantity)
                    .orderId(orderId)
                    .changeType(StockChangeType.DEDUCT)
                    .changeTime(LocalDateTime.now())
                    .build();

            stockMapper.insertChangeLog(changeLog);

            log.info("Seata库存扣减成功: productId={}, quantity={}, orderId={}",
                    productId, quantity, orderId);

        } catch (Exception e) {
            log.error("Seata库存扣减失败: productId={}, quantity={}, orderId={}",
                     productId, quantity, orderId, e);
            throw e;
        }
    }

    /**
     * 库存补偿
     */
    public void compensateStock(Long productId, Integer quantity, String orderId) {
        try {
            // 添加库存
            stockMapper.addStock(productId, quantity);

            // 记录补偿日志
            StockChangeLog changeLog = StockChangeLog.builder()
                    .productId(productId)
                    .quantity(quantity)
                    .orderId(orderId)
                    .changeType(StockChangeType.COMPENSATE)
                    .changeTime(LocalDateTime.now())
                    .build();

            stockMapper.insertChangeLog(changeLog);

            log.info("库存补偿成功: productId={}, quantity={}, orderId={}",
                    productId, quantity, orderId);

        } catch (Exception e) {
            log.error("库存补偿失败: productId={}, quantity={}, orderId={}",
                     productId, quantity, orderId, e);
            throw e;
        }
    }
}
```

## 6. 库存预扣方案

### 6.1 基于时间窗口的库存预扣

```java
@Service
public class PreDeductStockService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private StockMapper stockMapper;

    private static final String PRE_DEDUCT_KEY = "pre_deduct:";
    private static final int PRE_DEDUCT_EXPIRE_MINUTES = 15; // 预扣15分钟

    /**
     * 库存预扣减
     */
    public PreDeductResult preDeductStock(Long productId, Integer quantity, String orderId) {
        String script = """
            local stock_key = KEYS[1]
            local pre_deduct_key = KEYS[2]
            local deduct_quantity = tonumber(ARGV[1])
            local expire_time = tonumber(ARGV[2])
            local order_id = ARGV[3]

            -- 获取当前库存
            local current_stock = redis.call('GET', stock_key)
            if current_stock == false then
                return {-1, 0}  -- 库存不存在
            end

            current_stock = tonumber(current_stock)

            -- 检查库存是否充足
            if current_stock < deduct_quantity then
                return {current_stock, 0}  -- 库存不足
            end

            -- 预扣库存
            local new_stock = current_stock - deduct_quantity
            redis.call('SET', stock_key, new_stock)

            -- 记录预扣信息
            local pre_deduct_info = {
                ['orderId'] = order_id,
                ['quantity'] = deduct_quantity,
                ['timestamp'] = redis.call('TIME')[1]
            }
            redis.call('HSET', pre_deduct_key, order_id, cjson.encode(pre_deduct_info))
            redis.call('EXPIRE', pre_deduct_key, expire_time)

            return {new_stock, 1}  -- 成功
            """;

        String stockKey = "stock:product:" + productId;
        String preDeductKey = PRE_DEDUCT_KEY + productId;

        DefaultRedisScript<List> preDeductScript = new DefaultRedisScript<>();
        preDeductScript.setScriptText(script);
        preDeductScript.setResultType(List.class);

        List<String> keys = Arrays.asList(stockKey, preDeductKey);
        List<String> args = Arrays.asList(
            quantity.toString(),
            String.valueOf(PRE_DEDUCT_EXPIRE_MINUTES * 60),
            orderId
        );

        List result = redisTemplate.execute(preDeductScript, keys, args.toArray());

        if (result != null && result.size() == 2) {
            Long stockValue = (Long) result.get(0);
            Long successFlag = (Long) result.get(1);

            if (successFlag == 1) {
                return PreDeductResult.success(stockValue.intValue(), orderId);
            } else if (stockValue == -1) {
                return PreDeductResult.error("库存数据不存在");
            } else {
                return PreDeductResult.insufficient(stockValue.intValue());
            }
        }

        return PreDeductResult.error("系统异常");
    }

    /**
     * 确认预扣减（订单支付成功）
     */
    public boolean confirmPreDeduct(Long productId, String orderId) {
        try {
            // 1. 从Redis删除预扣信息
            String preDeductKey = PRE_DEDUCT_KEY + productId;
            redisTemplate.opsForHash().delete(preDeductKey, orderId);

            // 2. 数据库库存扣减
            // 这里可以异步执行，因为Redis已经扣减了
            CompletableFuture.runAsync(() -> {
                try {
                    // 获取预扣数量（可以从订单信息中获取）
                    Integer quantity = getPreDeductQuantityFromOrder(orderId);
                    stockMapper.atomicDeductStock(productId, quantity);
                } catch (Exception e) {
                    log.error("数据库库存扣减失败: productId={}, orderId={}", productId, orderId, e);
                }
            });

            return true;

        } catch (Exception e) {
            log.error("确认预扣失败: productId={}, orderId={}", productId, orderId, e);
            return false;
        }
    }

    /**
     * 取消预扣减（订单取消或超时）
     */
    public boolean cancelPreDeduct(Long productId, String orderId) {
        String script = """
            local stock_key = KEYS[1]
            local pre_deduct_key = KEYS[2]
            local order_id = ARGV[1]

            -- 获取预扣信息
            local pre_deduct_info = redis.call('HGET', pre_deduct_key, order_id)
            if pre_deduct_info == false then
                return 0  -- 预扣信息不存在
            end

            local info = cjson.decode(pre_deduct_info)
            local quantity = tonumber(info.quantity)

            -- 恢复库存
            redis.call('INCRBY', stock_key, quantity)

            -- 删除预扣信息
            redis.call('HDEL', pre_deduct_key, order_id)

            return quantity
            """;

        String stockKey = "stock:product:" + productId;
        String preDeductKey = PRE_DEDUCT_KEY + productId;

        DefaultRedisScript<Long> cancelScript = new DefaultRedisScript<>();
        cancelScript.setScriptText(script);
        cancelScript.setResultType(Long.class);

        Long restoredQuantity = redisTemplate.execute(
            cancelScript,
            Arrays.asList(stockKey, preDeductKey),
            orderId
        );

        return restoredQuantity != null && restoredQuantity > 0;
    }

    /**
     * 定时清理过期的预扣信息
     */
    @Scheduled(fixedDelay = 60000) // 每分钟执行一次
    public void cleanExpiredPreDeduct() {
        try {
            Set<String> preDeductKeys = redisTemplate.keys(PRE_DEDUCT_KEY + "*");

            for (String preDeductKey : preDeductKeys) {
                Long productId = extractProductIdFromKey(preDeductKey);
                cleanExpiredOrdersForProduct(productId, preDeductKey);
            }

        } catch (Exception e) {
            log.error("清理过期预扣信息失败", e);
        }
    }

    private void cleanExpiredOrdersForProduct(Long productId, String preDeductKey) {
        // 获取所有预扣订单
        Map<Object, Object> preDeductOrders = redisTemplate.opsForHash().entries(preDeductKey);

        long currentTime = System.currentTimeMillis() / 1000;
        String stockKey = "stock:product:" + productId;

        for (Map.Entry<Object, Object> entry : preDeductOrders.entrySet()) {
            String orderId = (String) entry.getKey();
            // 解析预扣信息，检查是否过期
            // 如果过期，恢复库存并删除预扣记录
        }
    }

    private Integer getPreDeductQuantityFromOrder(String orderId) {
        // 从订单服务获取预扣数量
        // 这里简化处理
        return 1;
    }

    private Long extractProductIdFromKey(String key) {
        return Long.parseLong(key.substring(PRE_DEDUCT_KEY.length()));
    }
}

@Data
@Builder
@AllArgsConstructor
public class PreDeductResult {
    private boolean success;
    private Integer remainingStock;
    private String orderId;
    private String errorMessage;

    public static PreDeductResult success(Integer remainingStock, String orderId) {
        return PreDeductResult.builder()
                .success(true)
                .remainingStock(remainingStock)
                .orderId(orderId)
                .build();
    }

    public static PreDeductResult insufficient(Integer currentStock) {
        return PreDeductResult.builder()
                .success(false)
                .remainingStock(currentStock)
                .errorMessage("库存不足")
                .build();
    }

    public static PreDeductResult error(String message) {
        return PreDeductResult.builder()
                .success(false)
                .errorMessage(message)
                .build();
    }
}
```

## 7. 性能优化和最佳实践

### 7.1 库存分片策略

```java
@Service
public class ShardedStockService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private static final int SHARD_COUNT = 10; // 分片数量

    /**
     * 分片库存扣减
     */
    public boolean deductShardedStock(Long productId, Integer quantity) {
        // 1. 计算需要从多少个分片扣减
        List<ShardDeductPlan> plans = calculateDeductPlan(productId, quantity);

        if (plans.isEmpty()) {
            return false; // 库存不足
        }

        // 2. 执行分片扣减
        boolean allSuccess = true;
        List<ShardDeductPlan> executedPlans = new ArrayList<>();

        for (ShardDeductPlan plan : plans) {
            try {
                boolean success = deductSingleShard(productId, plan.getShardIndex(), plan.getQuantity());

                if (success) {
                    executedPlans.add(plan);
                } else {
                    allSuccess = false;
                    break;
                }
            } catch (Exception e) {
                log.error("分片库存扣减失败: productId={}, shard={}, quantity={}",
                         productId, plan.getShardIndex(), plan.getQuantity(), e);
                allSuccess = false;
                break;
            }
        }

        // 3. 如果部分失败，回滚已扣减的分片
        if (!allSuccess) {
            rollbackShardDeduct(productId, executedPlans);
            return false;
        }

        return true;
    }

    /**
     * 计算分片扣减计划
     */
    private List<ShardDeductPlan> calculateDeductPlan(Long productId, Integer totalQuantity) {
        List<ShardDeductPlan> plans = new ArrayList<>();
        Integer remainingQuantity = totalQuantity;

        // 遍历所有分片，尽可能平均分配扣减量
        for (int i = 0; i < SHARD_COUNT && remainingQuantity > 0; i++) {
            String shardKey = getShardKey(productId, i);
            Integer shardStock = getCurrentShardStock(shardKey);

            if (shardStock > 0) {
                Integer deductFromShard = Math.min(shardStock, remainingQuantity);
                plans.add(new ShardDeductPlan(i, deductFromShard));
                remainingQuantity -= deductFromShard;
            }
        }

        // 如果无法完全扣减，返回空列表
        if (remainingQuantity > 0) {
            return Collections.emptyList();
        }

        return plans;
    }

    /**
     * 单个分片库存扣减
     */
    private boolean deductSingleShard(Long productId, Integer shardIndex, Integer quantity) {
        String script = """
            local shard_key = KEYS[1]
            local deduct_quantity = tonumber(ARGV[1])

            local current_stock = redis.call('GET', shard_key)
            if current_stock == false then
                current_stock = 0
            else
                current_stock = tonumber(current_stock)
            end

            if current_stock < deduct_quantity then
                return 0
            end

            local new_stock = current_stock - deduct_quantity
            redis.call('SET', shard_key, new_stock)
            return 1
            """;

        String shardKey = getShardKey(productId, shardIndex);

        DefaultRedisScript<Long> deductScript = new DefaultRedisScript<>();
        deductScript.setScriptText(script);
        deductScript.setResultType(Long.class);

        Long result = redisTemplate.execute(
            deductScript,
            Collections.singletonList(shardKey),
            quantity.toString()
        );

        return result != null && result == 1;
    }

    /**
     * 回滚分片扣减
     */
    private void rollbackShardDeduct(Long productId, List<ShardDeductPlan> executedPlans) {
        for (ShardDeductPlan plan : executedPlans) {
            try {
                String shardKey = getShardKey(productId, plan.getShardIndex());
                redisTemplate.opsForValue().increment(shardKey, plan.getQuantity());
            } catch (Exception e) {
                log.error("回滚分片库存失败: productId={}, shard={}, quantity={}",
                         productId, plan.getShardIndex(), plan.getQuantity(), e);
            }
        }
    }

    private String getShardKey(Long productId, Integer shardIndex) {
        return String.format("stock:shard:%d:%d", productId, shardIndex);
    }

    private Integer getCurrentShardStock(String shardKey) {
        String stock = (String) redisTemplate.opsForValue().get(shardKey);
        return stock != null ? Integer.parseInt(stock) : 0;
    }

    @Data
    @AllArgsConstructor
    private static class ShardDeductPlan {
        private Integer shardIndex;
        private Integer quantity;
    }
}
```

### 7.2 库存同步策略

```java
@Service
public class StockSyncService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private StockMapper stockMapper;

    /**
     * 定时同步Redis库存到数据库
     */
    @Scheduled(fixedDelay = 30000) // 每30秒同步一次
    public void syncStockToDatabase() {
        try {
            Set<String> stockKeys = redisTemplate.keys("stock:product:*");

            for (String stockKey : stockKeys) {
                Long productId = extractProductId(stockKey);
                syncSingleProductStock(productId);
            }

        } catch (Exception e) {
            log.error("库存同步失败", e);
        }
    }

    /**
     * 同步单个商品库存
     */
    private void syncSingleProductStock(Long productId) {
        try {
            String stockKey = "stock:product:" + productId;
            String redisStock = (String) redisTemplate.opsForValue().get(stockKey);

            if (redisStock != null) {
                Integer currentRedisStock = Integer.parseInt(redisStock);
                Integer currentDbStock = stockMapper.getStock(productId);

                // 如果Redis和数据库库存不一致，更新数据库
                if (!Objects.equals(currentRedisStock, currentDbStock)) {
                    stockMapper.updateStockDirectly(productId, currentRedisStock);
                    log.info("库存同步: productId={}, Redis={}, DB={} -> {}",
                            productId, currentRedisStock, currentDbStock, currentRedisStock);
                }
            }

        } catch (Exception e) {
            log.error("同步商品库存失败: productId={}", productId, e);
        }
    }

    /**
     * 从数据库初始化Redis库存
     */
    public void initRedisStockFromDatabase() {
        try {
            List<Stock> stocks = stockMapper.getAllStocks();

            for (Stock stock : stocks) {
                String stockKey = "stock:product:" + stock.getProductId();
                redisTemplate.opsForValue().set(
                    stockKey,
                    stock.getQuantity().toString(),
                    Duration.ofHours(24)
                );
            }

            log.info("Redis库存初始化完成，共初始化{}个商品", stocks.size());

        } catch (Exception e) {
            log.error("Redis库存初始化失败", e);
        }
    }

    private Long extractProductId(String stockKey) {
        return Long.parseLong(stockKey.substring("stock:product:".length()));
    }
}
```

## 8. 方案对比和选择建议

### 8.1 各方案对比

| 方案 | 一致性 | 性能 | 复杂度 | 适用场景 |
|------|--------|------|--------|----------|
| 数据库悲观锁 | 强一致 | 低 | 低 | 低并发场景 |
| 数据库乐观锁 | 强一致 | 中 | 中 | 中等并发场景 |
| Redis Lua脚本 | 强一致 | 高 | 中 | 高并发场景 |
| 消息队列异步 | 最终一致 | 高 | 高 | 对一致性要求不严格 |
| TCC分布式事务 | 强一致 | 中 | 高 | 跨系统场景 |
| 库存预扣 | 弱一致 | 高 | 中 | 电商秒杀场景 |

### 8.2 选择建议

1. **低并发场景（QPS < 1000）**
   - 推荐：数据库原子操作或悲观锁
   - 理由：实现简单，一致性强

2. **中等并发场景（1000 < QPS < 10000）**
   - 推荐：数据库乐观锁 + 重试
   - 理由：性能与一致性平衡

3. **高并发场景（QPS > 10000）**
   - 推荐：Redis Lua脚本 + 异步同步数据库
   - 理由：性能最优，可扩展性强

4. **秒杀场景**
   - 推荐：库存预扣 + 分片策略
   - 理由：处理突发流量，用户体验好

5. **跨系统场景**
   - 推荐：TCC或Saga分布式事务
   - 理由：保证跨系统数据一致性

## 总结

库存扣减一致性是一个复杂的技术问题，需要根据具体的业务场景和性能要求选择合适的方案。在实际应用中，往往需要组合多种方案：

1. **分层设计**：Redis缓存 + 数据库持久化
2. **异步同步**：保证最终一致性
3. **监控告警**：及时发现和处理异常
4. **降级策略**：极端情况下的兜底方案

关键是要在一致性、性能和复杂度之间找到平衡点，确保系统既能满足业务需求，又具备良好的可维护性和扩展性。