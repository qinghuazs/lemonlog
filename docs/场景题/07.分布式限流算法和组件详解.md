# 分布式环境中的限流算法和组件详解

## 1. 限流机制基础概念

### 1.1 什么是限流

限流（Rate Limiting）是分布式系统中一种重要的保护机制，通过控制进入系统的请求速率，防止系统因为突发流量或恶意攻击而过载。限流的核心目标是在保证系统稳定性的前提下，尽可能地提供服务。

### 1.2 限流的作用

- **系统保护**：防止系统因流量过大而崩溃
- **资源分配**：合理分配有限的系统资源
- **服务质量保证**：确保核心用户的服务质量
- **成本控制**：避免因流量激增导致的成本暴涨
- **安全防护**：防止DDoS攻击和恶意请求

### 1.3 限流的维度

#### 1.3.1 按照限流粒度分类

**系统级限流**
- 限制整个系统的总请求量
- 适用于系统整体性能保护

**应用级限流**
- 限制单个应用的请求量
- 适用于微服务架构

**接口级限流**
- 限制单个API接口的请求量
- 适用于不同接口有不同性能要求的场景

**用户级限流**
- 限制单个用户的请求量
- 适用于防止恶意用户滥用

**IP级限流**
- 限制单个IP的请求量
- 适用于防止攻击和爬虫

#### 1.3.2 按照限流范围分类

**单机限流**
- 在单个服务实例上进行限流
- 实现简单，性能高
- 无法应对分布式场景

**分布式限流**
- 在多个服务实例间共享限流配额
- 实现复杂，但能准确控制总体流量
- 适用于集群部署

## 2. 限流算法详解

### 2.1 固定窗口算法

#### 2.1.1 算法原理

固定窗口算法将时间分割为固定大小的窗口，在每个窗口内统计请求数量，当请求数量超过阈值时拒绝后续请求。

```java
public class FixedWindowRateLimiter {
    private final int limit;
    private final long windowSizeMs;
    private volatile long windowStart;
    private volatile int currentCount;
    private final Object lock = new Object();

    public FixedWindowRateLimiter(int limit, long windowSizeMs) {
        this.limit = limit;
        this.windowSizeMs = windowSizeMs;
        this.windowStart = System.currentTimeMillis();
        this.currentCount = 0;
    }

    public boolean tryAcquire() {
        synchronized (lock) {
            long now = System.currentTimeMillis();

            // 检查是否需要重置窗口
            if (now - windowStart >= windowSizeMs) {
                windowStart = now;
                currentCount = 0;
            }

            // 检查是否超过限制
            if (currentCount < limit) {
                currentCount++;
                return true;
            }

            return false;
        }
    }

    public int getCurrentCount() {
        synchronized (lock) {
            long now = System.currentTimeMillis();
            if (now - windowStart >= windowSizeMs) {
                return 0;
            }
            return currentCount;
        }
    }

    public long getTimeToNextWindow() {
        synchronized (lock) {
            long now = System.currentTimeMillis();
            return Math.max(0, windowSizeMs - (now - windowStart));
        }
    }
}
```

#### 2.1.2 优缺点分析

**优点：**
- 实现简单，易于理解
- 内存占用少
- 性能高，时间复杂度O(1)

**缺点：**
- 窗口边界效应严重
- 无法平滑处理突发流量
- 可能出现瞬时流量翻倍问题

### 2.2 滑动窗口算法

#### 2.2.1 基于时间的滑动窗口

```java
public class SlidingTimeWindowRateLimiter {
    private final int limit;
    private final long windowSizeMs;
    private final int bucketCount;
    private final long bucketSizeMs;
    private final CircularArray<Bucket> buckets;
    private final Object lock = new Object();

    private static class Bucket {
        private volatile long timestamp;
        private volatile int count;

        public Bucket(long timestamp) {
            this.timestamp = timestamp;
            this.count = 0;
        }

        public void reset(long timestamp) {
            this.timestamp = timestamp;
            this.count = 0;
        }

        public void increment() {
            this.count++;
        }
    }

    public SlidingTimeWindowRateLimiter(int limit, long windowSizeMs, int bucketCount) {
        this.limit = limit;
        this.windowSizeMs = windowSizeMs;
        this.bucketCount = bucketCount;
        this.bucketSizeMs = windowSizeMs / bucketCount;
        this.buckets = new CircularArray<>(bucketCount);

        // 初始化桶
        long now = System.currentTimeMillis();
        for (int i = 0; i < bucketCount; i++) {
            buckets.set(i, new Bucket(now - (bucketCount - 1 - i) * bucketSizeMs));
        }
    }

    public boolean tryAcquire() {
        synchronized (lock) {
            long now = System.currentTimeMillis();

            // 更新当前桶
            Bucket currentBucket = getCurrentBucket(now);

            // 清理过期桶
            removeExpiredBuckets(now);

            // 计算当前窗口内的总请求数
            int totalCount = calculateTotalCount();

            if (totalCount < limit) {
                currentBucket.increment();
                return true;
            }

            return false;
        }
    }

    private Bucket getCurrentBucket(long timestamp) {
        int index = (int) ((timestamp / bucketSizeMs) % bucketCount);
        Bucket bucket = buckets.get(index);

        // 检查桶是否需要重置
        if (bucket == null || timestamp - bucket.timestamp >= bucketSizeMs) {
            if (bucket == null) {
                bucket = new Bucket(timestamp);
                buckets.set(index, bucket);
            } else {
                bucket.reset(timestamp);
            }
        }

        return bucket;
    }

    private void removeExpiredBuckets(long currentTime) {
        long cutoffTime = currentTime - windowSizeMs;

        for (int i = 0; i < bucketCount; i++) {
            Bucket bucket = buckets.get(i);
            if (bucket != null && bucket.timestamp < cutoffTime) {
                buckets.set(i, null);
            }
        }
    }

    private int calculateTotalCount() {
        int total = 0;
        for (int i = 0; i < bucketCount; i++) {
            Bucket bucket = buckets.get(i);
            if (bucket != null) {
                total += bucket.count;
            }
        }
        return total;
    }

    public double getCurrentRate() {
        synchronized (lock) {
            long now = System.currentTimeMillis();
            removeExpiredBuckets(now);
            int totalCount = calculateTotalCount();
            return (double) totalCount / (windowSizeMs / 1000.0);
        }
    }
}
```

#### 2.2.2 基于计数的滑动窗口

```java
public class SlidingCountWindowRateLimiter {
    private final int limit;
    private final Queue<Long> requestTimestamps;
    private final Object lock = new Object();

    public SlidingCountWindowRateLimiter(int limit) {
        this.limit = limit;
        this.requestTimestamps = new LinkedList<>();
    }

    public boolean tryAcquire() {
        synchronized (lock) {
            long now = System.currentTimeMillis();

            // 移除超出窗口的请求
            while (!requestTimestamps.isEmpty() &&
                   now - requestTimestamps.peek() > 1000) { // 1秒窗口
                requestTimestamps.poll();
            }

            // 检查是否超过限制
            if (requestTimestamps.size() < limit) {
                requestTimestamps.offer(now);
                return true;
            }

            return false;
        }
    }

    public int getCurrentCount() {
        synchronized (lock) {
            long now = System.currentTimeMillis();

            // 移除过期请求
            while (!requestTimestamps.isEmpty() &&
                   now - requestTimestamps.peek() > 1000) {
                requestTimestamps.poll();
            }

            return requestTimestamps.size();
        }
    }

    public long getOldestRequestTime() {
        synchronized (lock) {
            return requestTimestamps.isEmpty() ? 0 : requestTimestamps.peek();
        }
    }
}
```

### 2.3 令牌桶算法

#### 2.3.1 基础令牌桶实现

```java
public class TokenBucketRateLimiter {
    private final int capacity;      // 桶容量
    private final double refillRate; // 令牌生成速率（每秒）
    private volatile double tokens;  // 当前令牌数
    private volatile long lastRefill; // 上次添加令牌的时间
    private final Object lock = new Object();

    public TokenBucketRateLimiter(int capacity, double refillRate) {
        this.capacity = capacity;
        this.refillRate = refillRate;
        this.tokens = capacity;
        this.lastRefill = System.currentTimeMillis();
    }

    public boolean tryAcquire() {
        return tryAcquire(1);
    }

    public boolean tryAcquire(int requestTokens) {
        synchronized (lock) {
            refillTokens();

            if (tokens >= requestTokens) {
                tokens -= requestTokens;
                return true;
            }

            return false;
        }
    }

    public boolean tryAcquire(int requestTokens, long timeoutMs) {
        synchronized (lock) {
            long startTime = System.currentTimeMillis();

            while (System.currentTimeMillis() - startTime < timeoutMs) {
                refillTokens();

                if (tokens >= requestTokens) {
                    tokens -= requestTokens;
                    return true;
                }

                // 计算下次获取令牌的时间
                double tokensNeeded = requestTokens - tokens;
                long waitTime = (long) (tokensNeeded / refillRate * 1000);
                waitTime = Math.min(waitTime, timeoutMs - (System.currentTimeMillis() - startTime));

                if (waitTime > 0) {
                    try {
                        lock.wait(waitTime);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return false;
                    }
                }
            }

            return false;
        }
    }

    private void refillTokens() {
        long now = System.currentTimeMillis();
        double timePassed = (now - lastRefill) / 1000.0;
        double tokensToAdd = timePassed * refillRate;

        tokens = Math.min(capacity, tokens + tokensToAdd);
        lastRefill = now;
    }

    public double getAvailableTokens() {
        synchronized (lock) {
            refillTokens();
            return tokens;
        }
    }

    public double getRefillRate() {
        return refillRate;
    }

    public int getCapacity() {
        return capacity;
    }
}
```

#### 2.3.2 分层令牌桶

```java
public class HierarchicalTokenBucket {
    private final Map<String, TokenBucketRateLimiter> buckets;
    private final TokenBucketConfig config;

    public HierarchicalTokenBucket(TokenBucketConfig config) {
        this.config = config;
        this.buckets = new ConcurrentHashMap<>();
        initializeBuckets();
    }

    private void initializeBuckets() {
        // 全局令牌桶
        buckets.put("global", new TokenBucketRateLimiter(
            config.getGlobalCapacity(),
            config.getGlobalRefillRate()
        ));

        // 用户级令牌桶
        for (String userType : config.getUserTypes()) {
            buckets.put("user:" + userType, new TokenBucketRateLimiter(
                config.getUserCapacity(userType),
                config.getUserRefillRate(userType)
            ));
        }

        // API级令牌桶
        for (String api : config.getApis()) {
            buckets.put("api:" + api, new TokenBucketRateLimiter(
                config.getApiCapacity(api),
                config.getApiRefillRate(api)
            ));
        }
    }

    public boolean tryAcquire(String userId, String userType, String api) {
        return tryAcquire(userId, userType, api, 1);
    }

    public boolean tryAcquire(String userId, String userType, String api, int tokens) {
        // 按优先级检查各级限制
        List<String> bucketKeys = Arrays.asList(
            "global",
            "user:" + userType,
            "api:" + api,
            "user-api:" + userId + ":" + api
        );

        // 预检查所有桶是否都有足够令牌
        for (String key : bucketKeys) {
            TokenBucketRateLimiter bucket = getBucket(key);
            if (bucket != null && bucket.getAvailableTokens() < tokens) {
                return false;
            }
        }

        // 从所有相关桶中消费令牌
        for (String key : bucketKeys) {
            TokenBucketRateLimiter bucket = getBucket(key);
            if (bucket != null && !bucket.tryAcquire(tokens)) {
                // 回滚已消费的令牌
                rollbackTokens(bucketKeys, key, tokens);
                return false;
            }
        }

        return true;
    }

    private TokenBucketRateLimiter getBucket(String key) {
        return buckets.computeIfAbsent(key, k -> {
            if (k.startsWith("user-api:")) {
                // 动态创建用户-API组合桶
                return new TokenBucketRateLimiter(
                    config.getDefaultUserApiCapacity(),
                    config.getDefaultUserApiRefillRate()
                );
            }
            return null;
        });
    }

    private void rollbackTokens(List<String> bucketKeys, String failedKey, int tokens) {
        int failedIndex = bucketKeys.indexOf(failedKey);
        for (int i = 0; i < failedIndex; i++) {
            TokenBucketRateLimiter bucket = getBucket(bucketKeys.get(i));
            if (bucket != null) {
                // 这里简化处理，实际应该有更精确的回滚机制
                bucket.tryAcquire(-tokens); // 负数表示归还令牌
            }
        }
    }

    public Map<String, Double> getBucketStatus() {
        Map<String, Double> status = new HashMap<>();
        for (Map.Entry<String, TokenBucketRateLimiter> entry : buckets.entrySet()) {
            status.put(entry.getKey(), entry.getValue().getAvailableTokens());
        }
        return status;
    }
}
```

### 2.4 漏桶算法

#### 2.4.1 基础漏桶实现

```java
public class LeakyBucketRateLimiter {
    private final int capacity;      // 桶容量
    private final double leakRate;   // 漏水速率（每秒）
    private volatile double volume;  // 当前水量
    private volatile long lastLeak;  // 上次漏水时间
    private final Object lock = new Object();

    public LeakyBucketRateLimiter(int capacity, double leakRate) {
        this.capacity = capacity;
        this.leakRate = leakRate;
        this.volume = 0;
        this.lastLeak = System.currentTimeMillis();
    }

    public boolean tryAcquire() {
        return tryAcquire(1);
    }

    public boolean tryAcquire(double water) {
        synchronized (lock) {
            leak();

            if (volume + water <= capacity) {
                volume += water;
                return true;
            }

            return false;
        }
    }

    private void leak() {
        long now = System.currentTimeMillis();
        double timePassed = (now - lastLeak) / 1000.0;
        double waterToLeak = timePassed * leakRate;

        volume = Math.max(0, volume - waterToLeak);
        lastLeak = now;
    }

    public double getCurrentVolume() {
        synchronized (lock) {
            leak();
            return volume;
        }
    }

    public double getCapacity() {
        return capacity;
    }

    public double getLeakRate() {
        return leakRate;
    }

    public boolean isEmpty() {
        return getCurrentVolume() == 0;
    }

    public boolean isFull() {
        return getCurrentVolume() >= capacity;
    }

    public double getWaitTime(double requestWater) {
        synchronized (lock) {
            leak();

            if (volume + requestWater <= capacity) {
                return 0; // 可以立即处理
            }

            // 计算需要等待的时间
            double excessWater = volume + requestWater - capacity;
            return excessWater / leakRate;
        }
    }
}
```

#### 2.4.2 队列化漏桶

```java
public class QueuedLeakyBucket {
    private final int capacity;
    private final double processRate; // 处理速率（每秒）
    private final Queue<RequestInfo> requestQueue;
    private final ScheduledExecutorService scheduler;
    private volatile boolean running;

    private static class RequestInfo {
        private final String requestId;
        private final long arrivalTime;
        private final CompletableFuture<Boolean> future;

        public RequestInfo(String requestId) {
            this.requestId = requestId;
            this.arrivalTime = System.currentTimeMillis();
            this.future = new CompletableFuture<>();
        }
    }

    public QueuedLeakyBucket(int capacity, double processRate) {
        this.capacity = capacity;
        this.processRate = processRate;
        this.requestQueue = new LinkedBlockingQueue<>();
        this.scheduler = Executors.newScheduledThreadPool(1);
        this.running = true;

        startProcessing();
    }

    public CompletableFuture<Boolean> tryAcquire(String requestId) {
        if (!running) {
            return CompletableFuture.completedFuture(false);
        }

        RequestInfo request = new RequestInfo(requestId);

        synchronized (this) {
            if (requestQueue.size() < capacity) {
                requestQueue.offer(request);
                return request.future;
            } else {
                // 桶满，拒绝请求
                request.future.complete(false);
                return request.future;
            }
        }
    }

    private void startProcessing() {
        long intervalMs = Math.round(1000.0 / processRate);

        scheduler.scheduleAtFixedRate(() -> {
            if (!running) {
                return;
            }

            RequestInfo request;
            synchronized (this) {
                request = requestQueue.poll();
            }

            if (request != null) {
                // 模拟请求处理
                processRequest(request);
            }
        }, intervalMs, intervalMs, TimeUnit.MILLISECONDS);
    }

    private void processRequest(RequestInfo request) {
        try {
            // 这里可以添加实际的请求处理逻辑
            // 模拟处理时间
            Thread.sleep(10);

            request.future.complete(true);
        } catch (Exception e) {
            request.future.completeExceptionally(e);
        }
    }

    public int getQueueSize() {
        synchronized (this) {
            return requestQueue.size();
        }
    }

    public double getProcessRate() {
        return processRate;
    }

    public void shutdown() {
        running = false;
        scheduler.shutdown();

        // 清理剩余请求
        RequestInfo request;
        while ((request = requestQueue.poll()) != null) {
            request.future.complete(false);
        }
    }
}
```

### 2.5 自适应限流算法

#### 2.5.1 基于系统负载的自适应限流

```java
public class AdaptiveRateLimiter {
    private final double baseLimit;           // 基准限流值
    private final double maxLimit;            // 最大限流值
    private final double minLimit;            // 最小限流值
    private final SystemMetricsCollector metricsCollector;
    private final ExponentialMovingAverage cpuAverage;
    private final ExponentialMovingAverage responseTimeAverage;

    private volatile double currentLimit;
    private volatile long lastAdjustTime;
    private final long adjustIntervalMs = 1000; // 1秒调整一次

    public AdaptiveRateLimiter(double baseLimit, double minLimit, double maxLimit,
                              SystemMetricsCollector metricsCollector) {
        this.baseLimit = baseLimit;
        this.minLimit = minLimit;
        this.maxLimit = maxLimit;
        this.currentLimit = baseLimit;
        this.metricsCollector = metricsCollector;
        this.cpuAverage = new ExponentialMovingAverage(0.1); // 10%权重
        this.responseTimeAverage = new ExponentialMovingAverage(0.1);
        this.lastAdjustTime = System.currentTimeMillis();
    }

    public boolean tryAcquire() {
        adjustLimitIfNeeded();
        return TokenBucketHolder.INSTANCE.tryAcquire(currentLimit);
    }

    private void adjustLimitIfNeeded() {
        long now = System.currentTimeMillis();
        if (now - lastAdjustTime >= adjustIntervalMs) {
            synchronized (this) {
                if (now - lastAdjustTime >= adjustIntervalMs) {
                    adjustLimit();
                    lastAdjustTime = now;
                }
            }
        }
    }

    private void adjustLimit() {
        SystemMetrics metrics = metricsCollector.getCurrentMetrics();

        // 更新移动平均值
        cpuAverage.update(metrics.getCpuUsage());
        responseTimeAverage.update(metrics.getAverageResponseTime());

        // 计算系统健康分数 (0-1之间)
        double healthScore = calculateHealthScore(metrics);

        // 根据健康分数调整限流值
        double targetLimit = baseLimit * healthScore;
        targetLimit = Math.max(minLimit, Math.min(maxLimit, targetLimit));

        // 平滑调整，避免剧烈变化
        double adjustmentFactor = 0.1; // 每次调整10%
        currentLimit = currentLimit * (1 - adjustmentFactor) + targetLimit * adjustmentFactor;

        logAdjustment(metrics, healthScore, targetLimit);
    }

    private double calculateHealthScore(SystemMetrics metrics) {
        // CPU使用率因子 (0-1)
        double cpuFactor = 1.0 - Math.max(0, (cpuAverage.getAverage() - 70) / 30.0);

        // 内存使用率因子 (0-1)
        double memoryFactor = 1.0 - Math.max(0, (metrics.getMemoryUsage() - 80) / 20.0);

        // 响应时间因子 (0-1)
        double responseTimeFactor = 1.0 - Math.max(0, (responseTimeAverage.getAverage() - 100) / 400.0);

        // 错误率因子 (0-1)
        double errorRateFactor = 1.0 - Math.min(1.0, metrics.getErrorRate() / 0.1);

        // 加权计算总健康分数
        return cpuFactor * 0.3 + memoryFactor * 0.2 + responseTimeFactor * 0.3 + errorRateFactor * 0.2;
    }

    private void logAdjustment(SystemMetrics metrics, double healthScore, double targetLimit) {
        logger.info("Adaptive rate limit adjustment: " +
                   "cpu={:.2f}%, memory={:.2f}%, responseTime={:.2f}ms, errorRate={:.3f}, " +
                   "healthScore={:.3f}, currentLimit={:.2f}, targetLimit={:.2f}",
                   metrics.getCpuUsage(), metrics.getMemoryUsage(),
                   metrics.getAverageResponseTime(), metrics.getErrorRate(),
                   healthScore, currentLimit, targetLimit);
    }

    public double getCurrentLimit() {
        return currentLimit;
    }

    public SystemStatus getSystemStatus() {
        SystemMetrics metrics = metricsCollector.getCurrentMetrics();
        double healthScore = calculateHealthScore(metrics);

        return SystemStatus.builder()
                .cpuUsage(metrics.getCpuUsage())
                .memoryUsage(metrics.getMemoryUsage())
                .responseTime(metrics.getAverageResponseTime())
                .errorRate(metrics.getErrorRate())
                .healthScore(healthScore)
                .currentLimit(currentLimit)
                .build();
    }

    // 单例令牌桶持有者
    private enum TokenBucketHolder {
        INSTANCE;

        private TokenBucketRateLimiter tokenBucket = new TokenBucketRateLimiter(1000, 100);

        public boolean tryAcquire(double limit) {
            // 动态调整令牌桶参数
            if (Math.abs(tokenBucket.getRefillRate() - limit) > 1.0) {
                tokenBucket = new TokenBucketRateLimiter((int) (limit * 10), limit);
            }
            return tokenBucket.tryAcquire();
        }
    }
}
```

#### 2.5.2 基于机器学习的智能限流

```java
public class MLBasedRateLimiter {
    private final MLModel predictionModel;
    private final FeatureExtractor featureExtractor;
    private final CircularBuffer<TrafficData> historicalData;
    private final TokenBucketRateLimiter tokenBucket;

    private volatile double currentLimit;
    private final ScheduledExecutorService scheduler;

    public MLBasedRateLimiter(MLModel model, int historySize) {
        this.predictionModel = model;
        this.featureExtractor = new FeatureExtractor();
        this.historicalData = new CircularBuffer<>(historySize);
        this.currentLimit = 100.0; // 初始限制
        this.tokenBucket = new TokenBucketRateLimiter((int) currentLimit * 10, currentLimit);
        this.scheduler = Executors.newScheduledThreadPool(1);

        startPrediction();
    }

    public boolean tryAcquire() {
        boolean acquired = tokenBucket.tryAcquire();

        // 记录流量数据
        recordTrafficData(acquired);

        return acquired;
    }

    private void startPrediction() {
        scheduler.scheduleAtFixedRate(() -> {
            try {
                updateLimitBasedOnPrediction();
            } catch (Exception e) {
                logger.error("Error during limit prediction", e);
            }
        }, 10, 10, TimeUnit.SECONDS); // 每10秒预测一次
    }

    private void updateLimitBasedOnPrediction() {
        if (historicalData.size() < 10) {
            return; // 数据不足，使用默认限制
        }

        // 提取特征
        Map<String, Double> features = featureExtractor.extractFeatures(historicalData);

        // 预测最优限制值
        double predictedOptimalLimit = predictionModel.predict(features);

        // 平滑调整
        double newLimit = currentLimit * 0.9 + predictedOptimalLimit * 0.1;

        // 安全边界检查
        newLimit = Math.max(10, Math.min(1000, newLimit));

        if (Math.abs(newLimit - currentLimit) > 5) { // 变化超过5才调整
            currentLimit = newLimit;
            updateTokenBucket();

            logger.info("ML-based limit adjustment: {} -> {} (predicted: {})",
                       currentLimit, newLimit, predictedOptimalLimit);
        }
    }

    private void updateTokenBucket() {
        // 重新创建令牌桶以应用新的限制
        synchronized (this) {
            // 这里可以实现更平滑的令牌桶参数调整
            TokenBucketRateLimiter newBucket = new TokenBucketRateLimiter(
                (int) (currentLimit * 10), currentLimit);
            // 原子替换
            this.tokenBucket = newBucket;
        }
    }

    private void recordTrafficData(boolean requestAccepted) {
        long now = System.currentTimeMillis();
        SystemMetrics metrics = SystemMetricsCollector.getCurrentMetrics();

        TrafficData data = TrafficData.builder()
                .timestamp(now)
                .requestAccepted(requestAccepted)
                .currentLimit(currentLimit)
                .cpuUsage(metrics.getCpuUsage())
                .memoryUsage(metrics.getMemoryUsage())
                .responseTime(metrics.getAverageResponseTime())
                .errorRate(metrics.getErrorRate())
                .queueSize(metrics.getQueueSize())
                .build();

        historicalData.add(data);

        // 定期训练模型
        if (historicalData.size() % 100 == 0) {
            retrainModel();
        }
    }

    private void retrainModel() {
        CompletableFuture.runAsync(() -> {
            try {
                List<TrafficData> trainingData = new ArrayList<>(historicalData.toList());
                predictionModel.retrain(trainingData);
                logger.info("Model retrained with {} samples", trainingData.size());
            } catch (Exception e) {
                logger.error("Error during model retraining", e);
            }
        });
    }

    public ModelPerformanceMetrics getModelPerformance() {
        List<TrafficData> recentData = historicalData.toList();
        if (recentData.size() < 20) {
            return ModelPerformanceMetrics.empty();
        }

        // 计算预测准确率
        double accuracy = calculatePredictionAccuracy(recentData);

        // 计算系统效率指标
        double efficiency = calculateSystemEfficiency(recentData);

        return ModelPerformanceMetrics.builder()
                .accuracy(accuracy)
                .efficiency(efficiency)
                .sampleCount(recentData.size())
                .build();
    }

    private double calculatePredictionAccuracy(List<TrafficData> data) {
        // 计算模型预测与实际最优值的差异
        int correctPredictions = 0;
        int totalPredictions = 0;

        for (int i = 10; i < data.size(); i++) { // 需要历史数据来计算最优值
            double actualOptimal = calculateActualOptimalLimit(data, i);
            double predicted = predictionModel.predict(
                featureExtractor.extractFeatures(data.subList(i-10, i)));

            if (Math.abs(predicted - actualOptimal) < actualOptimal * 0.1) { // 10%误差范围
                correctPredictions++;
            }
            totalPredictions++;
        }

        return totalPredictions > 0 ? (double) correctPredictions / totalPredictions : 0.0;
    }

    private double calculateActualOptimalLimit(List<TrafficData> data, int index) {
        // 基于实际系统表现计算最优限制值
        TrafficData current = data.get(index);

        // 简化计算：基于系统负载和性能指标
        double loadFactor = (current.getCpuUsage() + current.getMemoryUsage()) / 200.0;
        double performanceFactor = Math.max(0.1, 1.0 - current.getErrorRate());

        return current.getCurrentLimit() * performanceFactor / Math.max(0.5, loadFactor);
    }

    private double calculateSystemEfficiency(List<TrafficData> data) {
        // 计算系统整体效率：成功处理的请求数 / 总请求数
        long acceptedRequests = data.stream()
                .mapToLong(d -> d.isRequestAccepted() ? 1 : 0)
                .sum();

        return (double) acceptedRequests / data.size();
    }

    public void shutdown() {
        scheduler.shutdown();
    }
}
```

## 3. 分布式限流实现

### 3.1 基于 Redis 的分布式限流

#### 3.1.1 Redis Lua 脚本限流

```java
@Component
public class RedisRateLimiter {
    private final RedisTemplate<String, String> redisTemplate;
    private final RedisScript<Long> limitScript;

    // Lua脚本：滑动窗口限流
    private static final String SLIDING_WINDOW_SCRIPT =
        "local key = KEYS[1]\n" +
        "local window = tonumber(ARGV[1])\n" +
        "local limit = tonumber(ARGV[2])\n" +
        "local current = tonumber(ARGV[3])\n" +
        "\n" +
        "-- 清除过期的记录\n" +
        "redis.call('zremrangebyscore', key, '-inf', current - window)\n" +
        "\n" +
        "-- 获取当前窗口内的请求数\n" +
        "local count = redis.call('zcard', key)\n" +
        "\n" +
        "if count < limit then\n" +
        "    -- 添加当前请求\n" +
        "    redis.call('zadd', key, current, current)\n" +
        "    redis.call('expire', key, math.ceil(window / 1000))\n" +
        "    return {1, limit - count - 1}\n" +
        "else\n" +
        "    return {0, 0}\n" +
        "end";

    // Lua脚本：令牌桶限流
    private static final String TOKEN_BUCKET_SCRIPT =
        "local key = KEYS[1]\n" +
        "local capacity = tonumber(ARGV[1])\n" +
        "local tokens = tonumber(ARGV[2])\n" +
        "local interval = tonumber(ARGV[3])\n" +
        "local requested = tonumber(ARGV[4])\n" +
        "local now = tonumber(ARGV[5])\n" +
        "\n" +
        "local bucket = redis.call('hmget', key, 'tokens', 'last_refill')\n" +
        "local current_tokens = tonumber(bucket[1]) or capacity\n" +
        "local last_refill = tonumber(bucket[2]) or now\n" +
        "\n" +
        "-- 计算需要添加的令牌数\n" +
        "local time_passed = now - last_refill\n" +
        "local tokens_to_add = math.floor(time_passed / interval * tokens)\n" +
        "current_tokens = math.min(capacity, current_tokens + tokens_to_add)\n" +
        "\n" +
        "if current_tokens >= requested then\n" +
        "    current_tokens = current_tokens - requested\n" +
        "    redis.call('hmset', key, 'tokens', current_tokens, 'last_refill', now)\n" +
        "    redis.call('expire', key, math.ceil(capacity / tokens))\n" +
        "    return {1, current_tokens}\n" +
        "else\n" +
        "    redis.call('hmset', key, 'tokens', current_tokens, 'last_refill', now)\n" +
        "    redis.call('expire', key, math.ceil(capacity / tokens))\n" +
        "    return {0, current_tokens}\n" +
        "end";

    public RedisRateLimiter(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
        this.limitScript = new DefaultRedisScript<>(SLIDING_WINDOW_SCRIPT, Long.class);
    }

    public RateLimitResult tryAcquireSlidingWindow(String key, int limit, long windowMs) {
        long now = System.currentTimeMillis();

        List<Object> result = redisTemplate.execute(
            limitScript,
            Collections.singletonList(key),
            String.valueOf(windowMs),
            String.valueOf(limit),
            String.valueOf(now)
        );

        boolean allowed = ((Long) result.get(0)) == 1;
        int remaining = ((Long) result.get(1)).intValue();

        return new RateLimitResult(allowed, remaining, limit);
    }

    public RateLimitResult tryAcquireTokenBucket(String key, int capacity,
                                               int tokensPerSecond, int requested) {
        long now = System.currentTimeMillis();
        int interval = 1000 / tokensPerSecond; // 每个令牌的间隔时间（毫秒）

        RedisScript<List> tokenScript = new DefaultRedisScript<>(TOKEN_BUCKET_SCRIPT, List.class);

        List<Object> result = redisTemplate.execute(
            tokenScript,
            Collections.singletonList(key),
            String.valueOf(capacity),
            String.valueOf(tokensPerSecond),
            String.valueOf(interval),
            String.valueOf(requested),
            String.valueOf(now)
        );

        boolean allowed = ((Long) result.get(0)) == 1;
        int remaining = ((Long) result.get(1)).intValue();

        return new RateLimitResult(allowed, remaining, capacity);
    }

    public RateLimitResult tryAcquireWithMultipleKeys(List<String> keys,
                                                    List<Integer> limits,
                                                    long windowMs) {
        // 批量检查多个限流键
        String batchScript =
            "local results = {}\n" +
            "for i = 1, #KEYS do\n" +
            "    local key = KEYS[i]\n" +
            "    local limit = tonumber(ARGV[i])\n" +
            "    local window = tonumber(ARGV[#KEYS + 1])\n" +
            "    local current = tonumber(ARGV[#KEYS + 2])\n" +
            "    \n" +
            "    redis.call('zremrangebyscore', key, '-inf', current - window)\n" +
            "    local count = redis.call('zcard', key)\n" +
            "    \n" +
            "    if count >= limit then\n" +
            "        return {0, i, count}\n" +
            "    end\n" +
            "    \n" +
            "    table.insert(results, {key, count})\n" +
            "end\n" +
            "\n" +
            "-- 所有检查通过，添加记录\n" +
            "for i = 1, #results do\n" +
            "    local key = results[i][1]\n" +
            "    redis.call('zadd', key, current, current)\n" +
            "    redis.call('expire', key, math.ceil(window / 1000))\n" +
            "end\n" +
            "\n" +
            "return {1, 0, 0}";

        long now = System.currentTimeMillis();
        List<String> args = new ArrayList<>();

        // 添加限制值
        for (Integer limit : limits) {
            args.add(String.valueOf(limit));
        }
        args.add(String.valueOf(windowMs));
        args.add(String.valueOf(now));

        RedisScript<List> batchLimitScript = new DefaultRedisScript<>(batchScript, List.class);

        List<Object> result = redisTemplate.execute(batchLimitScript, keys, args.toArray());

        boolean allowed = ((Long) result.get(0)) == 1;
        int failedIndex = ((Long) result.get(1)).intValue();
        int currentCount = ((Long) result.get(2)).intValue();

        if (allowed) {
            return new RateLimitResult(true, -1, -1); // 成功，剩余数量不适用于批量操作
        } else {
            return new RateLimitResult(false, currentCount, limits.get(failedIndex - 1));
        }
    }

    @Data
    @AllArgsConstructor
    public static class RateLimitResult {
        private final boolean allowed;
        private final int remaining;
        private final int limit;

        public boolean isAllowed() {
            return allowed;
        }

        public double getUsagePercentage() {
            if (limit <= 0) return 0.0;
            return (double) (limit - remaining) / limit;
        }
    }
}
```

#### 3.1.2 Redis 集群限流

```java
@Component
public class ClusterRedisRateLimiter {
    private final List<RedisTemplate<String, String>> redisTemplates;
    private final ConsistentHash<RedisTemplate<String, String>> consistentHash;
    private final LoadBalancer<RedisTemplate<String, String>> loadBalancer;

    public ClusterRedisRateLimiter(List<RedisTemplate<String, String>> redisTemplates) {
        this.redisTemplates = redisTemplates;
        this.consistentHash = new ConsistentHash<>(redisTemplates);
        this.loadBalancer = new RoundRobinLoadBalancer<>(redisTemplates);
    }

    public RateLimitResult tryAcquireDistributed(String key, int limit, long windowMs,
                                               DistributionStrategy strategy) {
        switch (strategy) {
            case CONSISTENT_HASH:
                return tryAcquireWithConsistentHash(key, limit, windowMs);
            case DISTRIBUTED_QUOTA:
                return tryAcquireWithDistributedQuota(key, limit, windowMs);
            case MASTER_SLAVE:
                return tryAcquireWithMasterSlave(key, limit, windowMs);
            default:
                throw new IllegalArgumentException("Unsupported strategy: " + strategy);
        }
    }

    private RateLimitResult tryAcquireWithConsistentHash(String key, int limit, long windowMs) {
        RedisTemplate<String, String> redisTemplate = consistentHash.get(key);
        return executeLimitCheck(redisTemplate, key, limit, windowMs);
    }

    private RateLimitResult tryAcquireWithDistributedQuota(String key, int limit, long windowMs) {
        int nodeCount = redisTemplates.size();
        int quotaPerNode = limit / nodeCount;
        int remainder = limit % nodeCount;

        List<CompletableFuture<RateLimitResult>> futures = new ArrayList<>();

        for (int i = 0; i < redisTemplates.size(); i++) {
            RedisTemplate<String, String> template = redisTemplates.get(i);
            int nodeQuota = quotaPerNode + (i < remainder ? 1 : 0);
            String nodeKey = key + ":node:" + i;

            CompletableFuture<RateLimitResult> future = CompletableFuture.supplyAsync(() ->
                executeLimitCheck(template, nodeKey, nodeQuota, windowMs));
            futures.add(future);
        }

        // 等待所有节点响应或第一个成功响应
        for (CompletableFuture<RateLimitResult> future : futures) {
            try {
                RateLimitResult result = future.get(100, TimeUnit.MILLISECONDS);
                if (result.isAllowed()) {
                    return result;
                }
            } catch (Exception e) {
                logger.warn("Node limit check failed", e);
            }
        }

        return new RateLimitResult(false, 0, limit);
    }

    private RateLimitResult tryAcquireWithMasterSlave(String key, int limit, long windowMs) {
        // 主节点处理写操作
        RedisTemplate<String, String> master = redisTemplates.get(0);

        try {
            RateLimitResult result = executeLimitCheck(master, key, limit, windowMs);

            // 异步同步到从节点
            if (result.isAllowed()) {
                syncToSlaves(key, windowMs);
            }

            return result;
        } catch (Exception e) {
            logger.error("Master node failed, trying slaves", e);

            // 主节点失败，尝试从节点（只读模式）
            for (int i = 1; i < redisTemplates.size(); i++) {
                try {
                    return executeLimitCheckReadOnly(redisTemplates.get(i), key, limit, windowMs);
                } catch (Exception slaveException) {
                    logger.warn("Slave node {} failed", i, slaveException);
                }
            }

            throw new RuntimeException("All Redis nodes failed", e);
        }
    }

    private void syncToSlaves(String key, long windowMs) {
        for (int i = 1; i < redisTemplates.size(); i++) {
            RedisTemplate<String, String> slave = redisTemplates.get(i);
            CompletableFuture.runAsync(() -> {
                try {
                    // 同步当前时间戳到从节点
                    long now = System.currentTimeMillis();
                    slave.opsForZSet().add(key, String.valueOf(now), now);
                    slave.expire(key, Duration.ofMilliseconds(windowMs));
                } catch (Exception e) {
                    logger.warn("Failed to sync to slave", e);
                }
            });
        }
    }

    private RateLimitResult executeLimitCheck(RedisTemplate<String, String> template,
                                            String key, int limit, long windowMs) {
        // 使用之前定义的滑动窗口脚本
        RedisScript<List> script = new DefaultRedisScript<>(SLIDING_WINDOW_SCRIPT, List.class);
        long now = System.currentTimeMillis();

        List<Object> result = template.execute(
            script,
            Collections.singletonList(key),
            String.valueOf(windowMs),
            String.valueOf(limit),
            String.valueOf(now)
        );

        boolean allowed = ((Long) result.get(0)) == 1;
        int remaining = ((Long) result.get(1)).intValue();

        return new RateLimitResult(allowed, remaining, limit);
    }

    private RateLimitResult executeLimitCheckReadOnly(RedisTemplate<String, String> template,
                                                    String key, int limit, long windowMs) {
        // 只读模式：只检查不修改
        long now = System.currentTimeMillis();
        long cutoff = now - windowMs;

        Long count = template.opsForZSet().count(key, cutoff, now);
        boolean allowed = count != null && count < limit;
        int remaining = allowed ? (int) (limit - count - 1) : 0;

        return new RateLimitResult(allowed, remaining, limit);
    }

    public enum DistributionStrategy {
        CONSISTENT_HASH,    // 一致性哈希分布
        DISTRIBUTED_QUOTA,  // 分布式配额
        MASTER_SLAVE       // 主从模式
    }

    public ClusterHealth getClusterHealth() {
        List<NodeHealth> nodeHealths = new ArrayList<>();

        for (int i = 0; i < redisTemplates.size(); i++) {
            RedisTemplate<String, String> template = redisTemplates.get(i);
            NodeHealth health;

            try {
                // 测试连接
                template.opsForValue().get("health_check");
                health = new NodeHealth(i, true, null);
            } catch (Exception e) {
                health = new NodeHealth(i, false, e.getMessage());
            }

            nodeHealths.add(health);
        }

        long healthyNodes = nodeHealths.stream().mapToLong(h -> h.isHealthy() ? 1 : 0).sum();
        double healthPercentage = (double) healthyNodes / nodeHealths.size();

        return new ClusterHealth(nodeHealths, healthPercentage);
    }

    @Data
    @AllArgsConstructor
    public static class NodeHealth {
        private final int nodeIndex;
        private final boolean healthy;
        private final String error;
    }

    @Data
    @AllArgsConstructor
    public static class ClusterHealth {
        private final List<NodeHealth> nodes;
        private final double healthPercentage;

        public boolean isHealthy() {
            return healthPercentage > 0.5; // 超过一半节点健康
        }
    }
}
```

### 3.2 基于数据库的分布式限流

#### 3.2.1 数据库实现限流

```java
@Repository
public class DatabaseRateLimiter {
    private final JdbcTemplate jdbcTemplate;
    private final TransactionTemplate transactionTemplate;

    // 创建限流表的SQL
    private static final String CREATE_TABLE_SQL = """
        CREATE TABLE IF NOT EXISTS rate_limit_buckets (
            id VARCHAR(255) PRIMARY KEY,
            tokens DECIMAL(10,2) NOT NULL,
            last_refill BIGINT NOT NULL,
            capacity INT NOT NULL,
            refill_rate DECIMAL(10,2) NOT NULL,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            INDEX idx_updated_at (updated_at)
        )
        """;

    public DatabaseRateLimiter(JdbcTemplate jdbcTemplate, TransactionTemplate transactionTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        this.transactionTemplate = transactionTemplate;
        initializeTable();
    }

    private void initializeTable() {
        try {
            jdbcTemplate.execute(CREATE_TABLE_SQL);
        } catch (Exception e) {
            logger.error("Failed to create rate limit table", e);
        }
    }

    public boolean tryAcquire(String key, int capacity, double refillRate, int requestedTokens) {
        return Boolean.TRUE.equals(transactionTemplate.execute(status -> {
            try {
                return tryAcquireInTransaction(key, capacity, refillRate, requestedTokens);
            } catch (Exception e) {
                status.setRollbackOnly();
                logger.error("Rate limit transaction failed", e);
                return false;
            }
        }));
    }

    private boolean tryAcquireInTransaction(String key, int capacity, double refillRate, int requestedTokens) {
        long now = System.currentTimeMillis();

        // 获取或创建令牌桶记录
        RateLimitBucket bucket = getOrCreateBucket(key, capacity, refillRate, now);

        // 计算应该添加的令牌数
        long timePassed = now - bucket.getLastRefill();
        double tokensToAdd = (timePassed / 1000.0) * refillRate;
        double newTokens = Math.min(capacity, bucket.getTokens() + tokensToAdd);

        // 检查是否有足够的令牌
        if (newTokens >= requestedTokens) {
            newTokens -= requestedTokens;

            // 更新令牌桶
            updateBucket(key, newTokens, now);
            return true;
        } else {
            // 更新最后刷新时间，但不扣除令牌
            updateBucket(key, newTokens, now);
            return false;
        }
    }

    private RateLimitBucket getOrCreateBucket(String key, int capacity, double refillRate, long now) {
        String selectSql = "SELECT tokens, last_refill, capacity, refill_rate FROM rate_limit_buckets WHERE id = ?";

        List<RateLimitBucket> buckets = jdbcTemplate.query(selectSql, new Object[]{key}, (rs, rowNum) ->
                RateLimitBucket.builder()
                        .id(key)
                        .tokens(rs.getDouble("tokens"))
                        .lastRefill(rs.getLong("last_refill"))
                        .capacity(rs.getInt("capacity"))
                        .refillRate(rs.getDouble("refill_rate"))
                        .build()
        );

        if (!buckets.isEmpty()) {
            return buckets.get(0);
        } else {
            // 创建新的令牌桶
            String insertSql = "INSERT INTO rate_limit_buckets (id, tokens, last_refill, capacity, refill_rate) VALUES (?, ?, ?, ?, ?)";
            jdbcTemplate.update(insertSql, key, (double) capacity, now, capacity, refillRate);

            return RateLimitBucket.builder()
                    .id(key)
                    .tokens(capacity)
                    .lastRefill(now)
                    .capacity(capacity)
                    .refillRate(refillRate)
                    .build();
        }
    }

    private void updateBucket(String key, double tokens, long lastRefill) {
        String updateSql = "UPDATE rate_limit_buckets SET tokens = ?, last_refill = ? WHERE id = ?";
        jdbcTemplate.update(updateSql, tokens, lastRefill, key);
    }

    public RateLimitStatus getBucketStatus(String key) {
        String selectSql = "SELECT tokens, last_refill, capacity, refill_rate FROM rate_limit_buckets WHERE id = ?";

        List<RateLimitBucket> buckets = jdbcTemplate.query(selectSql, new Object[]{key}, (rs, rowNum) ->
                RateLimitBucket.builder()
                        .id(key)
                        .tokens(rs.getDouble("tokens"))
                        .lastRefill(rs.getLong("last_refill"))
                        .capacity(rs.getInt("capacity"))
                        .refillRate(rs.getDouble("refill_rate"))
                        .build()
        );

        if (buckets.isEmpty()) {
            return RateLimitStatus.notFound();
        }

        RateLimitBucket bucket = buckets.get(0);
        long now = System.currentTimeMillis();

        // 计算当前应有的令牌数
        long timePassed = now - bucket.getLastRefill();
        double tokensToAdd = (timePassed / 1000.0) * bucket.getRefillRate();
        double currentTokens = Math.min(bucket.getCapacity(), bucket.getTokens() + tokensToAdd);

        return RateLimitStatus.builder()
                .available(true)
                .tokens(currentTokens)
                .capacity(bucket.getCapacity())
                .refillRate(bucket.getRefillRate())
                .utilizationRate((bucket.getCapacity() - currentTokens) / bucket.getCapacity())
                .build();
    }

    public boolean tryAcquireBatch(List<BatchRateLimitRequest> requests) {
        return Boolean.TRUE.equals(transactionTemplate.execute(status -> {
            try {
                long now = System.currentTimeMillis();

                // 预检查所有请求
                for (BatchRateLimitRequest request : requests) {
                    RateLimitBucket bucket = getOrCreateBucket(
                            request.getKey(),
                            request.getCapacity(),
                            request.getRefillRate(),
                            now
                    );

                    long timePassed = now - bucket.getLastRefill();
                    double tokensToAdd = (timePassed / 1000.0) * bucket.getRefillRate();
                    double currentTokens = Math.min(bucket.getCapacity(), bucket.getTokens() + tokensToAdd);

                    if (currentTokens < request.getRequestedTokens()) {
                        return false; // 有请求无法满足，整批失败
                    }
                }

                // 所有请求都能满足，执行扣除
                for (BatchRateLimitRequest request : requests) {
                    tryAcquireInTransaction(
                            request.getKey(),
                            request.getCapacity(),
                            request.getRefillRate(),
                            request.getRequestedTokens()
                    );
                }

                return true;
            } catch (Exception e) {
                status.setRollbackOnly();
                logger.error("Batch rate limit transaction failed", e);
                return false;
            }
        }));
    }

    public void cleanupExpiredBuckets(Duration retentionPeriod) {
        long cutoffTime = System.currentTimeMillis() - retentionPeriod.toMillis();
        String deleteSql = "DELETE FROM rate_limit_buckets WHERE updated_at < ?";

        int deletedCount = jdbcTemplate.update(deleteSql, new Timestamp(cutoffTime));
        logger.info("Cleaned up {} expired rate limit buckets", deletedCount);
    }

    @Data
    @Builder
    public static class RateLimitBucket {
        private String id;
        private double tokens;
        private long lastRefill;
        private int capacity;
        private double refillRate;
    }

    @Data
    @Builder
    public static class RateLimitStatus {
        private boolean available;
        private double tokens;
        private int capacity;
        private double refillRate;
        private double utilizationRate;

        public static RateLimitStatus notFound() {
            return RateLimitStatus.builder()
                    .available(false)
                    .tokens(0)
                    .capacity(0)
                    .refillRate(0)
                    .utilizationRate(0)
                    .build();
        }
    }

    @Data
    @Builder
    @AllArgsConstructor
    public static class BatchRateLimitRequest {
        private String key;
        private int capacity;
        private double refillRate;
        private int requestedTokens;
    }
}
```

### 3.3 基于 Zookeeper 的分布式限流

#### 3.3.1 ZooKeeper 协调限流

```java
@Component
public class ZookeeperRateLimiter {
    private final CuratorFramework client;
    private final String basePath;
    private final Map<String, DistributedAtomicLong> counters;
    private final Map<String, PathChildrenCache> watchers;
    private final ScheduledExecutorService scheduler;

    public ZookeeperRateLimiter(CuratorFramework client, String basePath) {
        this.client = client;
        this.basePath = basePath;
        this.counters = new ConcurrentHashMap<>();
        this.watchers = new ConcurrentHashMap<>();
        this.scheduler = Executors.newScheduledThreadPool(2);

        initializeBasePath();
        startCleanupTask();
    }

    private void initializeBasePath() {
        try {
            if (client.checkExists().forPath(basePath) == null) {
                client.create()
                        .creatingParentsIfNeeded()
                        .forPath(basePath);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize ZooKeeper base path", e);
        }
    }

    public boolean tryAcquire(String key, int limit, long windowMs) {
        try {
            String windowPath = getWindowPath(key, windowMs);
            DistributedAtomicLong counter = getOrCreateCounter(windowPath);

            // 尝试递增计数器
            AtomicValue<Long> result = counter.increment();

            if (result.succeeded()) {
                long currentCount = result.postValue();
                return currentCount <= limit;
            } else {
                // 递增失败，重试
                return tryAcquireWithRetry(counter, limit, 3);
            }

        } catch (Exception e) {
            logger.error("ZooKeeper rate limit check failed", e);
            return false; // 失败时拒绝请求，保守策略
        }
    }

    private boolean tryAcquireWithRetry(DistributedAtomicLong counter, int limit, int maxRetries) {
        for (int i = 0; i < maxRetries; i++) {
            try {
                AtomicValue<Long> result = counter.increment();
                if (result.succeeded()) {
                    return result.postValue() <= limit;
                }

                // 短暂等待后重试
                Thread.sleep(10 * (i + 1));
            } catch (Exception e) {
                logger.warn("Retry {} failed", i + 1, e);
            }
        }
        return false;
    }

    private String getWindowPath(String key, long windowMs) {
        long windowStart = (System.currentTimeMillis() / windowMs) * windowMs;
        return basePath + "/" + key + "/" + windowStart;
    }

    private DistributedAtomicLong getOrCreateCounter(String path) throws Exception {
        return counters.computeIfAbsent(path, p -> {
            try {
                // 确保路径存在
                if (client.checkExists().forPath(p) == null) {
                    client.create()
                            .creatingParentsIfNeeded()
                            .forPath(p, "0".getBytes());
                }

                RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
                return new DistributedAtomicLong(client, p, retryPolicy);

            } catch (Exception e) {
                throw new RuntimeException("Failed to create distributed counter", e);
            }
        });
    }

    public boolean tryAcquireGlobalQuota(String key, int globalLimit, long windowMs) {
        try {
            String quotaPath = basePath + "/global/" + key;
            String instancePath = quotaPath + "/instances";

            // 获取当前活跃实例数
            List<String> instances = client.getChildren().forPath(instancePath);
            int instanceCount = instances.size();

            if (instanceCount == 0) {
                return false; // 没有活跃实例
            }

            // 计算每个实例的配额
            int quotaPerInstance = globalLimit / instanceCount;
            int remainder = globalLimit % instanceCount;

            // 获取当前实例的索引
            String currentInstance = getCurrentInstanceId();
            int instanceIndex = instances.indexOf(currentInstance);

            // 分配配额（前remainder个实例多分配1个）
            int instanceQuota = quotaPerInstance + (instanceIndex < remainder ? 1 : 0);

            // 使用实例配额进行限流
            return tryAcquire(key + ":instance:" + currentInstance, instanceQuota, windowMs);

        } catch (Exception e) {
            logger.error("Global quota rate limit failed", e);
            return false;
        }
    }

    public void registerInstance() {
        try {
            String instancesPath = basePath + "/instances";
            String instancePath = instancesPath + "/" + getCurrentInstanceId();

            // 确保instances路径存在
            if (client.checkExists().forPath(instancesPath) == null) {
                client.create()
                        .creatingParentsIfNeeded()
                        .forPath(instancesPath);
            }

            // 创建临时节点表示当前实例
            client.create()
                    .withMode(CreateMode.EPHEMERAL)
                    .forPath(instancePath, getInstanceInfo().getBytes());

            // 监听实例变化
            watchInstanceChanges();

        } catch (Exception e) {
            throw new RuntimeException("Failed to register instance", e);
        }
    }

    private void watchInstanceChanges() {
        try {
            String instancesPath = basePath + "/instances";
            PathChildrenCache cache = new PathChildrenCache(client, instancesPath, true);

            cache.getListenable().addListener(new PathChildrenCacheListener() {
                @Override
                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) {
                    switch (event.getType()) {
                        case CHILD_ADDED:
                            logger.info("New instance joined: {}", event.getData().getPath());
                            onInstanceChange();
                            break;
                        case CHILD_REMOVED:
                            logger.info("Instance left: {}", event.getData().getPath());
                            onInstanceChange();
                            break;
                        default:
                            break;
                    }
                }
            });

            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);
            watchers.put(instancesPath, cache);

        } catch (Exception e) {
            logger.error("Failed to watch instance changes", e);
        }
    }

    private void onInstanceChange() {
        // 实例变化时，清理本地配额缓存
        scheduler.schedule(() -> {
            counters.clear();
            logger.info("Quota cache cleared due to instance change");
        }, 1, TimeUnit.SECONDS);
    }

    private void startCleanupTask() {
        scheduler.scheduleAtFixedRate(() -> {
            try {
                cleanupExpiredWindows();
            } catch (Exception e) {
                logger.error("Cleanup task failed", e);
            }
        }, 1, 1, TimeUnit.MINUTES);
    }

    private void cleanupExpiredWindows() {
        long cutoffTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1); // 清理1小时前的窗口

        try {
            List<String> children = client.getChildren().forPath(basePath);

            for (String child : children) {
                if (child.equals("instances") || child.equals("global")) {
                    continue; // 跳过特殊目录
                }

                String childPath = basePath + "/" + child;
                List<String> windows = client.getChildren().forPath(childPath);

                for (String window : windows) {
                    try {
                        long windowTime = Long.parseLong(window);
                        if (windowTime < cutoffTime) {
                            String windowPath = childPath + "/" + window;
                            client.delete().guaranteed().forPath(windowPath);
                            counters.remove(windowPath);
                        }
                    } catch (NumberFormatException e) {
                        // 跳过非数字窗口名
                    }
                }

                // 如果目录为空，删除它
                if (client.getChildren().forPath(childPath).isEmpty()) {
                    client.delete().forPath(childPath);
                }
            }

        } catch (Exception e) {
            logger.error("Failed to cleanup expired windows", e);
        }
    }

    private String getCurrentInstanceId() {
        return ManagementFactory.getRuntimeMXBean().getName();
    }

    private String getInstanceInfo() {
        return String.format("{\"id\":\"%s\",\"startTime\":%d,\"host\":\"%s\"}",
                getCurrentInstanceId(),
                System.currentTimeMillis(),
                getLocalHostname());
    }

    private String getLocalHostname() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            return "unknown";
        }
    }

    public RateLimitClusterInfo getClusterInfo() {
        try {
            String instancesPath = basePath + "/instances";
            List<String> instances = client.getChildren().forPath(instancesPath);

            List<InstanceInfo> instanceInfos = new ArrayList<>();
            for (String instance : instances) {
                try {
                    byte[] data = client.getData().forPath(instancesPath + "/" + instance);
                    String info = new String(data);
                    instanceInfos.add(parseInstanceInfo(instance, info));
                } catch (Exception e) {
                    logger.warn("Failed to get info for instance: {}", instance, e);
                }
            }

            return new RateLimitClusterInfo(instanceInfos.size(), instanceInfos);

        } catch (Exception e) {
            logger.error("Failed to get cluster info", e);
            return new RateLimitClusterInfo(0, Collections.emptyList());
        }
    }

    private InstanceInfo parseInstanceInfo(String instanceId, String info) {
        // 简化的JSON解析，实际可以使用Jackson
        try {
            return InstanceInfo.builder()
                    .instanceId(instanceId)
                    .startTime(System.currentTimeMillis()) // 简化处理
                    .host("unknown")
                    .build();
        } catch (Exception e) {
            return InstanceInfo.builder()
                    .instanceId(instanceId)
                    .startTime(0)
                    .host("unknown")
                    .build();
        }
    }

    public void shutdown() {
        try {
            scheduler.shutdown();

            for (PathChildrenCache cache : watchers.values()) {
                cache.close();
            }

            // 清理实例注册
            String instancePath = basePath + "/instances/" + getCurrentInstanceId();
            if (client.checkExists().forPath(instancePath) != null) {
                client.delete().forPath(instancePath);
            }

        } catch (Exception e) {
            logger.error("Failed to shutdown ZooKeeper rate limiter", e);
        }
    }

    @Data
    @Builder
    @AllArgsConstructor
    public static class InstanceInfo {
        private String instanceId;
        private long startTime;
        private String host;
    }

    @Data
    @AllArgsConstructor
    public static class RateLimitClusterInfo {
        private int instanceCount;
        private List<InstanceInfo> instances;
    }
}
```

## 4. 主流限流组件和框架

### 4.1 Google Guava RateLimiter

#### 4.1.1 基础使用

```java
@Component
public class GuavaRateLimiterService {
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();

    public boolean tryAcquire(String key, double permitsPerSecond) {
        RateLimiter limiter = limiters.computeIfAbsent(key, k ->
            RateLimiter.create(permitsPerSecond));

        return limiter.tryAcquire();
    }

    public boolean tryAcquire(String key, double permitsPerSecond, int permits, long timeout, TimeUnit unit) {
        RateLimiter limiter = limiters.computeIfAbsent(key, k ->
            RateLimiter.create(permitsPerSecond));

        return limiter.tryAcquire(permits, timeout, unit);
    }

    public void acquire(String key, double permitsPerSecond) {
        RateLimiter limiter = limiters.computeIfAbsent(key, k ->
            RateLimiter.create(permitsPerSecond));

        limiter.acquire();
    }

    public void updateRate(String key, double newRate) {
        RateLimiter limiter = limiters.get(key);
        if (limiter != null) {
            limiter.setRate(newRate);
        }
    }
}
```

### 4.2 Alibaba Sentinel

#### 4.2.1 配置和使用

```yaml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080
      datasource:
        flow:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-flow-rules
            groupId: DEFAULT_GROUP
            rule-type: flow
```

```java
@RestController
public class SentinelController {

    @GetMapping("/api/users/{id}")
    @SentinelResource(
        value = "getUserById",
        blockHandler = "handleBlock",
        fallback = "handleFallback"
    )
    public User getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }

    public User handleBlock(Long id, BlockException ex) {
        return User.builder()
                .id(id)
                .name("Limited User")
                .build();
    }

    public User handleFallback(Long id, Throwable ex) {
        return User.builder()
                .id(id)
                .name("Fallback User")
                .build();
    }
}

@Configuration
public class SentinelConfig {

    @PostConstruct
    public void initFlowRules() {
        List<FlowRule> rules = new ArrayList<>();

        FlowRule rule = new FlowRule();
        rule.setResource("getUserById");
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        rule.setCount(100); // 100 QPS
        rule.setStrategy(RuleConstant.STRATEGY_DIRECT);
        rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);

        rules.add(rule);
        FlowRuleManager.loadRules(rules);
    }
}
```

### 4.3 Spring Cloud Gateway

#### 4.3.1 Gateway 限流配置

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: http://localhost:8081
          predicates:
            - Path=/api/users/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10  # 每秒补充10个令牌
                redis-rate-limiter.burstCapacity: 20  # 令牌桶容量20
                redis-rate-limiter.requestedTokens: 1 # 每个请求消耗1个令牌
                key-resolver: "#{@userKeyResolver}"

  redis:
    host: localhost
    port: 6379
```

```java
@Component
public class UserKeyResolver implements KeyResolver {
    @Override
    public Mono<String> resolve(ServerWebExchange exchange) {
        // 基于用户ID限流
        String userId = exchange.getRequest().getHeaders().getFirst("User-Id");
        return Mono.just(userId != null ? userId : "anonymous");
    }
}

@Component
public class IpKeyResolver implements KeyResolver {
    @Override
    public Mono<String> resolve(ServerWebExchange exchange) {
        // 基于IP地址限流
        String ip = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
        return Mono.just(ip);
    }
}

@Configuration
public class GatewayConfig {

    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(10, 20, 1);
    }

    @Bean
    public KeyResolver pathKeyResolver() {
        return exchange -> Mono.just(exchange.getRequest().getPath().value());
    }
}
```

### 4.4 Resilience4j RateLimiter

#### 4.4.1 配置和使用

```yaml
resilience4j:
  ratelimiter:
    instances:
      userService:
        limit-for-period: 100
        limit-refresh-period: 1s
        timeout-duration: 0s
        subscribe-for-events: true
        register-health-indicator: true
      paymentService:
        limit-for-period: 50
        limit-refresh-period: 1s
        timeout-duration: 5s
```

```java
@Component
public class RateLimiterService {

    private final RateLimiterRegistry rateLimiterRegistry;

    public RateLimiterService(RateLimiterRegistry rateLimiterRegistry) {
        this.rateLimiterRegistry = rateLimiterRegistry;
    }

    @RateLimiter(name = "userService")
    public User getUser(Long id) {
        return userService.getUser(id);
    }

    public boolean tryExecute(String rateLimiterName, Runnable operation) {
        RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter(rateLimiterName);

        if (rateLimiter.acquirePermission()) {
            try {
                operation.run();
                return true;
            } finally {
                // 释放许可
            }
        }
        return false;
    }

    public <T> Optional<T> tryExecute(String rateLimiterName, Supplier<T> operation) {
        RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter(rateLimiterName);

        Supplier<T> decoratedSupplier = RateLimiter.decorateSupplier(rateLimiter, operation);

        try {
            return Optional.of(decoratedSupplier.get());
        } catch (RequestNotPermitted e) {
            return Optional.empty();
        }
    }
}
```

## 5. 技术选型考虑因素

### 5.1 业务场景分析

#### 5.1.1 API网关限流

```java
// 多维度限流策略
@Component
public class ApiGatewayRateLimiter {

    public boolean checkRateLimit(HttpServletRequest request) {
        String userId = extractUserId(request);
        String apiPath = request.getRequestURI();
        String clientIp = getClientIp(request);

        // 多层限流检查
        List<RateLimitCheck> checks = Arrays.asList(
            // 全局限流
            new RateLimitCheck("global", 10000, "1s"),
            // API限流
            new RateLimitCheck("api:" + apiPath, 1000, "1s"),
            // 用户限流
            new RateLimitCheck("user:" + userId, 100, "1s"),
            // IP限流
            new RateLimitCheck("ip:" + clientIp, 500, "1s")
        );

        return checks.stream().allMatch(this::checkSingleLimit);
    }
}
```

#### 5.1.2 防刷限流

```java
@Component
public class AntiSpamRateLimiter {

    public boolean checkAntiSpam(String userId, String action) {
        Map<String, RateLimitRule> rules = getAntiSpamRules(action);

        for (Map.Entry<String, RateLimitRule> entry : rules.entrySet()) {
            String key = String.format("%s:%s:%s", userId, action, entry.getKey());
            RateLimitRule rule = entry.getValue();

            if (!rateLimiter.tryAcquire(key, rule.getLimit(), rule.getWindow())) {
                logSpamAttempt(userId, action, key);
                return false;
            }
        }

        return true;
    }

    private Map<String, RateLimitRule> getAntiSpamRules(String action) {
        switch (action) {
            case "login":
                return Map.of(
                    "short", new RateLimitRule(5, "1m"),    // 1分钟5次
                    "medium", new RateLimitRule(20, "1h"),   // 1小时20次
                    "long", new RateLimitRule(100, "1d")     // 1天100次
                );
            case "register":
                return Map.of(
                    "short", new RateLimitRule(1, "1m"),     // 1分钟1次
                    "medium", new RateLimitRule(3, "1h"),    // 1小时3次
                    "long", new RateLimitRule(10, "1d")      // 1天10次
                );
            default:
                return Map.of("default", new RateLimitRule(60, "1m"));
        }
    }
}
```

### 5.2 性能要求分析

#### 5.2.1 高性能场景选型

| 场景 | QPS要求 | 推荐方案 | 理由 |
|------|---------|----------|------|
| 超高并发API网关 | >100万 | 本地限流+预分配 | 减少网络开销 |
| 普通Web应用 | 1万-10万 | Redis分布式限流 | 平衡性能和准确性 |
| 后台任务 | <1万 | 数据库限流 | 持久化，易管理 |
| 实时推荐 | >50万 | 内存限流+异步同步 | 极低延迟要求 |

#### 5.2.2 延迟敏感度分析

```java
@Component
public class LatencyAwareRateLimiter {

    private final Map<String, RateLimiterStrategy> strategies;

    public LatencyAwareRateLimiter() {
        strategies = Map.of(
            "ultra-low", new LocalTokenBucketStrategy(),     // <1ms
            "low", new LocalCounterStrategy(),               // <5ms
            "medium", new RedisLuaStrategy(),               // <20ms
            "high", new DatabaseStrategy()                  // <100ms
        );
    }

    public boolean tryAcquire(String key, String latencyTier) {
        RateLimiterStrategy strategy = strategies.get(latencyTier);
        return strategy.tryAcquire(key);
    }
}
```

### 5.3 一致性要求分析

#### 5.3.1 强一致性 vs 最终一致性

```java
// 强一致性：关键业务场景
public class StrictRateLimiter {
    public boolean tryAcquire(String key, int limit) {
        return databaseRateLimiter.tryAcquireWithLock(key, limit);
    }
}

// 最终一致性：一般业务场景
public class EventualConsistentRateLimiter {
    public boolean tryAcquire(String key, int limit) {
        // 本地预检
        if (!localRateLimiter.tryAcquire(key, limit)) {
            return false;
        }

        // 异步同步到分布式存储
        asyncSyncToRedis(key);
        return true;
    }
}
```

### 5.4 运维复杂度考虑

#### 5.4.1 监控和告警

```java
@Component
public class RateLimiterMonitoring {

    @EventListener
    public void handleRateLimitEvent(RateLimitEvent event) {
        // 记录限流指标
        meterRegistry.counter("rate_limit.requests",
            "key", event.getKey(),
            "result", event.isAllowed() ? "allowed" : "blocked")
            .increment();

        // 记录限流延迟
        meterRegistry.timer("rate_limit.latency",
            "strategy", event.getStrategy())
            .record(event.getLatency(), TimeUnit.MICROSECONDS);

        // 异常情况告警
        if (event.getErrorRate() > 0.1) {
            alertService.sendAlert("高错误率限流", event);
        }
    }
}
```

## 6. 限流策略设计和实施

### 6.1 分层限流架构

```java
@Component
public class HierarchicalRateLimiter {

    private final Map<String, RateLimiterChain> chains;

    public HierarchicalRateLimiter() {
        chains = new HashMap<>();
        initializeChains();
    }

    private void initializeChains() {
        // API网关层
        chains.put("gateway", RateLimiterChain.builder()
            .addLimiter("global", new TokenBucketLimiter(10000, TimeUnit.SECONDS))
            .addLimiter("ip", new SlidingWindowLimiter(1000, 60))
            .build());

        // 应用层
        chains.put("application", RateLimiterChain.builder()
            .addLimiter("user", new TokenBucketLimiter(100, TimeUnit.SECONDS))
            .addLimiter("api", new FixedWindowLimiter(500, 60))
            .build());

        // 数据库层
        chains.put("database", RateLimiterChain.builder()
            .addLimiter("connection", new TokenBucketLimiter(50, TimeUnit.SECONDS))
            .addLimiter("query", new LeakyBucketLimiter(100, TimeUnit.SECONDS))
            .build());
    }

    public boolean tryAcquire(String layer, String key, Map<String, Object> context) {
        RateLimiterChain chain = chains.get(layer);
        return chain != null && chain.tryAcquire(key, context);
    }
}
```

### 6.2 动态限流配置

```java
@Component
public class DynamicRateLimiterConfig {

    private final ConfigurableRateLimiter rateLimiter;
    private final ConfigChangeListener configListener;

    @EventListener
    public void handleConfigChange(ConfigChangeEvent event) {
        if (event.getKey().startsWith("rate-limit.")) {
            updateRateLimitConfig(event);
        }
    }

    private void updateRateLimitConfig(ConfigChangeEvent event) {
        String key = event.getKey();
        String value = event.getNewValue();

        try {
            RateLimitConfig config = parseConfig(value);
            rateLimiter.updateConfig(key, config);

            logger.info("Rate limit config updated: {} = {}", key, config);

            // 发送配置更新事件
            eventPublisher.publishEvent(new RateLimitConfigUpdatedEvent(key, config));

        } catch (Exception e) {
            logger.error("Failed to update rate limit config: {}", key, e);
        }
    }

    private RateLimitConfig parseConfig(String configValue) {
        // 解析配置格式：algorithm=token_bucket;rate=100;capacity=1000;window=60s
        Map<String, String> params = parseParams(configValue);

        return RateLimitConfig.builder()
            .algorithm(params.get("algorithm"))
            .rate(Integer.parseInt(params.getOrDefault("rate", "100")))
            .capacity(Integer.parseInt(params.getOrDefault("capacity", "1000")))
            .windowMs(parseTimeToMs(params.getOrDefault("window", "60s")))
            .build();
    }
}
```

## 7. 最佳实践和常见陷阱

### 7.1 最佳实践

#### 7.1.1 限流键设计

```java
public class RateLimitKeyDesign {

    // 好的实践：层次化的限流键
    public static class GoodKeyDesign {
        public String buildKey(String service, String method, String userId, String clientId) {
            return String.format("%s:%s:%s:%s", service, method, userId, clientId);
        }

        public String buildHierarchicalKey(String... segments) {
            return String.join(":", segments);
        }
    }

    // 避免：过于简单的键设计
    public static class PoorKeyDesign {
        public String buildKey(String userId) {
            return userId; // 无法区分不同的API
        }

        public String buildKey(String api) {
            return api; // 无法区分不同用户
        }
    }
}
```

#### 7.1.2 优雅降级

```java
@Component
public class GracefulRateLimiter {

    public <T> T executeWithRateLimit(String key, Supplier<T> operation,
                                     Supplier<T> fallback,
                                     Function<Exception, T> errorHandler) {
        try {
            if (rateLimiter.tryAcquire(key)) {
                return operation.get();
            } else {
                // 限流触发，执行降级逻辑
                return fallback.get();
            }
        } catch (Exception e) {
            // 限流组件异常，执行错误处理
            logger.error("Rate limiter error for key: {}", key, e);
            return errorHandler.apply(e);
        }
    }

    public CompletableFuture<Void> executeAsync(String key, Runnable operation) {
        return CompletableFuture.runAsync(() -> {
            if (rateLimiter.tryAcquire(key)) {
                operation.run();
            } else {
                // 限流时排队等待
                scheduleForLater(key, operation);
            }
        });
    }
}
```

### 7.2 常见陷阱

#### 7.2.1 时间窗口边界问题

```java
// 错误：固定窗口的突发问题
public class BadFixedWindow {
    public boolean tryAcquire(String key, int limit) {
        long window = System.currentTimeMillis() / 60000; // 分钟级窗口
        String windowKey = key + ":" + window;

        int count = redis.incr(windowKey);
        redis.expire(windowKey, 60);

        return count <= limit; // 窗口边界可能有2倍流量
    }
}

// 正确：滑动窗口避免边界问题
public class GoodSlidingWindow {
    public boolean tryAcquire(String key, int limit, long windowMs) {
        long now = System.currentTimeMillis();

        // 清理过期记录
        redis.zremrangeByScore(key, 0, now - windowMs);

        // 检查当前窗口计数
        long count = redis.zcard(key);
        if (count < limit) {
            redis.zadd(key, now, UUID.randomUUID().toString());
            redis.expire(key, (int) (windowMs / 1000) + 1);
            return true;
        }

        return false;
    }
}
```

#### 7.2.2 分布式限流的数据竞争

```java
// 错误：没有考虑并发安全
public class UnsafeDistributedLimiter {
    public boolean tryAcquire(String key, int limit) {
        int current = redis.get(key);
        if (current < limit) {
            redis.incr(key); // 竞争条件！
            return true;
        }
        return false;
    }
}

// 正确：使用原子操作
public class SafeDistributedLimiter {
    public boolean tryAcquire(String key, int limit) {
        String script =
            "local current = redis.call('GET', KEYS[1]) or 0 " +
            "if tonumber(current) < tonumber(ARGV[1]) then " +
            "  redis.call('INCR', KEYS[1]) " +
            "  return 1 " +
            "else " +
            "  return 0 " +
            "end";

        Long result = redis.eval(script, Collections.singletonList(key),
                                Collections.singletonList(String.valueOf(limit)));

        return result != null && result == 1;
    }
}
```

#### 7.2.3 内存泄漏问题

```java
// 错误：无限制的缓存增长
public class MemoryLeakLimiter {
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();

    public boolean tryAcquire(String key, double rate) {
        RateLimiter limiter = limiters.computeIfAbsent(key, k ->
            RateLimiter.create(rate)); // 永远不清理！

        return limiter.tryAcquire();
    }
}

// 正确：定期清理过期条目
public class MemorySafeLimiter {
    private final Map<String, TimestampedRateLimiter> limiters = new ConcurrentHashMap<>();

    @Scheduled(fixedDelay = 300000) // 5分钟清理一次
    public void cleanupExpiredLimiters() {
        long cutoff = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1);

        limiters.entrySet().removeIf(entry ->
            entry.getValue().getLastUsed() < cutoff);
    }

    public boolean tryAcquire(String key, double rate) {
        TimestampedRateLimiter limiter = limiters.computeIfAbsent(key, k ->
            new TimestampedRateLimiter(RateLimiter.create(rate)));

        limiter.updateLastUsed();
        return limiter.getRateLimiter().tryAcquire();
    }
}
```

## 8. 总结

### 8.1 限流机制的价值

限流是分布式系统稳定性保障的重要手段：

- **系统保护**：防止系统过载，保证服务稳定性
- **资源公平**：确保资源的公平分配和合理使用
- **成本控制**：避免突发流量导致的成本暴增
- **用户体验**：保证核心用户的服务质量

### 8.2 算法选择建议

| 场景 | 推荐算法 | 理由 |
|------|----------|------|
| API网关 | 令牌桶 | 允许突发流量，平滑限流 |
| 防刷保护 | 滑动窗口 | 精确控制时间窗口内的请求数 |
| 流量整形 | 漏桶 | 恒定速率输出，流量平滑 |
| 实时调整 | 自适应算法 | 根据系统状态动态调整 |

### 8.3 技术选型矩阵

| 技术方案 | 性能 | 准确性 | 复杂度 | 适用场景 |
|----------|------|--------|--------|----------|
| 本地限流 | 很高 | 中等 | 低 | 单机应用，延迟敏感 |
| Redis限流 | 高 | 高 | 中等 | 分布式应用，通用场景 |
| 数据库限流 | 中等 | 很高 | 高 | 强一致性要求 |
| ZooKeeper限流 | 中等 | 很高 | 很高 | 配额管理，协调场景 |

### 8.4 实施建议

1. **从简单开始**：优先使用成熟的限流组件
2. **分层设计**：在不同层次实施不同的限流策略
3. **监控优先**：建立完善的限流监控和告警
4. **渐进优化**：根据实际情况逐步优化限流策略
5. **容错设计**：限流组件故障时的降级方案

### 8.5 未来发展趋势

- **智能化限流**：基于AI的自适应限流策略
- **细粒度控制**：更精细的限流维度和策略
- **云原生集成**：与Kubernetes、Service Mesh深度集成
- **边缘计算**：在CDN边缘节点实现限流

限流机制的设计需要权衡性能、准确性、复杂度等多个因素，通过合理的算法选择和系统设计，可以构建出既高效又可靠的限流系统。