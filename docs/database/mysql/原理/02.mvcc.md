---
title: MVCC
date: 2024-10-26
permalink: /mysql/mvcc.html
tags: ['MySQL']
categories:
 - MySQL
---

## 锁和隔离级别

InnoDB 引擎来说，有表锁和行锁。

表锁就是一次操作锁住整张表，这样锁的粒度最大，但是性能也最低，不会出现死锁。

行锁就是一次操作锁住一行，这样锁的粒度小，并发度高，但是会出现死锁。

Innodb的行锁又分为共享锁（读锁）和排它锁（写锁），当一个事务对某一行加了读锁时，允许其他事务对这一行进行读操作，但是不允许进行写操作，也不允许其他事务对这一行执行加写锁，但是可以加读锁。

当一个事务对某一行加了写锁时，不允许其他事务对这一行进行写操作，但是可以读，同时不允许其他事务对这一行加读写锁。

读未提交：一个事务可以读到其他事务还没有提交的数据，会出现脏读。举个例子，有一张工资表，事务A先开启，然后执行查询id为1的员工的工资，假设此时的工资为1000，此时，事务B也开启，执行了更新操作，将id为1的员工工资减少了100，但是并未提交事务。此时再执行事务A的查询操作，可以读到事务B已经更新的数据，如果此时事务B发生回滚，事务A读到的就是“脏”数据。当事务A执行更新操作的话还可能产生幻读的情况。

读已提交：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。还是同样的例子，这次的事务隔离级别为读已提交的情况下，事务B不提交事务的情况下，事务A无法读到事务B更新后的数据，也就避免了脏数据产生。但是，当事务B提交之后，事务A再执行相同的数据，会发现数据变了，这就是所谓的不可重复读，意思就是同一个事务中多次执行相同的查询得到的结果不一致，同时，幻读的情况还是存在。

可重复读：一个事务第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据，这就是可重复读，这种隔离级别解决了不可重复，但是还是会出现幻读。

串行化：这种隔离级别因为对同一条记录的操作都是串行的，所以不会出现脏读、幻读等现象，但是这也就不是并发事务了。

Mysql的undo log
MVCC底层依赖Mysql的undo log，undo log记录了数据库的操作，因为undo log是逻辑日志，可以理解为delete一条记录的时候，undo log会记录一条对应的insert记录，update一条记录的时候，undo log会记录一条相反的update记录，当事务失败需要回滚操作时，就可以通过读取undo log中相应的内容进行回滚，MVCC就利用到了undo log。

undo log分为两种，分别为insert undo log，在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃，还有update undo log，事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除。MVCC利用到的是update undo log。



## MVCC

MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种用于管理并发访问数据库记录的技术，它允许在高并发环境下提高数据库性能的同时，保证数据的一致性和隔离性。MVCC主要在MySQL的InnoDB存储引擎中实现，通过维护数据的多个版本来处理并发读写操作，避免了读写冲突和锁竞争。

### MVCC的工作原理

1. **隐藏列**：InnoDB为每行记录添加了三个隐藏列：
   - **DB_TRX_ID**：记录最后修改该行的事务ID。
   - **DB_ROLL_PTR**：指向undo日志记录的指针，用于支持事务回滚和MVCC。
   - **DB_ROW_ID**：行的唯一标识，用于没有主键的表的聚簇索引。
2. **Undo Log**：Undo日志记录了事务对数据的修改操作，以便在需要时可以将数据恢复到修改前的状态。在MVCC中，Undo日志是支持数据多版本的关键。
3. **Read View**：每个事务在开始时都会生成一个Read View，它包含了该事务启动时刻系统中活跃的读写事务ID列表。Read View用于判断一个数据版本对当前事务是否可见。

### MVCC的可见性判断规则

- 如果数据行的**trx_id**等于当前事务ID，说明数据行是由当前事务修改的，因此该数据行对当前事务可见。
- 如果数据行的**trx_id**小于Read View中的最小活跃事务ID（min_trx_id），说明数据行是由一个已提交的事务修改的，因此该数据行对当前事务可见。
- 如果数据行的**trx_id**大于Read View中的最大活跃事务ID（max_trx_id），说明数据行是由一个将来事务修改的，因此该数据行对当前事务不可见。
- 如果数据行的**trx_id**在Read View的活跃事务ID列表中，则需要通过undo日志找到该数据行的早期版本。

### MVCC在不同隔离级别下的行为

- **READ UNCOMMITTED**：不使用MVCC读，可以读到其他事务修改甚至未提交的数据。
- **READ COMMITTED**：其他事务对数据库的修改，只要已经提交，其修改的结果就是可见的。不完全适用于MVCC读。
- **REPEATABLE READ**：完全适用MVCC，只能读取在它开始之前已经提交的事务对数据库的修改。在它开始以后，所有其他事务对数据库的修改对它来说均不可见。
- **SERIALIZABLE**：完全不适合使用MVCC，所有的query都会加锁，在其之后的事务都要等待。

## 间隙锁

间隙锁（Gap Lock）是MySQL InnoDB存储引擎中的一种特殊锁机制，它锁定的是两个索引记录之间的间隙，或者锁定的是第一个索引记录之前的间隙或最后一个索引记录之后的间隙。这种锁并不直接锁定具体的记录，而是锁定记录之间的空间。间隙锁的主要目的是防止幻读现象，即在一个事务的执行过程中，另一个事务插入新的记录，从而导致前后读取结果不一致的情况 。

在可重复读（REPEATABLE READ）的事务隔离级别下，InnoDB会使用间隙锁来阻止其他事务在间隙之间插入新的记录。例如，当执行一个范围查询时，如 `SELECT * FROM t WHERE id BETWEEN 2 AND 4 FOR UPDATE`，InnoDB不仅会对符合条件的记录加锁，还会锁定这些记录之间的间隙，防止其他事务在这个范围内插入新的记录，从而避免了幻读的问题 。

间隙锁通常在以下情况下使用：

1. **范围查询**：当执行范围查询时，如 `SELECT ... WHERE column BETWEEN A AND B FOR UPDATE`，InnoDB会锁定查询范围内的所有记录以及这些记录之间的间隙。
2. **唯一索引**：当执行唯一索引的插入或更新操作时，如果插入的键值已经存在，InnoDB会锁定该键值以及其前后的间隙，防止其他事务插入相同的键值。

间隙锁的分类：

- **间隙共享锁（gap S-lock）**：允许多个事务在同一间隙添加间隙共享锁。
- **间隙排它锁（gap X-lock）**：防止其他事务在锁定的间隙内插入新的记录。