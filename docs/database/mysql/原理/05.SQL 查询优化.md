---
title: SQL 查询优化器
date: 2025-09-05
permalink: /mysql/sql-select-optimize.html
tags: ['MySQL']
categories:
 - MySQL
---


SQL 解析之后，查询优化器会对 SQL 语句进行优化，这是一个系统性的决策过程，主要包含重写优化、访问路径选择和分组策略选择三个核心环节。

## 重写优化（Query Rewrite Optimization）

重写优化是在不改变查询语义的前提下，通过代数变换和逻辑简化来提升查询效率。

### 常量折叠（Constant Folding）

常量折叠是指编译阶段，在不改变查询语义的前提下，提前计算表达式中所有操作数都是常量的部分，并用计算结果替换原表达式，从而避免程序在运行时再进行这些计算， 提升查询效率。

编译器在语法分析和语义分析阶段（通常在构建抽象语法树 AST 后进行）识别出常量表达式，预先计算其值，然后将结果值直接嵌入到代码中，替换掉原来的表达式。

这里的常量表达式包含​算术表达式、逻辑表达式、位运算，如果函数参数是常量且函数本身是纯函数（无副作用，输出仅依赖于输入），如 sqrt(4.0)，也可能被折叠为 2.0。

比如 `WHERE age > 20+5` → `WHERE age > 25`， `true && false` → `false`, `5 << 2` → `20` 等。

另外在 SQL 查询优化中，MySQL 也会进行常量折叠。例如，查询条件 WHERE column < 256，如果 column 是 TINYINT UNSIGNED 类型（范围 0~255），这个条件会被折叠为 WHERE 1（永真），从而可能优化掉整个过滤条件。

### 谓词下推（Predicate Pushdown）

谓词下推是将查询语句中的过滤条件（WHERE 子句或 JOIN ON 中的部分条件）尽可能向下推，靠近数据源执行。这样可以在查询的早期阶段就过滤掉大量不满足条件的记录，避免这些记录参与昂贵的中间操作（如 JOIN, GROUP BY），从而减少网络传输（分布式环境下）和计算开销。

谓词下推的目的是尽早过滤数据，减少后续处理的数据量。

> 谓词下推和索引下推不是同一件事情，别搞混了

如果谓词中包含不确定性函数（如 RAND()）或某些用户定义函数（UDF），优化器可能不会下推，因为无法保证多次执行结果一致。

应用场景：内连接和外连接。

内连接的谓词下推通常很直接，将条件推至基表扫描阶段或连接前执行。

外连接 (OUTER JOIN)​​ 需要特别注意，否则可能改变查询结果。

​​左外连接 (LEFT JOIN)​​：A LEFT JOIN B ，推 ​​A表（保留表）​​ 的谓词，可直接下推，不影响结果。推 ​​B表（空提供表）​​ 的谓词，不能直接下推到 B 表扫描前，因为这会过滤掉 B 表中本应保留的 NULL 记录。但可以下推到连接操作之后作为过滤条件，或者在某些优化器（如 Hive CBO）支持下，通过更复杂的逻辑安全下推。

```sql
-- 示例表
-- employees(id, name, dept_id, salary)
-- departments(id, dept_name)

-- 原始查询：查询工资大于5000的'Sales'部门员工
SELECT e.name, e.salary, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.id
WHERE e.salary > 5000
AND d.dept_name = 'Sales';

-- 未优化执行流程（简化）：
-- 1. 扫描 employees 表所有数据
-- 2. 扫描 departments 表所有数据
-- 3. 进行 JOIN 操作
-- 4. 对 JOIN 结果应用过滤条件 (salary > 5000 AND dept_name='Sales')

-- 谓词下推优化后可能的执行流程：
-- 1. 扫描 employees 表，同时应用条件 salary > 5000（下推）
-- 2. 扫描 departments 表，同时应用条件 dept_name = 'Sales'（下推）
-- 3. 对过滤后的两个结果集进行 JOIN

-- 另一个例子：LEFT JOIN 中的谓词下推需谨慎
SELECT * 
FROM A 
LEFT JOIN B ON A.id = B.id 
WHERE A.col1 > 10 AND B.col2 < 100; -- A的条件可下推，B的条件在JOIN后过滤
```

### 子查询优化

#### 子查询展开

优化器会对子查询进行优化，将相关子查询转换为 JOIN 操作，例如：

```sql
-- 子查询展开
SELECT e.department, e.position, COUNT(*) as employee_count
FROM employees e
WHERE e.department IN (
    SELECT department FROM departments WHERE location = 'New York'
)
GROUP BY e.department, e.position;
```
MySQL优化器​​很可能​​会尝试将 IN 子查询转换为更高效的 JOIN 操作，其转换后的逻辑可能类似于：

```sql
SELECT e.department, e.position, COUNT(*) as employee_count
FROM employees e
INNER JOIN departments d ON e.department = d.department
WHERE d.location = 'New York'
GROUP BY e.department, e.position;
```
#### 半连接转换

优化器会将 IN 子查询转换为半连接操作，其目的是​​高效地检查主查询中的记录是否在子查询返回的结果中存在​​，且不产生重复记录。

```sql
SELECT * 
FROM departments d 
WHERE d.department_id IN (
    SELECT e.department_id 
    FROM employees e
);
```
MySQL 优化器可能会将上述查询识别为半连接场景，并将其转换成一个更高效的 ​​半连接操作​​，其核心逻辑是：对于 departments 表的每条记录，只要在 employees 表中找到一条匹配的 department_id 记录即返回，且不会因 employees 表有多条相同部门的记录而产生重复，转换后的 SQL 类似于：

```sql
SELECT d.* 
FROM departments d 
SEMI JOIN employees e ON d.department_id = e.department_id;
```

另一种写法是通过 EXISTS，

```sql
SELECT * 
FROM departments d 
WHERE EXISTS (
    SELECT 1 
    FROM employees e 
    WHERE e.department_id = d.department_id
);
```
EXISTS 子查询是半连接的另一种常见写法。对于主查询的每一行，一旦在子查询中​​找到一条匹配​​记录就立即返回 TRUE，并处理下一行。

**反连接转换**

MySQL 中的反连接（Anti Join）是一种用于优化 NOT EXISTS 子查询的策略，其目标是高效地找到主查询中存在而在子查询中不存在匹配的记录。

反连接通常通过​​左外连接​​（Left Outer Join）实现，主查询的表作为左表，子查询中的表作为右表。连接后，那些在右表中​​没有找到匹配行​​（即右表的连接列值为 NULL）的记录，就是最终结果集。

```sql
SELECT * 
FROM departments d 
WHERE NOT EXISTS (
    SELECT 1 
    FROM employees e 
    WHERE e.department_id = d.department_id
);
```
转换后的 SQL 类似于：

```sql
SELECT * 
FROM departments d 
LEFT JOIN employees e ON d.department_id = e.department_id
WHERE e.department_id IS NULL;
```
**标量子查询优化**

标量子查询​​（Scalar Subquery）指的是返回​​单一值​​（单行单列）的子查询，它通常作为查询中的一个列或表达式的一部分出现。

标量子查询的主要​​性能问题​​在于其执行方式：对于主结果集中的​​每一行​​，标量子查询都可能被执行一次，这相当于一种​​嵌套循环连接​​。如果主查询返回的行数很多，或者子查询本身的执行效率不高，整体查询性能就会显著下降。

优化标量子查询的核心思路是​​减少子查询的执行次数​​或​​改变其执行方式​​。

可以用 JOIN 连接​优化

```sql
-- 原始查询
SELECT e.employee_name,
       (SELECT dept_name FROM hr_dept d WHERE d.dept_id = e.dept_id) AS deptname
FROM hr_employee e;

-- 优化后
SELECT e.employee_name, d.dept_name
FROM hr_employee e
LEFT JOIN hr_dept d ON e.dept_id = d.dept_id;
```

当你使用子查询 `(SELECT COUNT(*) FROM ... ) > 0` 来判断是否存在记录时，应优先使用 EXISTS。EXISTS 一旦找到一条匹配记录就会停止扫描，而 COUNT(*) 需要统计所有匹配的行数，效率更高。

```sql
-- 原始 SQL
SELECT * FROM customer
WHERE (SELECT COUNT(*) FROM orders WHERE c_custkey = o_custkey) > 0;

-- 优化后
SELECT * FROM customer
WHERE EXISTS (SELECT 1 FROM orders WHERE c_custkey = o_custkey);
```


## 访问路径选择（Access Path Selection）

优化器需要为每个表选择最优的数据访问方式，包含以下几个方面：

**扫描方式选择**：
  - **全表扫描**：适用于小表或需要访问大部分数据的场景
  - **索引扫描**：包括索引范围扫描、索引全扫描、索引跳跃扫描
  - **索引查找**：基于等值条件的精确查找

**索引选择策略**：
  - **单列索引**：适用于单个字段的 GROUP BY 操作
  - **复合索引**：可同时优化 WHERE、ORDER BY 和 GROUP BY
  - **覆盖索引**：包含所有需要的列，避免回表操作
  - **前缀索引**：对于长字符串字段的优化

**成本估算模型**：
  - **IO 成本**：磁盘读取次数 × IO 成本系数
  - **CPU 成本**：处理行数 × CPU 成本系数
  - **内存成本**：缓冲区使用和内存分配开销
  - **网络成本**：分布式环境下的数据传输成本

## 分组策略选择（Grouping Strategy Selection）

根据数据特征和资源情况选择最适合的分组算法：

- **基于索引的分组（Index-based Grouping）**：
  - **适用场景**：GROUP BY 字段有合适的索引
  - **工作原理**：利用索引的有序性，顺序读取并分组
  - **性能特点**：最高效，无需额外排序，IO 开销最小
  - **限制条件**：需要索引覆盖 GROUP BY 字段

- **基于排序的分组（Sort-based Grouping）**：
  - **适用场景**：没有合适索引，但内存充足
  - **工作原理**：先对数据按 GROUP BY 字段排序，再进行分组聚合
  - **性能特点**：需要额外的排序开销，但分组效率高
  - **内存管理**：使用 sort_buffer_size 控制排序缓冲区

- **基于哈希的分组（Hash-based Grouping）**：
  - **适用场景**：分组数量较少，内存充足
  - **工作原理**：使用哈希表存储分组结果，边扫描边聚合
  - **性能特点**：单次扫描即可完成，但需要足够内存
  - **内存要求**：哈希表大小受 tmp_table_size 限制

## 优化器决策过程

- **统计信息收集**：
  - 表的行数、页数、平均行长度
  - 索引的选择性、高度、叶子页数量
  - 列的数据分布、NULL 值比例、唯一值数量

- **执行计划生成**：
  - 生成多个候选执行计划
  - 为每个计划估算总成本
  - 选择成本最低的执行计划

- **动态调整**：
  - 根据实际执行情况调整成本模型
  - 利用执行统计信息优化后续查询
  - 支持 Hint 语句强制使用特定策略

## 执行阶段详细流程

#### 数据读取

- **索引扫描**：如果存在合适的索引，使用索引快速定位数据
- **全表扫描**：按页读取表数据，应用 WHERE 条件过滤

#### 分组处理

**方式一：基于索引的分组**
- 利用索引的有序性，直接按分组列顺序读取
- 适用于分组列上有索引的情况
- 无需额外排序，性能最优

**方式二：基于排序的分组**
- 先对数据按分组列排序
- 然后扫描排序后的数据进行分组
- 需要临时存储空间

**方式三：基于哈希的分组**
- 使用哈希表存储分组结果
- 适用于分组数量较少的情况
- 内存使用效率高

## 聚合计算

- **增量计算**：边扫描边计算聚合值
- **内存管理**：管理聚合状态的内存使用
- **溢出处理**：当内存不足时写入临时文件

## 结果输出

- 应用 HAVING 条件过滤分组结果
- 按 ORDER BY 子句排序
- 返回最终结果集

