---
title: Group By 的执行原理
date: 2025-09-03
permalink: /mysql/group-by.html
tags: ['MySQL']
categories:
 - MySQL
---

## GROUP BY 的作用和概念

`GROUP BY` 是 SQL 中用于数据分组的重要子句，它将查询结果按照指定的列进行分组，每个分组返回一行结果。GROUP BY 通常与聚合函数（如 COUNT、SUM、AVG、MAX、MIN）配合使用，对每个分组进行统计计算。

### 主要作用

- **数据分组**：将具有相同值的行归为一组
- **聚合计算**：对每个分组进行统计运算
- **数据汇总**：将详细数据转换为汇总报表
- **去重统计**：统计不同值的数量和分布

### 应用场景

- 销售报表：按地区、产品类别统计销售额
- 用户分析：按年龄段、性别统计用户数量
- 日志分析：按时间段统计访问量、错误数
- 库存管理：按仓库、商品类型统计库存

## GROUP BY 语法和用法

### 基本语法

```sql
SELECT column1, aggregate_function(column2)
FROM table_name
WHERE condition
GROUP BY column1, column2, ...
HAVING group_condition
ORDER BY column1, column2, ...;
```

### 单列分组示例

```sql
-- 按部门统计员工数量
SELECT department, COUNT(*) as employee_count
FROM employees
GROUP BY department;

-- 按产品类别统计平均价格
SELECT category, AVG(price) as avg_price
FROM products
GROUP BY category;
```

### 多列分组示例

```sql
-- 按部门和职位统计员工数量
SELECT department, position, COUNT(*) as count
FROM employees
GROUP BY department, position;

-- 按年份和月份统计销售额
SELECT YEAR(order_date) as year, MONTH(order_date) as month, SUM(amount) as total
FROM orders
GROUP BY YEAR(order_date), MONTH(order_date);
```

注意，队列分组时，分组条件一定要在 select 语句中。

### 与 HAVING 子句结合

```sql
-- 查找员工数量超过10人的部门
SELECT department, COUNT(*) as employee_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 10;

-- 查找平均工资超过5000的职位
SELECT position, AVG(salary) as avg_salary
FROM employees
GROUP BY position
HAVING AVG(salary) > 5000;
```

## GROUP BY 执行流程图

![](https://i.imgur.com/ZmQaO1T.png)


### SQL 解析阶段

SQL 解析阶段主要进行词法分析、语法分析、语义分析和权限检查。

词法分析将 SQL 语句分解为关键字、标识符、操作符等，语法分析将这些词法单元组织成语法树（AST），语义分析检查语法是否正确、检查表名、列名是否存在，数据类型是否匹配，权限检查验证用户是否有执行该查询的权限。

### 查询优化阶段

解析之后，查询优化器会对 SQL 语句进行优化，这是一个系统性的决策过程，主要包含重写优化、访问路径选择和分组策略选择三个核心环节。

#### 重写优化（Query Rewrite Optimization）

重写优化是在不改变查询语义的前提下，通过代数变换和逻辑简化来提升查询效率。

**常量折叠（Constant Folding）**

常量折叠是指编译阶段，在不改变查询语义的前提下，提前计算表达式中所有操作数都是常量的部分，并用计算结果替换原表达式，从而避免程序在运行时再进行这些计算， 提升查询效率。

编译器在语法分析和语义分析阶段（通常在构建抽象语法树 AST 后进行）识别出常量表达式，预先计算其值，然后将结果值直接嵌入到代码中，替换掉原来的表达式。

这里的常量表达式包含​算术表达式、逻辑表达式、位运算，如果函数参数是常量且函数本身是纯函数（无副作用，输出仅依赖于输入），如 sqrt(4.0)，也可能被折叠为 2.0。

比如 `WHERE age > 20+5` → `WHERE age > 25`， `true && false` → `false`, `5 << 2` → `20` 等。

另外在 SQL 查询优化中，MySQL 也会进行常量折叠。例如，查询条件 WHERE column < 256，如果 column 是 TINYINT UNSIGNED 类型（范围 0~255），这个条件会被折叠为 WHERE 1（永真），从而可能优化掉整个过滤条件。

**谓词下推（Predicate Pushdown）**

谓词下推是将查询语句中的过滤条件（WHERE 子句或 JOIN ON 中的部分条件）尽可能向下推，靠近数据源执行。这样可以在查询的早期阶段就过滤掉大量不满足条件的记录，避免这些记录参与昂贵的中间操作（如 JOIN, GROUP BY），从而减少网络传输（分布式环境下）和计算开销。

谓词下推的目的是尽早过滤数据，减少后续处理的数据量。

> 谓词下推和索引下推不是同一件事情，别搞混了

如果谓词中包含不确定性函数（如 RAND()）或某些用户定义函数（UDF），优化器可能不会下推，因为无法保证多次执行结果一致。

应用场景：内连接和外连接。

内连接的谓词下推通常很直接，将条件推至基表扫描阶段或连接前执行。

外连接 (OUTER JOIN)​​ 需要特别注意，否则可能改变查询结果。

​​左外连接 (LEFT JOIN)​​：A LEFT JOIN B ，推 ​​A表（保留表）​​ 的谓词，可直接下推，不影响结果。推 ​​B表（空提供表）​​ 的谓词，不能直接下推到 B 表扫描前，因为这会过滤掉 B 表中本应保留的 NULL 记录。但可以下推到连接操作之后作为过滤条件，或者在某些优化器（如 Hive CBO）支持下，通过更复杂的逻辑安全下推。

```sql
-- 示例表
-- employees(id, name, dept_id, salary)
-- departments(id, dept_name)

-- 原始查询：查询工资大于5000的'Sales'部门员工
SELECT e.name, e.salary, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.id
WHERE e.salary > 5000
AND d.dept_name = 'Sales';

-- 未优化执行流程（简化）：
-- 1. 扫描 employees 表所有数据
-- 2. 扫描 departments 表所有数据
-- 3. 进行 JOIN 操作
-- 4. 对 JOIN 结果应用过滤条件 (salary > 5000 AND dept_name='Sales')

-- 谓词下推优化后可能的执行流程：
-- 1. 扫描 employees 表，同时应用条件 salary > 5000（下推）
-- 2. 扫描 departments 表，同时应用条件 dept_name = 'Sales'（下推）
-- 3. 对过滤后的两个结果集进行 JOIN

-- 另一个例子：LEFT JOIN 中的谓词下推需谨慎
SELECT * 
FROM A 
LEFT JOIN B ON A.id = B.id 
WHERE A.col1 > 10 AND B.col2 < 100; -- A的条件可下推，B的条件在JOIN后过滤
```

**子查询优化**

**子查询展开**

优化器会对子查询进行优化，将相关子查询转换为 JOIN 操作，例如：

```sql
-- 子查询展开
SELECT e.department, e.position, COUNT(*) as employee_count
FROM employees e
WHERE e.department IN (
    SELECT department FROM departments WHERE location = 'New York'
)
GROUP BY e.department, e.position;
```
MySQL优化器​​很可能​​会尝试将 IN 子查询转换为更高效的 JOIN 操作，其转换后的逻辑可能类似于：

```sql
SELECT e.department, e.position, COUNT(*) as employee_count
FROM employees e
INNER JOIN departments d ON e.department = d.department
WHERE d.location = 'New York'
GROUP BY e.department, e.position;
```
**半连接转换**

优化器会将 IN 子查询转换为半连接操作，其目的是​​高效地检查主查询中的记录是否在子查询返回的结果中存在​​，且不产生重复记录。

```sql
SELECT * 
FROM departments d 
WHERE d.department_id IN (
    SELECT e.department_id 
    FROM employees e
);
```
MySQL 优化器可能会将上述查询识别为半连接场景，并将其转换成一个更高效的 ​​半连接操作​​，其核心逻辑是：对于 departments 表的每条记录，只要在 employees 表中找到一条匹配的 department_id 记录即返回，且不会因 employees 表有多条相同部门的记录而产生重复，转换后的 SQL 类似于：

```sql
SELECT d.* 
FROM departments d 
SEMI JOIN employees e ON d.department_id = e.department_id;
```

另一种写法是通过 EXISTS，

```sql
SELECT * 
FROM departments d 
WHERE EXISTS (
    SELECT 1 
    FROM employees e 
    WHERE e.department_id = d.department_id
);
```
EXISTS 子查询是半连接的另一种常见写法。对于主查询的每一行，一旦在子查询中​​找到一条匹配​​记录就立即返回 TRUE，并处理下一行。

**反连接转换**

MySQL 中的反连接（Anti Join）是一种用于优化 NOT EXISTS 子查询的策略，其目标是高效地找到主查询中存在而在子查询中不存在匹配的记录。

反连接通常通过​​左外连接​​（Left Outer Join）实现，主查询的表作为左表，子查询中的表作为右表。连接后，那些在右表中​​没有找到匹配行​​（即右表的连接列值为 NULL）的记录，就是最终结果集。

```sql
SELECT * 
FROM departments d 
WHERE NOT EXISTS (
    SELECT 1 
    FROM employees e 
    WHERE e.department_id = d.department_id
);
```
转换后的 SQL 类似于：

```sql
SELECT * 
FROM departments d 
LEFT JOIN employees e ON d.department_id = e.department_id
WHERE e.department_id IS NULL;
```
**标量子查询优化**

标量子查询​​（Scalar Subquery）指的是返回​​单一值​​（单行单列）的子查询，它通常作为查询中的一个列或表达式的一部分出现。

标量子查询的主要​​性能问题​​在于其执行方式：对于主结果集中的​​每一行​​，标量子查询都可能被执行一次，这相当于一种​​嵌套循环连接​​。如果主查询返回的行数很多，或者子查询本身的执行效率不高，整体查询性能就会显著下降。

优化标量子查询的核心思路是​​减少子查询的执行次数​​或​​改变其执行方式​​。

可以用 JOIN 连接​优化

```sql
-- 原始查询
SELECT e.employee_name,
       (SELECT dept_name FROM hr_dept d WHERE d.dept_id = e.dept_id) AS deptname
FROM hr_employee e;

-- 优化后
SELECT e.employee_name, d.dept_name
FROM hr_employee e
LEFT JOIN hr_dept d ON e.dept_id = d.dept_id;
```

当你使用子查询 `(SELECT COUNT(*) FROM ... ) > 0` 来判断是否存在记录时，应优先使用 EXISTS。EXISTS 一旦找到一条匹配记录就会停止扫描，而 COUNT(*) 需要统计所有匹配的行数，效率更高。

```sql
-- 原始 SQL
SELECT * FROM customer
WHERE (SELECT COUNT(*) FROM orders WHERE c_custkey = o_custkey) > 0;

-- 优化后
SELECT * FROM customer
WHERE EXISTS (SELECT 1 FROM orders WHERE c_custkey = o_custkey);
```


#### 访问路径选择（Access Path Selection）

优化器需要为每个表选择最优的数据访问方式，包含以下几个方面：

**扫描方式选择**：
  - **全表扫描**：适用于小表或需要访问大部分数据的场景
  - **索引扫描**：包括索引范围扫描、索引全扫描、索引跳跃扫描
  - **索引查找**：基于等值条件的精确查找

**索引选择策略**：
  - **单列索引**：适用于单个字段的 GROUP BY 操作
  - **复合索引**：可同时优化 WHERE、ORDER BY 和 GROUP BY
  - **覆盖索引**：包含所有需要的列，避免回表操作
  - **前缀索引**：对于长字符串字段的优化

**成本估算模型**：
  - **IO 成本**：磁盘读取次数 × IO 成本系数
  - **CPU 成本**：处理行数 × CPU 成本系数
  - **内存成本**：缓冲区使用和内存分配开销
  - **网络成本**：分布式环境下的数据传输成本

#### 分组策略选择（Grouping Strategy Selection）

根据数据特征和资源情况选择最适合的分组算法：

- **基于索引的分组（Index-based Grouping）**：
  - **适用场景**：GROUP BY 字段有合适的索引
  - **工作原理**：利用索引的有序性，顺序读取并分组
  - **性能特点**：最高效，无需额外排序，IO 开销最小
  - **限制条件**：需要索引覆盖 GROUP BY 字段

- **基于排序的分组（Sort-based Grouping）**：
  - **适用场景**：没有合适索引，但内存充足
  - **工作原理**：先对数据按 GROUP BY 字段排序，再进行分组聚合
  - **性能特点**：需要额外的排序开销，但分组效率高
  - **内存管理**：使用 sort_buffer_size 控制排序缓冲区

- **基于哈希的分组（Hash-based Grouping）**：
  - **适用场景**：分组数量较少，内存充足
  - **工作原理**：使用哈希表存储分组结果，边扫描边聚合
  - **性能特点**：单次扫描即可完成，但需要足够内存
  - **内存要求**：哈希表大小受 tmp_table_size 限制

#### 4. 优化器决策过程

- **统计信息收集**：
  - 表的行数、页数、平均行长度
  - 索引的选择性、高度、叶子页数量
  - 列的数据分布、NULL 值比例、唯一值数量

- **执行计划生成**：
  - 生成多个候选执行计划
  - 为每个计划估算总成本
  - 选择成本最低的执行计划

- **动态调整**：
  - 根据实际执行情况调整成本模型
  - 利用执行统计信息优化后续查询
  - 支持 Hint 语句强制使用特定策略

### 执行阶段详细流程

#### 数据读取

- **索引扫描**：如果存在合适的索引，使用索引快速定位数据
- **全表扫描**：按页读取表数据，应用 WHERE 条件过滤

#### 分组处理

**方式一：基于索引的分组**
- 利用索引的有序性，直接按分组列顺序读取
- 适用于分组列上有索引的情况
- 无需额外排序，性能最优

**方式二：基于排序的分组**
- 先对数据按分组列排序
- 然后扫描排序后的数据进行分组
- 需要临时存储空间

**方式三：基于哈希的分组**
- 使用哈希表存储分组结果
- 适用于分组数量较少的情况
- 内存使用效率高

#### 3.3.3 聚合计算

- **增量计算**：边扫描边计算聚合值
- **内存管理**：管理聚合状态的内存使用
- **溢出处理**：当内存不足时写入临时文件

#### 3.3.4 结果输出

- 应用 HAVING 条件过滤分组结果
- 按 ORDER BY 子句排序
- 返回最终结果集


## 常见问题

### SELECT 字段与 GROUP BY 不匹配

**问题描述**：
```sql
-- 错误示例：SELECT中包含非分组列且非聚合函数
SELECT department, employee_name, COUNT(*)
FROM employees
GROUP BY department;
```

**解决方案**：
```sql
-- 正确写法1：只选择分组列和聚合函数
SELECT department, COUNT(*)
FROM employees
GROUP BY department;

-- 正确写法2：使用ANY_VALUE()函数
SELECT department, ANY_VALUE(employee_name), COUNT(*)
FROM employees
GROUP BY department;
```

### 性能问题：大数据量分组

GROUP BY 和 WHERE 条件中需要使用合适的索引，否则MySQL 会进行全表扫描，产生大量 I/0 消耗。

当需要处理的数据量非常大时，MySQL 可能会使用​​临时表​​来存储中间计算结果。如果内存临时表不够用（由 tmp_table_size 和 max_heap_table_size 参数决定），就会使用​​磁盘临时表​​，其速度会比内存操作慢很多。同时，如果 ORDER BY 和 GROUP BY 的字段不一致或无法利用索引，还可能需要额外的​​文件排序（Filesort）​​，这会增加 CPU 开销。

如果确实是数据量特别大，即使用到了索引也很慢，则需要根据业务场景进行判断，是否可以使用后台任务进行定时计划汇总，进行查询时直接返回已经统计好的数据。

更进一步，则可以考虑使用 ES 或者 Doris 等。

### 内存不足导致磁盘排序

在上面提到，MySQL 可能会使用​​临时表​​来存储中间计算结果，如果内存临时表不够用（由 tmp_table_size 和 max_heap_table_size 参数决定），就会使用​​磁盘临时表。

可以使用  `SHOW STATUS LIKE 'Created_tmp%';` 查看临时表使用情况。




**相关参数**：
- `tmp_table_size`：内存临时表最大大小
- `max_heap_table_size`：MEMORY表最大大小
- `sort_buffer_size`：排序缓冲区大小

### 索引使用不当

**问题示例**：
```sql
-- 分组列顺序与索引列顺序不匹配
CREATE INDEX idx_dept_pos ON employees(department, position);

-- 无法使用索引的分组
SELECT position, department, COUNT(*)
FROM employees
GROUP BY position, department;  -- 顺序不匹配
```

## 6. 优化策略

### 6.1 索引优化

#### 6.1.1 创建合适的索引

```sql
-- 为分组列创建索引
CREATE INDEX idx_department ON employees(department);

-- 创建复合索引（注意列的顺序）
CREATE INDEX idx_dept_pos ON employees(department, position);

-- 创建覆盖索引
CREATE INDEX idx_covering ON employees(department, position, salary);
```

#### 6.1.2 索引列顺序优化

```sql
-- 优化前：索引列顺序与GROUP BY不匹配
CREATE INDEX idx_old ON orders(customer_id, order_date, status);
SELECT status, COUNT(*) FROM orders GROUP BY status;

-- 优化后：调整索引列顺序
CREATE INDEX idx_new ON orders(status, customer_id, order_date);
```

### 6.2 SQL 优化技巧

#### 6.2.1 使用 SQL_BIG_RESULT 提示

```sql
-- 对于大结果集，提示MySQL使用磁盘临时表
SELECT SQL_BIG_RESULT department, COUNT(*)
FROM employees
GROUP BY department;
```

#### 6.2.2 限制结果集大小

```sql
-- 使用LIMIT减少结果集
SELECT department, COUNT(*) as cnt
FROM employees
GROUP BY department
ORDER BY cnt DESC
LIMIT 10;
```

#### 6.2.3 预过滤数据

```sql
-- 在GROUP BY前先过滤数据
SELECT department, COUNT(*)
FROM employees
WHERE hire_date >= '2020-01-01'  -- 预过滤
GROUP BY department;
```

### 6.3 分区表优化

```sql
-- 创建分区表
CREATE TABLE sales (
    id INT,
    sale_date DATE,
    amount DECIMAL(10,2),
    region VARCHAR(50)
) PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023)
);

-- 分区裁剪优化GROUP BY
SELECT region, SUM(amount)
FROM sales
WHERE sale_date >= '2022-01-01'
GROUP BY region;
```

### 6.4 硬件和配置优化

#### 6.4.1 内存配置

```sql
-- 调整相关参数
SET GLOBAL tmp_table_size = 256*1024*1024;        -- 256MB
SET GLOBAL max_heap_table_size = 256*1024*1024;   -- 256MB
SET GLOBAL sort_buffer_size = 2*1024*1024;        -- 2MB
SET GLOBAL read_buffer_size = 1*1024*1024;        -- 1MB
```

#### 6.4.2 并行处理

```sql
-- 启用并行查询（MySQL 8.0+）
SET SESSION innodb_parallel_read_threads = 4;
```

## 7. 性能监控和诊断

### 7.1 使用 EXPLAIN 分析

```sql
EXPLAIN FORMAT=JSON
SELECT department, COUNT(*)
FROM employees
GROUP BY department;
```

**关键指标**：
- `using_temporary_table`：是否使用临时表
- `using_filesort`：是否使用文件排序
- `rows_examined`：扫描行数
- `cost_info`：执行成本

### 7.2 性能监控查询

```sql
-- 查看临时表使用情况
SHOW STATUS LIKE 'Created_tmp%';

-- 查看排序使用情况
SHOW STATUS LIKE 'Sort%';

-- 查看慢查询
SHOW VARIABLES LIKE 'slow_query_log';
SHOW VARIABLES LIKE 'long_query_time';
```

### 7.3 Performance Schema 监控

```sql
-- 查看语句统计
SELECT * FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%GROUP BY%'
ORDER BY AVG_TIMER_WAIT DESC;

-- 查看临时表统计
SELECT * FROM performance_schema.events_statements_current
WHERE SQL_TEXT LIKE '%GROUP BY%';
```

## 8. 最佳实践总结

### 8.1 设计阶段

1. **合理设计索引**：为常用的分组列创建索引
2. **考虑分区策略**：对于大表考虑分区设计
3. **选择合适的数据类型**：使用较小的数据类型减少内存使用

### 8.2 开发阶段

1. **遵循SQL规范**：SELECT列必须在GROUP BY中或使用聚合函数
2. **合理使用WHERE**：在GROUP BY前过滤数据
3. **注意列顺序**：GROUP BY列顺序与索引列顺序保持一致
4. **适当使用LIMIT**：限制结果集大小

### 8.3 运维阶段

1. **监控性能指标**：关注临时表和排序的使用情况
2. **定期分析慢查询**：识别和优化性能问题
3. **调整配置参数**：根据业务需求调整内存参数
4. **维护索引**：定期检查和优化索引使用情况

### 8.4 优化检查清单

- [ ] 是否为分组列创建了合适的索引？
- [ ] GROUP BY列顺序是否与索引列顺序一致？
- [ ] 是否在GROUP BY前进行了数据过滤？
- [ ] 是否使用了覆盖索引避免回表？
- [ ] 临时表使用是否在合理范围内？
- [ ] 内存配置是否满足业务需求？
- [ ] 是否考虑了分区表优化？
- [ ] 查询结果集大小是否合理？

通过遵循这些最佳实践，可以显著提升 GROUP BY 查询的性能，确保数据库系统的高效运行。


