---
title: Group By 的执行原理
date: 2025-09-03
permalink: /mysql/group-by.html
tags: ['MySQL']
categories:
 - MySQL
---

## GROUP BY 的作用和概念

`GROUP BY` 是 SQL 中用于数据分组的重要子句，它将查询结果按照指定的列进行分组，每个分组返回一行结果。GROUP BY 通常与聚合函数（如 COUNT、SUM、AVG、MAX、MIN）配合使用，对每个分组进行统计计算。

### 主要作用

- **数据分组**：将具有相同值的行归为一组
- **聚合计算**：对每个分组进行统计运算
- **数据汇总**：将详细数据转换为汇总报表
- **去重统计**：统计不同值的数量和分布

### 应用场景

- 销售报表：按地区、产品类别统计销售额
- 用户分析：按年龄段、性别统计用户数量
- 日志分析：按时间段统计访问量、错误数
- 库存管理：按仓库、商品类型统计库存

## GROUP BY 语法和用法

### 基本语法

```sql
SELECT column1, aggregate_function(column2)
FROM table_name
WHERE condition
GROUP BY column1, column2, ...
HAVING group_condition
ORDER BY column1, column2, ...;
```

### 单列分组示例

```sql
-- 按部门统计员工数量
SELECT department, COUNT(*) as employee_count
FROM employees
GROUP BY department;

-- 按产品类别统计平均价格
SELECT category, AVG(price) as avg_price
FROM products
GROUP BY category;
```

### 多列分组示例

```sql
-- 按部门和职位统计员工数量
SELECT department, position, COUNT(*) as count
FROM employees
GROUP BY department, position;

-- 按年份和月份统计销售额
SELECT YEAR(order_date) as year, MONTH(order_date) as month, SUM(amount) as total
FROM orders
GROUP BY YEAR(order_date), MONTH(order_date);
```

注意，队列分组时，分组条件一定要在 select 语句中。

### 与 HAVING 子句结合

```sql
-- 查找员工数量超过10人的部门
SELECT department, COUNT(*) as employee_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 10;

-- 查找平均工资超过5000的职位
SELECT position, AVG(salary) as avg_salary
FROM employees
GROUP BY position
HAVING AVG(salary) > 5000;
```

## GROUP BY 执行流程图

![](https://i.imgur.com/ZmQaO1T.png)

## 常见问题

### SELECT 字段与 GROUP BY 不匹配

```sql
-- 错误示例：SELECT中包含非分组列且非聚合函数
SELECT department, employee_name, COUNT(*)
FROM employees
GROUP BY department;

-- 正确写法1：只选择分组列和聚合函数
SELECT department, COUNT(*)
FROM employees
GROUP BY department;

-- 正确写法2：使用ANY_VALUE()函数
SELECT department, ANY_VALUE(employee_name), COUNT(*)
FROM employees
GROUP BY department;
```

### 性能问题：大数据量分组

GROUP BY 和 WHERE 条件中需要使用合适的索引，否则MySQL 会进行全表扫描，产生大量 I/0 消耗。

当需要处理的数据量非常大时，MySQL 可能会使用​​临时表​​来存储中间计算结果。如果内存临时表不够用（由 tmp_table_size 和 max_heap_table_size 参数决定），就会使用​​磁盘临时表​​，其速度会比内存操作慢很多。同时，如果 ORDER BY 和 GROUP BY 的字段不一致或无法利用索引，还可能需要额外的​​文件排序（Filesort）​​，这会增加 CPU 开销。

可以使用 `LIMIT` 限制结果集大小，避免返回大量数据。

```sql
-- 使用LIMIT减少结果集
SELECT department, COUNT(*) as cnt
FROM employees
GROUP BY department
ORDER BY cnt DESC
LIMIT 10;
```

也可以使用 `WHERE` 子句进行预过滤，避免对所有数据进行分组。

```sql
-- 在GROUP BY前先过滤数据
SELECT department, COUNT(*)
FROM employees
WHERE hire_date >= '2020-01-01'  -- 预过滤
GROUP BY department;
```

也可以创建分区表，根据特定字段进行分区，这样在查询时可以根据分区字段进行裁剪，避免扫描全表。

```sql
-- 创建分区表
CREATE TABLE sales (
    id INT,
    sale_date DATE,
    amount DECIMAL(10,2),
    region VARCHAR(50)
) PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023)
);

-- 分区裁剪优化GROUP BY
SELECT region, SUM(amount)
FROM sales
WHERE sale_date >= '2022-01-01'
GROUP BY region;
```

如果确实是数据量特别大，即使用到了索引也很慢，则需要根据业务场景进行判断，是否可以使用后台任务进行定时计划汇总，进行查询时直接返回已经统计好的数据。

更进一步，则可以考虑使用 ES 或者 Doris 等。

### 内存不足导致磁盘排序

在上面提到，MySQL 可能会使用​​临时表​​来存储中间计算结果，如果内存临时表不够用（由 tmp_table_size 和 max_heap_table_size 参数决定），就会使用​​磁盘临时表。

- `tmp_table_size`：内存临时表最大大小
- `max_heap_table_size`：MEMORY表最大大小
- `sort_buffer_size`：排序缓冲区大小

可以使用  `SHOW STATUS LIKE 'Created_tmp%';` 查看临时表使用情况。

![](https://i.imgur.com/lnmas4x.png)

执行 SHOW STATUS LIKE 'Created_tmp%' 通常会返回以下三个关键状态变量:

Created_tmp_tables： MySQL服务器启动后，​​在内存中创建的临时表的总数量​​（即使之后转到了磁盘）

Created_tmp_disk_tables： MySQL服务器启动后，​​在磁盘上创建的临时表的总数量

Created_tmp_files：MySQL服务器创建的​​临时文件的数量​​（注意：是文件，并非全是表）

临时表，尤其是磁盘临时表，是常见的性能瓶颈。理想情况下，磁盘临时表占总临时表的比例 ​​应尽可能低，通常建议控制在25%以下，可以通过以下公式进行计算：

```sql
Created_tmp_disk_tables / Created_tmp_tables * 100%
```

如果这个比例持续很高，说明很多复杂操作（如 GROUP BY、ORDER BY、DISTINCT、多表 JOIN 或子查询）无法在内存中完成，需要写入磁盘，这会显著影响性能。

如果磁盘临时表比例过高，一个直接的应对方法是增大 tmp_table_size 和 max_heap_table_size 这两个参数的值，让MySQL能在内存中容纳更大的临时表。但要注意，​​这两个参数是 per-connection 的​​，如果有大量并发连接，盲目调得太大可能导致内存耗尽。

```sql
-- 查看当前tmp_table_size和max_heap_table_size的配置大小
SHOW VARIABLES LIKE 'tmp_table_size';
SHOW VARIABLES LIKE 'max_heap_table_size';
```

最好的方式是从 SQL 优化的角度出发，使用 EXPLAIN 命令分析慢查询，留意 Extra 列中是否出现 ​​Using temporary（使用临时表）​​ 和 ​​Using filesort（使用文件排序），合理使用索引，减少临时表和文件排序的使用。


### 索引使用不当

#### 创建合适的索引

```sql
-- 为分组列创建索引
CREATE INDEX idx_department ON employees(department);

-- 创建复合索引（注意列的顺序）
CREATE INDEX idx_dept_pos ON employees(department, position);

-- 创建覆盖索引
CREATE INDEX idx_covering ON employees(department, position, salary);
```
#### 索引列顺序优化

```sql
-- 优化前：索引列顺序与GROUP BY不匹配
CREATE INDEX idx_old ON orders(customer_id, order_date, status);
SELECT status, COUNT(*) FROM orders GROUP BY status;

-- 优化后：调整索引列顺序
CREATE INDEX idx_new ON orders(status, customer_id, order_date);
```

## 性能监控和诊断

使用 Performance Schema 监控 GROUP BY 的执行效率。

```sql
-- 查看语句统计
SELECT * FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%GROUP BY%'
ORDER BY AVG_TIMER_WAIT DESC;

-- 查看临时表统计
SELECT * FROM performance_schema.events_statements_current
WHERE SQL_TEXT LIKE '%GROUP BY%';
```

## 优化检查清单

- [ ] 是否为分组列创建了合适的索引？
- [ ] GROUP BY列顺序是否与索引列顺序一致？
- [ ] 是否在GROUP BY前进行了数据过滤？
- [ ] 是否使用了覆盖索引避免回表？
- [ ] 临时表使用是否在合理范围内？
- [ ] 内存配置是否满足业务需求？
- [ ] 是否考虑了分区表优化？
- [ ] 查询结果集大小是否合理？

