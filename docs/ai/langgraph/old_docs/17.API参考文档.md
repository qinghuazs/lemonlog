---
title: LangGraph API 参考文档
date: 2025-01-30
permalink: /ai/langgraph/api-reference.html
tags:
  - AI
  - LangGraph
  - API
categories:
  - AI
  - LangGraph
---

# LangGraph API 参考文档

## 一、核心类与接口

### 1.1 StateGraph

#### 类定义
```python
class StateGraph(Generic[State]):
    """
    状态图的核心类，用于构建和管理工作流图。

    Parameters:
        state_schema: Type[State] - 状态的类型定义
        config_schema: Optional[Type[Config]] - 配置的类型定义
    """

    def __init__(
        self,
        state_schema: Type[State],
        config_schema: Optional[Type[Config]] = None
    ):
        pass
```

#### 主要方法

##### add_node()
```python
def add_node(
    self,
    node: str,
    action: Union[Callable, Runnable],
    *,
    metadata: Optional[Dict[str, Any]] = None,
    retry_policy: Optional[RetryPolicy] = None
) -> None:
    """
    添加节点到图中。

    Args:
        node: 节点的唯一标识符
        action: 节点执行的函数或可运行对象
        metadata: 节点的元数据
        retry_policy: 重试策略

    Example:
        graph.add_node("process", process_function)
        graph.add_node("validate", ValidationRunnable())
    """
```

##### add_edge()
```python
def add_edge(
    self,
    start_node: str,
    end_node: str,
    *,
    condition: Optional[Callable] = None,
    metadata: Optional[Dict] = None
) -> None:
    """
    添加从一个节点到另一个节点的边。

    Args:
        start_node: 起始节点标识符
        end_node: 结束节点标识符
        condition: 可选的条件函数
        metadata: 边的元数据

    Example:
        graph.add_edge("start", "process")
        graph.add_edge("process", "end", condition=lambda s: s["success"])
    """
```

##### add_conditional_edges()
```python
def add_conditional_edges(
    self,
    source: str,
    path: Callable[[State], str],
    path_map: Optional[Dict[str, str]] = None,
    *,
    then: Optional[str] = None
) -> None:
    """
    添加条件边，根据路径函数的返回值决定下一个节点。

    Args:
        source: 源节点标识符
        path: 返回下一个节点标识符的函数
        path_map: 路径映射字典
        then: 默认的下一个节点

    Example:
        graph.add_conditional_edges(
            "router",
            route_function,
            {
                "option1": "node1",
                "option2": "node2",
                "default": END
            }
        )
    """
```

##### set_entry_point()
```python
def set_entry_point(
    self,
    node: str
) -> None:
    """
    设置图的入口点。

    Args:
        node: 入口节点的标识符

    Example:
        graph.set_entry_point("start")
    """
```

##### set_finish_point()
```python
def set_finish_point(
    self,
    node: str
) -> None:
    """
    设置图的结束点。

    Args:
        node: 结束节点的标识符

    Example:
        graph.set_finish_point("end")
    """
```

##### compile()
```python
def compile(
    self,
    *,
    checkpointer: Optional[BaseCheckpointer] = None,
    interrupt_before: Optional[List[str]] = None,
    interrupt_after: Optional[List[str]] = None,
    debug: bool = False
) -> CompiledGraph:
    """
    编译图为可执行的工作流。

    Args:
        checkpointer: 检查点管理器
        interrupt_before: 在这些节点前中断
        interrupt_after: 在这些节点后中断
        debug: 是否启用调试模式

    Returns:
        CompiledGraph: 编译后的图

    Example:
        app = graph.compile(
            checkpointer=MemorySaver(),
            interrupt_before=["human_review"]
        )
    """
```

### 1.2 MessageGraph

```python
class MessageGraph(StateGraph[List[BaseMessage]]):
    """
    专门用于处理消息的状态图。

    自动管理消息列表状态，简化对话流程的构建。
    """

    def __init__(self):
        super().__init__(List[BaseMessage])
```

#### 使用示例
```python
from langgraph.graph import MessageGraph
from langchain.schema import HumanMessage, AIMessage

graph = MessageGraph()

def chatbot(messages: List[BaseMessage]) -> List[BaseMessage]:
    # 处理消息并返回响应
    return messages + [AIMessage(content="Hello!")]

graph.add_node("chatbot", chatbot)
graph.set_entry_point("chatbot")
graph.set_finish_point("chatbot")

app = graph.compile()
```

### 1.3 END 常量

```python
END: str = "__end__"
"""
特殊常量，表示图的结束。
在条件路由中使用，指示工作流应该终止。

Example:
    graph.add_conditional_edges(
        "decide",
        lambda x: "continue" if x["retry"] else END
    )
"""
```

## 二、状态管理

### 2.1 State 类型定义

#### TypedDict 方式
```python
from typing import TypedDict, List, Annotated
import operator

class AgentState(TypedDict):
    """基础状态定义"""
    messages: List[str]
    current_step: int
    metadata: dict

class AnnotatedState(TypedDict):
    """带注解的状态定义，支持reducer函数"""
    messages: Annotated[List[str], operator.add]  # 自动追加
    count: Annotated[int, operator.add]  # 自动累加
    latest: Annotated[str, lambda x, y: y]  # 总是使用最新值
```

#### Pydantic 方式
```python
from pydantic import BaseModel, Field
from typing import Optional

class PydanticState(BaseModel):
    """使用 Pydantic 定义状态，提供验证和序列化"""
    messages: List[str] = Field(default_factory=list)
    user_id: str = Field(..., description="用户标识")
    session_id: Optional[str] = None

    class Config:
        schema_extra = {
            "example": {
                "messages": ["Hello"],
                "user_id": "user123"
            }
        }
```

### 2.2 Reducer 函数

```python
from typing import Any

def custom_reducer(old_value: Any, new_value: Any) -> Any:
    """
    自定义 reducer 函数，用于合并状态更新。

    Args:
        old_value: 当前状态值
        new_value: 新的状态值

    Returns:
        合并后的状态值
    """
    if isinstance(old_value, list) and isinstance(new_value, list):
        return old_value + new_value
    return new_value

# 使用示例
class CustomState(TypedDict):
    data: Annotated[List[dict], custom_reducer]
```

## 三、检查点（Checkpointing）

### 3.1 BaseCheckpointer

```python
from langgraph.checkpoint.base import BaseCheckpointer
from typing import Optional, Dict, Any

class BaseCheckpointer(ABC):
    """
    检查点基类，用于保存和恢复状态。
    """

    @abstractmethod
    async def aget(
        self,
        config: RunnableConfig
    ) -> Optional[Checkpoint]:
        """异步获取检查点"""
        pass

    @abstractmethod
    async def aput(
        self,
        config: RunnableConfig,
        checkpoint: Checkpoint,
        metadata: Optional[Dict[str, Any]] = None
    ) -> RunnableConfig:
        """异步保存检查点"""
        pass

    @abstractmethod
    def get(
        self,
        config: RunnableConfig
    ) -> Optional[Checkpoint]:
        """同步获取检查点"""
        pass

    @abstractmethod
    def put(
        self,
        config: RunnableConfig,
        checkpoint: Checkpoint,
        metadata: Optional[Dict[str, Any]] = None
    ) -> RunnableConfig:
        """同步保存检查点"""
        pass
```

### 3.2 MemorySaver

```python
from langgraph.checkpoint.memory import MemorySaver

# 创建内存检查点
memory = MemorySaver()

# 在编译时使用
app = graph.compile(checkpointer=memory)

# 使用会话ID运行
config = {"configurable": {"thread_id": "session-123"}}
result = app.invoke(input_data, config=config)
```

### 3.3 SqliteSaver

```python
from langgraph.checkpoint.sqlite import SqliteSaver

# 创建 SQLite 检查点
checkpointer = SqliteSaver.from_conn_string("checkpoint.db")

# 或使用内存数据库
checkpointer = SqliteSaver.from_conn_string(":memory:")

app = graph.compile(checkpointer=checkpointer)
```

### 3.4 PostgresSaver

```python
from langgraph.checkpoint.postgres import PostgresSaver
import psycopg2

# 创建 PostgreSQL 连接
conn = psycopg2.connect(
    "postgresql://user:password@localhost:5432/dbname"
)

# 创建检查点
checkpointer = PostgresSaver(conn)

# 初始化表结构
checkpointer.setup()

app = graph.compile(checkpointer=checkpointer)
```

## 四、工具与函数

### 4.1 工具装饰器

```python
from langgraph.prebuilt import tool

@tool
def search_tool(query: str) -> str:
    """
    搜索工具示例。

    Args:
        query: 搜索查询

    Returns:
        搜索结果
    """
    return f"Results for: {query}"

# 带参数验证的工具
@tool(args_schema=SearchSchema)
def advanced_search(
    query: str,
    filters: Optional[Dict] = None
) -> List[Dict]:
    """高级搜索工具"""
    pass
```

### 4.2 ToolExecutor

```python
from langgraph.prebuilt import ToolExecutor
from langchain.tools import Tool

# 创建工具列表
tools = [
    Tool(name="search", func=search_func, description="Search tool"),
    Tool(name="calculator", func=calc_func, description="Math tool")
]

# 创建执行器
tool_executor = ToolExecutor(tools)

# 在节点中使用
def execute_tools(state):
    tool_calls = state["tool_calls"]
    results = tool_executor.batch(tool_calls)
    return {"tool_results": results}
```

## 五、预构建组件

### 5.1 create_react_agent

```python
from langgraph.prebuilt import create_react_agent
from langchain_openai import ChatOpenAI

# 创建 ReAct 智能体
agent = create_react_agent(
    llm=ChatOpenAI(model="gpt-4"),
    tools=tools,
    state_modifier="You are a helpful assistant."
)

# 运行智能体
result = agent.invoke({
    "messages": [HumanMessage(content="What's the weather?")]
})
```

### 5.2 ToolNode

```python
from langgraph.prebuilt import ToolNode

# 创建工具节点
tool_node = ToolNode(tools)

# 在图中使用
graph.add_node("tools", tool_node)
graph.add_edge("agent", "tools")
```

## 六、运行时配置

### 6.1 RunnableConfig

```python
from langchain.schema.runnable import RunnableConfig

config = RunnableConfig(
    # 线程/会话 ID
    configurable={
        "thread_id": "session-123",
        "user_id": "user-456"
    },
    # 标签
    tags=["production", "v1"],
    # 元数据
    metadata={
        "source": "api",
        "version": "1.0.0"
    },
    # 回调
    callbacks=[CustomCallback()],
    # 递归限制
    recursion_limit=25,
    # 最大并发
    max_concurrency=5
)

# 使用配置运行
result = app.invoke(input_data, config=config)
```

### 6.2 中断配置

```python
# 在特定节点前中断
app = graph.compile(
    interrupt_before=["human_review", "critical_decision"]
)

# 在特定节点后中断
app = graph.compile(
    interrupt_after=["data_collection", "processing"]
)

# 恢复执行
config = {"configurable": {"thread_id": "session-123"}}
# 获取当前状态
state = app.get_state(config)
# 更新状态并继续
app.update_state(config, {"approved": True})
result = app.invoke(None, config)  # 继续执行
```

## 七、流式处理

### 7.1 stream()

```python
# 流式处理
async for chunk in app.astream(input_data, config):
    print(f"Node: {chunk.get('node')}")
    print(f"Data: {chunk.get('data')}")
```

### 7.2 stream_events()

```python
# 流式事件
async for event in app.astream_events(
    input_data,
    config,
    version="v1"
):
    if event["event"] == "on_node_start":
        print(f"Starting node: {event['name']}")
    elif event["event"] == "on_node_end":
        print(f"Completed node: {event['name']}")
```

## 八、异步支持

### 8.1 异步方法

```python
# 异步调用
result = await app.ainvoke(input_data, config)

# 异步批处理
results = await app.abatch([input1, input2, input3])

# 异步流式处理
async for chunk in app.astream(input_data):
    process_chunk(chunk)
```

### 8.2 异步节点

```python
async def async_node(state: State) -> State:
    """异步节点函数"""
    result = await external_api_call(state["data"])
    return {"result": result}

graph.add_node("async_process", async_node)
```

## 九、错误处理

### 9.1 错误捕获

```python
from langgraph.errors import GraphRecursionError, NodeError

try:
    result = app.invoke(input_data)
except GraphRecursionError as e:
    print(f"递归限制错误: {e}")
except NodeError as e:
    print(f"节点执行错误: {e.node} - {e.error}")
except Exception as e:
    print(f"未知错误: {e}")
```

### 9.2 重试策略

```python
from langgraph.types import RetryPolicy

retry_policy = RetryPolicy(
    max_attempts=3,
    initial_interval=1.0,
    max_interval=10.0,
    exponential_base=2.0,
    retry_on_error=lambda e: not isinstance(e, ValueError)
)

graph.add_node(
    "risky_node",
    risky_function,
    retry_policy=retry_policy
)
```

## 十、高级功能

### 10.1 子图

```python
# 创建子图
subgraph = StateGraph(SubState)
subgraph.add_node("sub_process", sub_function)
subgraph.set_entry_point("sub_process")
subgraph.set_finish_point("sub_process")

# 编译子图
sub_app = subgraph.compile()

# 在主图中使用
graph.add_node("subworkflow", sub_app)
```

### 10.2 并行执行

```python
from langgraph.graph import StateGraph, END

def parallel_branch_1(state):
    # 分支 1 逻辑
    return {"branch1_result": "done"}

def parallel_branch_2(state):
    # 分支 2 逻辑
    return {"branch2_result": "done"}

# 创建并行分支
graph.add_node("branch1", parallel_branch_1)
graph.add_node("branch2", parallel_branch_2)
graph.add_edge("start", "branch1")
graph.add_edge("start", "branch2")
graph.add_edge("branch1", "merge")
graph.add_edge("branch2", "merge")
```

### 10.3 动态图构建

```python
def build_dynamic_graph(config: Dict) -> StateGraph:
    """根据配置动态构建图"""
    graph = StateGraph(DynamicState)

    # 根据配置添加节点
    for node_config in config["nodes"]:
        graph.add_node(
            node_config["id"],
            node_config["function"]
        )

    # 根据配置添加边
    for edge_config in config["edges"]:
        graph.add_edge(
            edge_config["from"],
            edge_config["to"]
        )

    return graph
```

## 十一、调试与监控

### 11.1 调试模式

```python
# 启用调试
app = graph.compile(debug=True)

# 设置日志级别
import logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("langgraph")
```

### 11.2 状态检查

```python
# 获取当前状态
state = app.get_state(config)
print(f"Current values: {state.values}")
print(f"Next nodes: {state.next}")
print(f"Checkpoint: {state.checkpoint}")

# 获取状态历史
history = app.get_state_history(config)
for state in history:
    print(f"Checkpoint {state.checkpoint}: {state.values}")
```

### 11.3 性能分析

```python
import time
from contextlib import contextmanager

@contextmanager
def timing(name: str):
    """性能计时器"""
    start = time.time()
    yield
    end = time.time()
    print(f"{name} took {end - start:.2f} seconds")

# 使用计时器
with timing("Graph execution"):
    result = app.invoke(input_data)
```

## 十二、最佳实践示例

### 12.1 完整应用示例

```python
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from typing import TypedDict, Annotated, List
import operator

# 定义状态
class AppState(TypedDict):
    messages: Annotated[List[str], operator.add]
    processed: bool
    error: Optional[str]

# 定义节点函数
def validate_input(state: AppState) -> AppState:
    """验证输入"""
    if not state.get("messages"):
        return {"error": "No input provided"}
    return {"processed": False}

def process_data(state: AppState) -> AppState:
    """处理数据"""
    if state.get("error"):
        return state
    # 处理逻辑
    processed_messages = [f"Processed: {msg}" for msg in state["messages"]]
    return {
        "messages": processed_messages,
        "processed": True
    }

def route_decision(state: AppState) -> str:
    """路由决策"""
    if state.get("error"):
        return "error_handler"
    elif state["processed"]:
        return "success"
    else:
        return "process"

# 构建图
def build_app():
    graph = StateGraph(AppState)

    # 添加节点
    graph.add_node("validate", validate_input)
    graph.add_node("process", process_data)
    graph.add_node("error_handler", lambda s: {"error": f"Error: {s['error']}"})
    graph.add_node("success", lambda s: s)

    # 添加边
    graph.add_edge("validate", "router")
    graph.add_conditional_edges(
        "router",
        route_decision,
        {
            "process": "process",
            "error_handler": "error_handler",
            "success": "success"
        }
    )
    graph.add_edge("process", "success")
    graph.add_edge("error_handler", END)
    graph.add_edge("success", END)

    # 设置入口
    graph.set_entry_point("validate")

    # 编译
    return graph.compile(
        checkpointer=MemorySaver(),
        interrupt_before=["process"]
    )

# 使用应用
app = build_app()
config = {"configurable": {"thread_id": "test-session"}}

# 运行
result = app.invoke(
    {"messages": ["Hello", "World"]},
    config=config
)

print(result)
```

## 十三、API 速查表

### 13.1 常用导入

```python
# 核心
from langgraph.graph import StateGraph, MessageGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.checkpoint.sqlite import SqliteSaver

# 类型
from typing import TypedDict, Annotated, List, Optional
import operator

# 预构建
from langgraph.prebuilt import create_react_agent, ToolNode, tool

# 错误
from langgraph.errors import GraphRecursionError, NodeError
```

### 13.2 快速参考

| 方法 | 描述 | 示例 |
|------|------|------|
| `add_node()` | 添加节点 | `graph.add_node("name", function)` |
| `add_edge()` | 添加边 | `graph.add_edge("from", "to")` |
| `add_conditional_edges()` | 条件路由 | `graph.add_conditional_edges("node", func, mapping)` |
| `set_entry_point()` | 设置入口 | `graph.set_entry_point("start")` |
| `compile()` | 编译图 | `app = graph.compile()` |
| `invoke()` | 同步执行 | `result = app.invoke(input)` |
| `ainvoke()` | 异步执行 | `result = await app.ainvoke(input)` |
| `stream()` | 流式处理 | `for chunk in app.stream(input): ...` |
| `get_state()` | 获取状态 | `state = app.get_state(config)` |
| `update_state()` | 更新状态 | `app.update_state(config, updates)` |

## 十四、版本兼容性

### 14.1 版本要求

```python
# requirements.txt
langgraph>=0.0.20
langchain>=0.1.0
langchain-openai>=0.0.5
pydantic>=2.0.0
typing-extensions>=4.8.0
```

### 14.2 迁移指南

```python
# v0.0.x -> v0.1.x
# 旧版本
from langgraph.graph import Graph

# 新版本
from langgraph.graph import StateGraph

# 旧版本
graph = Graph()

# 新版本
graph = StateGraph(StateType)
```

## 结语

本 API 参考文档涵盖了 LangGraph 的核心功能和常用接口。建议结合官方文档和示例代码深入学习。随着 LangGraph 的持续发展，API 可能会有更新和变化，请及时关注官方发布的最新信息。

如需更详细的信息，请参考：
- 官方文档：[langgraph.readthedocs.io](https://langgraph.readthedocs.io)
- GitHub：[github.com/langchain-ai/langgraph](https://github.com/langchain-ai/langgraph)
- 示例代码：[LangGraph Examples](https://github.com/langchain-ai/langgraph/tree/main/examples)