---
title: LangGraph 高级特性与优化技巧
date: 2025-09-30
permalink: /ai/langgraph/advanced-features.html
tags:
  - AI
  - LangGraph
  - 优化技巧
categories:
  - AI
  - LangGraph
---

# LangGraph 高级特性与优化技巧

## 1. 子图和嵌套图

### 子图的概念与应用

子图允许将复杂的工作流分解为可重用的模块，提高代码的可维护性和复用性。

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, Annotated, List, Dict
from operator import add

# 1. 定义子图状态
class SubWorkflowState(TypedDict):
    sub_input: str
    sub_result: str
    sub_metadata: Dict

# 2. 创建子图
def create_sub_workflow() -> StateGraph:
    """创建可重用的子工作流"""
    sub_workflow = StateGraph(SubWorkflowState)

    def sub_process_node(state):
        # 子流程处理逻辑
        result = f"Processed: {state['sub_input']}"
        return {"sub_result": result}

    def sub_validation_node(state):
        # 子流程验证
        is_valid = len(state.get("sub_result", "")) > 0
        return {"sub_metadata": {"valid": is_valid}}

    sub_workflow.add_node("process", sub_process_node)
    sub_workflow.add_node("validate", sub_validation_node)

    sub_workflow.set_entry_point("process")
    sub_workflow.add_edge("process", "validate")
    sub_workflow.add_edge("validate", END)

    return sub_workflow

# 3. 主图集成子图
class MainState(TypedDict):
    main_data: str
    sub_results: Annotated[List[str], add]
    final_result: str

def create_main_workflow_with_subgraph():
    main_workflow = StateGraph(MainState)

    # 编译子图
    sub_app = create_sub_workflow().compile()

    def prepare_node(state):
        """准备数据供子图使用"""
        return {"main_data": "prepared_" + state.get("main_data", "")}

    def invoke_subgraph_node(state):
        """调用子图"""
        # 准备子图输入
        sub_input = {
            "sub_input": state["main_data"],
            "sub_result": "",
            "sub_metadata": {}
        }

        # 执行子图
        sub_output = sub_app.invoke(sub_input)

        # 提取结果
        return {"sub_results": [sub_output["sub_result"]]}

    def finalize_node(state):
        """整合结果"""
        all_results = " | ".join(state.get("sub_results", []))
        return {"final_result": all_results}

    # 构建主流程
    main_workflow.add_node("prepare", prepare_node)
    main_workflow.add_node("subgraph", invoke_subgraph_node)
    main_workflow.add_node("finalize", finalize_node)

    main_workflow.set_entry_point("prepare")
    main_workflow.add_edge("prepare", "subgraph")
    main_workflow.add_edge("subgraph", "finalize")
    main_workflow.add_edge("finalize", END)

    return main_workflow.compile()
```

### 动态子图选择

```python
class DynamicSubgraphState(TypedDict):
    task_type: str
    data: Dict
    result: str

def create_dynamic_workflow():
    """根据任务类型动态选择子图"""
    workflow = StateGraph(DynamicSubgraphState)

    # 创建不同类型的子图
    analysis_subgraph = create_analysis_subgraph().compile()
    generation_subgraph = create_generation_subgraph().compile()
    transformation_subgraph = create_transformation_subgraph().compile()

    # 子图映射
    subgraph_map = {
        "analyze": analysis_subgraph,
        "generate": generation_subgraph,
        "transform": transformation_subgraph
    }

    def router_node(state):
        """路由到合适的子图"""
        task_type = state.get("task_type", "analyze")
        selected_subgraph = subgraph_map.get(task_type, analysis_subgraph)

        # 执行选中的子图
        result = selected_subgraph.invoke(state["data"])

        return {"result": result}

    workflow.add_node("router", router_node)
    workflow.set_entry_point("router")
    workflow.add_edge("router", END)

    return workflow.compile()
```

## 2. 并行执行优化

### MapReduce 模式

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import asyncio
from typing import List, Any

class MapReduceState(TypedDict):
    input_chunks: List[Any]
    mapped_results: Annotated[List[Any], add]
    reduced_result: Any

def create_mapreduce_workflow():
    """创建 MapReduce 工作流"""
    workflow = StateGraph(MapReduceState)

    def split_node(state):
        """分割数据为块"""
        data = state.get("data", [])
        chunk_size = 10
        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
        return {"input_chunks": chunks}

    def parallel_map_node(state):
        """并行映射处理"""
        chunks = state["input_chunks"]
        mapped_results = []

        def process_chunk(chunk):
            # 处理单个块
            return sum(chunk)  # 示例：求和

        # 使用线程池并行处理
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = {executor.submit(process_chunk, chunk): chunk for chunk in chunks}

            for future in as_completed(futures):
                try:
                    result = future.result()
                    mapped_results.append(result)
                except Exception as e:
                    print(f"处理失败: {e}")

        return {"mapped_results": mapped_results}

    def reduce_node(state):
        """归约结果"""
        mapped = state.get("mapped_results", [])
        reduced = sum(mapped)  # 示例：总和
        return {"reduced_result": reduced}

    workflow.add_node("split", split_node)
    workflow.add_node("map", parallel_map_node)
    workflow.add_node("reduce", reduce_node)

    workflow.set_entry_point("split")
    workflow.add_edge("split", "map")
    workflow.add_edge("map", "reduce")
    workflow.add_edge("reduce", END)

    return workflow.compile()
```

### 异步节点执行

```python
import asyncio
from langchain_openai import ChatOpenAI

class AsyncState(TypedDict):
    queries: List[str]
    responses: Annotated[List[str], add]
    summary: str

def create_async_workflow():
    """创建异步执行工作流"""
    workflow = StateGraph(AsyncState)
    llm = ChatOpenAI(model="gpt-4")

    async def async_process_query(query: str) -> str:
        """异步处理单个查询"""
        response = await llm.ainvoke(query)
        return response.content

    def async_batch_node(state):
        """批量异步处理"""
        queries = state["queries"]

        async def process_all():
            tasks = [async_process_query(q) for q in queries]
            responses = await asyncio.gather(*tasks)
            return responses

        # 运行异步任务
        responses = asyncio.run(process_all())

        return {"responses": responses}

    def summarize_node(state):
        """总结所有响应"""
        responses = state.get("responses", [])
        summary = f"处理了 {len(responses)} 个查询"
        return {"summary": summary}

    workflow.add_node("async_batch", async_batch_node)
    workflow.add_node("summarize", summarize_node)

    workflow.set_entry_point("async_batch")
    workflow.add_edge("async_batch", "summarize")
    workflow.add_edge("summarize", END)

    return workflow.compile()
```

## 3. 流式处理

### 实时流式输出

```python
from typing import Iterator, AsyncIterator
import time

class StreamState(TypedDict):
    input_text: str
    tokens: Annotated[List[str], add]
    is_complete: bool

def create_streaming_workflow():
    """创建支持流式输出的工作流"""
    workflow = StateGraph(StreamState)

    def streaming_node(state):
        """流式生成节点"""
        input_text = state["input_text"]

        # 模拟流式生成
        def token_generator():
            words = input_text.split()
            for word in words:
                time.sleep(0.1)  # 模拟延迟
                yield word

        tokens = list(token_generator())
        return {"tokens": tokens}

    def check_completion_node(state):
        """检查是否完成"""
        tokens = state.get("tokens", [])
        is_complete = len(tokens) > 10 or "END" in tokens
        return {"is_complete": is_complete}

    workflow.add_node("stream", streaming_node)
    workflow.add_node("check", check_completion_node)

    workflow.set_entry_point("stream")
    workflow.add_edge("stream", "check")

    workflow.add_conditional_edges(
        "check",
        lambda s: "end" if s["is_complete"] else "continue",
        {
            "end": END,
            "continue": "stream"
        }
    )

    return workflow.compile()

# 使用流式输出
def use_streaming():
    app = create_streaming_workflow()
    config = {"configurable": {"thread_id": "stream_1"}}

    initial_state = {
        "input_text": "This is a test of streaming output END",
        "tokens": [],
        "is_complete": False
    }

    # 流式处理
    for chunk in app.stream(initial_state, config):
        print(f"Token: {chunk}")
        # 实时处理每个token
```

### 事件驱动流

```python
from typing import Callable
import queue
import threading

class EventDrivenState(TypedDict):
    events: List[Dict]
    processed_events: Annotated[List[Dict], add]
    active: bool

class EventDrivenWorkflow:
    """事件驱动的工作流"""

    def __init__(self):
        self.event_queue = queue.Queue()
        self.handlers = {}
        self.workflow = self._build_workflow()

    def _build_workflow(self):
        workflow = StateGraph(EventDrivenState)

        def event_processor_node(state):
            """处理事件队列"""
            processed = []

            while not self.event_queue.empty():
                try:
                    event = self.event_queue.get_nowait()
                    handler = self.handlers.get(event["type"])

                    if handler:
                        result = handler(event)
                        processed.append({
                            "event": event,
                            "result": result,
                            "timestamp": time.time()
                        })
                except queue.Empty:
                    break

            return {"processed_events": processed}

        def monitor_node(state):
            """监控节点"""
            processed = state.get("processed_events", [])
            active = len(processed) > 0 or not self.event_queue.empty()
            return {"active": active}

        workflow.add_node("process", event_processor_node)
        workflow.add_node("monitor", monitor_node)

        workflow.set_entry_point("process")
        workflow.add_edge("process", "monitor")

        workflow.add_conditional_edges(
            "monitor",
            lambda s: "continue" if s["active"] else "end",
            {
                "continue": "process",
                "end": END
            }
        )

        return workflow.compile()

    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        self.handlers[event_type] = handler

    def emit_event(self, event: Dict):
        """发送事件"""
        self.event_queue.put(event)

    def run(self):
        """运行事件驱动工作流"""
        initial_state = {
            "events": [],
            "processed_events": [],
            "active": True
        }

        return self.workflow.invoke(initial_state)
```

## 4. 内存优化

### 增量状态更新

```python
class OptimizedState(TypedDict):
    # 使用生成器减少内存占用
    large_data: Any  # 实际使用时应该是生成器
    # 使用引用而非复制
    data_ref: str  # 数据的引用ID
    # 压缩存储
    compressed_data: bytes

def memory_optimized_workflow():
    """内存优化的工作流"""
    import zlib
    import pickle

    workflow = StateGraph(OptimizedState)

    # 外部存储管理器
    external_storage = {}

    def compress_node(state):
        """压缩大型数据"""
        data = state.get("large_data")
        if data:
            # 序列化并压缩
            serialized = pickle.dumps(data)
            compressed = zlib.compress(serialized)
            return {"compressed_data": compressed}
        return {}

    def store_reference_node(state):
        """存储引用而非数据本身"""
        data = state.get("large_data")
        if data:
            # 生成唯一ID
            ref_id = f"ref_{id(data)}_{time.time()}"
            # 存储到外部
            external_storage[ref_id] = data
            return {"data_ref": ref_id, "large_data": None}  # 清除原数据
        return {}

    def retrieve_reference_node(state):
        """通过引用获取数据"""
        ref_id = state.get("data_ref")
        if ref_id and ref_id in external_storage:
            data = external_storage[ref_id]
            # 处理数据...
            # 清理引用
            del external_storage[ref_id]
            return {"data_ref": None}
        return {}

    workflow.add_node("compress", compress_node)
    workflow.add_node("store_ref", store_reference_node)
    workflow.add_node("retrieve", retrieve_reference_node)

    workflow.set_entry_point("compress")
    workflow.add_edge("compress", "store_ref")
    workflow.add_edge("store_ref", "retrieve")
    workflow.add_edge("retrieve", END)

    return workflow.compile()
```

### 懒加载策略

```python
class LazyLoadState(TypedDict):
    data_paths: List[str]
    loaded_data: Dict
    current_index: int

class LazyLoader:
    """懒加载数据管理器"""

    def __init__(self, paths: List[str]):
        self.paths = paths
        self.cache = {}
        self.max_cache_size = 3

    def get(self, index: int):
        """按需加载数据"""
        if index in self.cache:
            return self.cache[index]

        # 检查缓存大小
        if len(self.cache) >= self.max_cache_size:
            # LRU 清理
            oldest = min(self.cache.keys())
            del self.cache[oldest]

        # 加载新数据
        if 0 <= index < len(self.paths):
            path = self.paths[index]
            # 模拟数据加载
            data = f"Data from {path}"
            self.cache[index] = data
            return data

        return None

def lazy_loading_workflow():
    """使用懒加载的工作流"""
    workflow = StateGraph(LazyLoadState)

    # 创建懒加载器
    loader = LazyLoader([f"path_{i}.dat" for i in range(100)])

    def process_batch_node(state):
        """批量处理with懒加载"""
        current_index = state.get("current_index", 0)
        batch_size = 5

        loaded = {}
        for i in range(current_index, min(current_index + batch_size, 100)):
            data = loader.get(i)
            if data:
                # 处理数据
                processed = f"Processed: {data}"
                loaded[i] = processed

        return {
            "loaded_data": loaded,
            "current_index": current_index + batch_size
        }

    def check_completion_node(state):
        """检查是否完成"""
        current_index = state.get("current_index", 0)
        return {"is_complete": current_index >= 100}

    workflow.add_node("process", process_batch_node)
    workflow.add_node("check", check_completion_node)

    workflow.set_entry_point("process")
    workflow.add_edge("process", "check")

    workflow.add_conditional_edges(
        "check",
        lambda s: "end" if s.get("is_complete") else "continue",
        {
            "end": END,
            "continue": "process"
        }
    )

    return workflow.compile()
```

## 5. 分布式执行

### 使用 Celery 分布式任务

```python
from celery import Celery
from typing import Any

# Celery 配置
celery_app = Celery('langgraph_distributed', broker='redis://localhost:6379')

@celery_app.task
def distributed_node_task(state_data: Dict) -> Dict:
    """分布式节点任务"""
    # 处理逻辑
    result = process_heavy_computation(state_data)
    return {"result": result}

class DistributedState(TypedDict):
    task_id: str
    input_data: Dict
    result: Any
    status: str

def create_distributed_workflow():
    """创建分布式工作流"""
    workflow = StateGraph(DistributedState)

    def submit_task_node(state):
        """提交分布式任务"""
        input_data = state["input_data"]

        # 异步提交任务到Celery
        task = distributed_node_task.delay(input_data)

        return {
            "task_id": task.id,
            "status": "submitted"
        }

    def check_task_node(state):
        """检查任务状态"""
        task_id = state["task_id"]

        # 获取任务结果
        result = celery_app.AsyncResult(task_id)

        if result.ready():
            if result.successful():
                return {
                    "result": result.get(),
                    "status": "completed"
                }
            else:
                return {
                    "status": "failed",
                    "error": str(result.info)
                }
        else:
            return {"status": "pending"}

    def wait_node(state):
        """等待节点"""
        time.sleep(1)  # 等待1秒后重试
        return {}

    workflow.add_node("submit", submit_task_node)
    workflow.add_node("check", check_task_node)
    workflow.add_node("wait", wait_node)

    workflow.set_entry_point("submit")
    workflow.add_edge("submit", "check")

    workflow.add_conditional_edges(
        "check",
        lambda s: s.get("status", "pending"),
        {
            "completed": END,
            "failed": END,
            "pending": "wait"
        }
    )

    workflow.add_edge("wait", "check")

    return workflow.compile()
```

### Ray 集成

```python
import ray
from ray import serve

@ray.remote
class RayNode:
    """Ray 分布式节点"""

    def __init__(self, node_id: str):
        self.node_id = node_id

    def process(self, state: Dict) -> Dict:
        """处理状态"""
        # CPU密集型任务
        result = self.heavy_computation(state)
        return {"node_id": self.node_id, "result": result}

    def heavy_computation(self, state: Dict):
        # 模拟计算
        import numpy as np
        data = np.random.rand(1000, 1000)
        return np.sum(data)

def create_ray_workflow():
    """使用 Ray 的分布式工作流"""
    ray.init()

    workflow = StateGraph(State)

    # 创建Ray actors
    nodes = [RayNode.remote(f"node_{i}") for i in range(4)]

    def distribute_work_node(state):
        """分发工作到Ray节点"""
        data_chunks = split_data(state["data"])

        # 并行处理
        futures = []
        for i, chunk in enumerate(data_chunks):
            node = nodes[i % len(nodes)]
            future = node.process.remote({"data": chunk})
            futures.append(future)

        # 收集结果
        results = ray.get(futures)

        return {"distributed_results": results}

    workflow.add_node("distribute", distribute_work_node)
    workflow.set_entry_point("distribute")
    workflow.add_edge("distribute", END)

    return workflow.compile()
```

## 6. 监控和可观测性

### 追踪和度量

```python
from opentelemetry import trace, metrics
from opentelemetry.exporter.prometheus import PrometheusMetricReader
import time

# 设置追踪器
tracer = trace.get_tracer(__name__)
meter = metrics.get_meter(__name__)

# 创建度量
node_duration = meter.create_histogram(
    name="langgraph_node_duration",
    description="Node execution duration",
    unit="ms"
)

node_counter = meter.create_counter(
    name="langgraph_node_executions",
    description="Number of node executions"
)

def instrumented_node(node_name: str):
    """带监控的节点装饰器"""
    def decorator(func):
        def wrapper(state):
            with tracer.start_as_current_span(f"node_{node_name}") as span:
                span.set_attribute("node.name", node_name)
                span.set_attribute("state.size", len(str(state)))

                start_time = time.time()

                try:
                    # 执行节点
                    result = func(state)

                    # 记录成功
                    span.set_status(trace.Status(trace.StatusCode.OK))
                    node_counter.add(1, {"node": node_name, "status": "success"})

                    return result

                except Exception as e:
                    # 记录错误
                    span.set_status(
                        trace.Status(trace.StatusCode.ERROR, str(e))
                    )
                    node_counter.add(1, {"node": node_name, "status": "error"})
                    raise

                finally:
                    # 记录执行时间
                    duration = (time.time() - start_time) * 1000
                    node_duration.record(duration, {"node": node_name})
                    span.set_attribute("duration.ms", duration)

        return wrapper
    return decorator

# 使用示例
@instrumented_node("process")
def monitored_process_node(state):
    # 处理逻辑
    return {"processed": True}
```

### 日志和审计

```python
import logging
import json
from datetime import datetime

class AuditLogger:
    """审计日志记录器"""

    def __init__(self, log_file: str = "audit.log"):
        self.logger = logging.getLogger("audit")
        handler = logging.FileHandler(log_file)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)

    def log_state_change(self, node: str, before: Dict, after: Dict):
        """记录状态变化"""
        audit_entry = {
            "timestamp": datetime.now().isoformat(),
            "node": node,
            "changes": self._diff(before, after),
            "metadata": {
                "before_size": len(str(before)),
                "after_size": len(str(after))
            }
        }
        self.logger.info(json.dumps(audit_entry))

    def _diff(self, before: Dict, after: Dict) -> List[Dict]:
        """计算差异"""
        changes = []
        all_keys = set(before.keys()) | set(after.keys())

        for key in all_keys:
            if key not in before:
                changes.append({"key": key, "action": "added", "value": after[key]})
            elif key not in after:
                changes.append({"key": key, "action": "removed", "value": before[key]})
            elif before[key] != after[key]:
                changes.append({
                    "key": key,
                    "action": "modified",
                    "before": before[key],
                    "after": after[key]
                })

        return changes

def audited_workflow():
    """带审计的工作流"""
    workflow = StateGraph(State)
    audit = AuditLogger()

    def audited_node(name: str):
        def decorator(func):
            def wrapper(state):
                before = state.copy()
                result = func(state)
                after = {**state, **result}
                audit.log_state_change(name, before, after)
                return result
            return wrapper
        return decorator

    @audited_node("process")
    def process_node(state):
        return {"processed": True}

    workflow.add_node("process", process_node)
    # ... 构建其余流程

    return workflow.compile()
```

## 7. 性能调优最佳实践

### 缓存策略

```python
from functools import lru_cache
import hashlib
import redis

class CacheStrategy:
    """缓存策略管理"""

    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379)
        self.local_cache = {}

    def cache_key(self, state: Dict) -> str:
        """生成缓存键"""
        state_str = json.dumps(state, sort_keys=True)
        return hashlib.md5(state_str.encode()).hexdigest()

    def cached_node(self, ttl: int = 3600):
        """缓存节点装饰器"""
        def decorator(func):
            def wrapper(state):
                key = self.cache_key(state)

                # 检查本地缓存
                if key in self.local_cache:
                    return self.local_cache[key]

                # 检查Redis缓存
                cached = self.redis_client.get(key)
                if cached:
                    result = json.loads(cached)
                    self.local_cache[key] = result
                    return result

                # 执行并缓存
                result = func(state)

                # 存储到缓存
                self.redis_client.setex(
                    key,
                    ttl,
                    json.dumps(result)
                )
                self.local_cache[key] = result

                return result

            return wrapper
        return decorator

# 使用缓存
cache_strategy = CacheStrategy()

@cache_strategy.cached_node(ttl=3600)
def expensive_computation_node(state):
    """昂贵的计算节点"""
    # 复杂计算
    result = perform_heavy_computation(state)
    return {"result": result}
```

### 批处理优化

```python
class BatchProcessor:
    """批处理优化器"""

    def __init__(self, batch_size: int = 32):
        self.batch_size = batch_size
        self.buffer = []

    def batch_node(self, process_func):
        """批处理节点装饰器"""
        def wrapper(state):
            item = state.get("item")
            if item:
                self.buffer.append(item)

            # 检查是否达到批量大小
            if len(self.buffer) >= self.batch_size or state.get("flush"):
                # 批量处理
                batch_result = process_func(self.buffer)
                self.buffer = []
                return {"batch_result": batch_result}

            return {"buffered": True}

        return wrapper

# 使用批处理
batch_processor = BatchProcessor(batch_size=32)

@batch_processor.batch_node
def batch_process(items: List):
    """批量处理函数"""
    # 批量API调用或计算
    results = batch_api_call(items)
    return results
```

## 总结

LangGraph 的高级特性提供了强大的能力：

1. **子图和模块化**：提高代码复用性和可维护性
2. **并行和异步执行**：提升性能和吞吐量
3. **流式处理**：支持实时数据处理
4. **内存优化**：处理大规模数据
5. **分布式执行**：横向扩展能力
6. **监控和可观测性**：生产级别的追踪和审计
7. **性能调优**：缓存、批处理等优化策略

这些特性使 LangGraph 成为构建生产级 AI 应用的强大框架。通过合理使用这些高级特性，可以构建高性能、可扩展、易维护的 AI 系统。

## 下一步

- 深入研究 LangGraph 源码
- 实践更复杂的生产案例
- 探索与其他框架的集成
- 贡献开源社区