---
title: 安全机制设计
date: 2025-01-15
permalink: /ai/claude-code/security-design.html
tags:
  - Claude Code
  - 安全
  - API密钥
  - 权限控制
categories:
  - AI
  - Claude Code
---

# 安全机制设计

## 1. 引言

安全是 AI 编程助手的生命线。Claude Code 拥有读写文件、执行命令、访问网络等强大权限，一旦被恶意利用，可能造成数据泄露、系统破坏等严重后果。本文将深入探讨 Claude Code 的多层安全防护体系。

### 1.1 安全威胁模型

```mermaid
graph TB
    subgraph "外部威胁"
        T1[提示注入攻击]
        T2[恶意代码仓库]
        T3[中间人攻击]
        T4[依赖供应链攻击]
    end

    subgraph "内部威胁"
        T5[误操作]
        T6[权限滥用]
        T7[敏感信息泄露]
        T8[资源耗尽]
    end

    subgraph "防护层"
        P1[输入验证]
        P2[命令过滤]
        P3[权限控制]
        P4[审计日志]
    end

    T1 --> P1
    T2 --> P2
    T5 --> P3
    T7 --> P4

    style T1,T2,T3,T4,T5,T6,T7,T8 fill:#ffebee
    style P1,P2,P3,P4 fill:#e8f5e9
```

### 1.2 安全设计原则

```java
/**
 * 安全设计原则
 */
public class SecurityPrinciples {

    /**
     * 1. 最小权限原则（Principle of Least Privilege）
     */
    public interface LeastPrivilege {
        // 只授予完成任务所需的最小权限
        // 例如：只读文件时不授予写权限
        void grantMinimalPermissions();
    }

    /**
     * 2. 深度防御（Defense in Depth）
     */
    public interface DefenseInDepth {
        // 多层安全机制，一层被突破时其他层仍能防护
        // 例如：输入验证 + 命令过滤 + 沙箱隔离
        void implementMultipleLayers();
    }

    /**
     * 3. 默认拒绝（Default Deny）
     */
    public interface DefaultDeny {
        // 默认拒绝所有操作，明确允许的才放行
        // 例如：白名单机制优于黑名单
        void denyByDefault();
    }

    /**
     * 4. 失败安全（Fail-Safe）
     */
    public interface FailSafe {
        // 发生错误时选择安全的处理方式
        // 例如：权限检查失败时拒绝访问而非默认允许
        void failSecurely();
    }

    /**
     * 5. 零信任（Zero Trust）
     */
    public interface ZeroTrust {
        // 永远不信任，始终验证
        // 例如：每次操作都验证权限，不依赖缓存的权限
        void neverTrustAlwaysVerify();
    }

    /**
     * 6. 审计与监控（Audit and Monitor）
     */
    public interface AuditAndMonitor {
        // 记录所有关键操作，便于事后审计
        // 例如：记录文件访问、命令执行、API调用
        void logSecurityEvents();
    }
}
```

### 1.3 安全架构总览

```mermaid
graph TB
    subgraph "用户层"
        User[用户/AI Agent]
    end

    subgraph "认证与授权层"
        Auth[API Key管理]
        Perms[权限控制]
        Hooks[用户确认Hooks]
    end

    subgraph "输入验证层"
        InputVal[输入验证器]
        Sanitize[数据清洗]
        Escape[转义处理]
    end

    subgraph "命令执行层"
        CmdFilter[命令过滤器]
        Whitelist[白名单检查]
        Blacklist[黑名单检查]
        Sandbox[沙箱隔离]
    end

    subgraph "文件访问层"
        PathVal[路径验证]
        FilePerms[文件权限]
        SensFilter[敏感信息过滤]
    end

    subgraph "审计层"
        AuditLog[审计日志]
        Monitor[实时监控]
        Alert[异常告警]
    end

    User --> Auth
    Auth --> Perms
    Perms --> Hooks

    Hooks --> InputVal
    InputVal --> Sanitize
    Sanitize --> Escape

    Escape --> CmdFilter
    CmdFilter --> Whitelist
    Whitelist --> Blacklist
    Blacklist --> Sandbox

    Escape --> PathVal
    PathVal --> FilePerms
    FilePerms --> SensFilter

    Sandbox --> AuditLog
    SensFilter --> AuditLog
    AuditLog --> Monitor
    Monitor --> Alert

    style Auth,Perms,Hooks fill:#e1f5ff
    style InputVal,Sanitize,Escape fill:#fff4e6
    style CmdFilter,Whitelist,Blacklist,Sandbox fill:#f3e5f5
    style AuditLog,Monitor,Alert fill:#e8f5e9
```

## 2. API Key管理

### 2.1 多层密钥存储策略

```mermaid
graph LR
    subgraph "存储优先级"
        L1[环境变量]
        L2[系统Keychain]
        L3[加密配置文件]
        L4[内存缓存]
    end

    L1 -->|最高优先级| Read[读取密钥]
    L2 -->|次优先级| Read
    L3 -->|备用方案| Read
    L4 -->|运行时缓存| Read

    Read --> Validate[验证密钥]
    Validate --> Use[使用密钥]

    style L1 fill:#e8f5e9
    style L2 fill:#e1f5ff
    style L3 fill:#fff4e6
    style L4 fill:#f3e5f5
```

### 2.2 API Key管理器实现

```java
/**
 * API Key管理器
 */
public class ApiKeyManager {

    private final KeychainService keychainService;
    private final EncryptionService encryptionService;
    private volatile String cachedApiKey;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    /**
     * 密钥配置
     */
    public static class ApiKeyConfig {
        private String envVarName;           // 环境变量名
        private String keychainService;      // Keychain服务名
        private String keychainAccount;      // Keychain账户名
        private String configFilePath;       // 配置文件路径
        private Duration cacheTimeout;       // 缓存超时时间

        public static ApiKeyConfig defaults() {
            return ApiKeyConfig.builder()
                .envVarName("ANTHROPIC_API_KEY")
                .keychainService("com.anthropic.claude-code")
                .keychainAccount("api-key")
                .configFilePath("~/.claude/config.enc")
                .cacheTimeout(Duration.ofHours(1))
                .build();
        }
    }

    /**
     * 获取API Key（多层回退）
     */
    public String getApiKey() throws ApiKeyException {
        // 1. 检查内存缓存
        lock.readLock().lock();
        try {
            if (cachedApiKey != null && !isExpired()) {
                return cachedApiKey;
            }
        } finally {
            lock.readLock().unlock();
        }

        // 2. 从环境变量读取
        String apiKey = getFromEnvironment();
        if (apiKey != null) {
            return cacheAndReturn(apiKey);
        }

        // 3. 从系统Keychain读取
        apiKey = getFromKeychain();
        if (apiKey != null) {
            return cacheAndReturn(apiKey);
        }

        // 4. 从加密配置文件读取
        apiKey = getFromConfigFile();
        if (apiKey != null) {
            return cacheAndReturn(apiKey);
        }

        throw new ApiKeyException("API Key not found in any storage location");
    }

    /**
     * 从环境变量获取
     */
    private String getFromEnvironment() {
        String apiKey = System.getenv(config.getEnvVarName());
        if (apiKey != null && validateApiKey(apiKey)) {
            log.info("API Key loaded from environment variable");
            return apiKey;
        }
        return null;
    }

    /**
     * 从系统Keychain获取
     */
    private String getFromKeychain() {
        try {
            String apiKey = keychainService.getPassword(
                config.getKeychainService(),
                config.getKeychainAccount()
            );

            if (apiKey != null && validateApiKey(apiKey)) {
                log.info("API Key loaded from system Keychain");
                return apiKey;
            }
        } catch (KeychainException e) {
            log.warn("Failed to read from Keychain: {}", e.getMessage());
        }
        return null;
    }

    /**
     * 从加密配置文件获取
     */
    private String getFromConfigFile() {
        try {
            Path configPath = Paths.get(expandHome(config.getConfigFilePath()));

            if (!Files.exists(configPath)) {
                return null;
            }

            // 读取加密内容
            byte[] encryptedData = Files.readAllBytes(configPath);

            // 解密
            byte[] decryptedData = encryptionService.decrypt(encryptedData);
            String apiKey = new String(decryptedData, StandardCharsets.UTF_8);

            if (validateApiKey(apiKey)) {
                log.info("API Key loaded from encrypted config file");
                return apiKey;
            }
        } catch (Exception e) {
            log.warn("Failed to read from config file: {}", e.getMessage());
        }
        return null;
    }

    /**
     * 保存API Key
     */
    public void saveApiKey(String apiKey, StorageLocation location)
            throws ApiKeyException {

        if (!validateApiKey(apiKey)) {
            throw new ApiKeyException("Invalid API Key format");
        }

        switch (location) {
            case KEYCHAIN:
                saveToKeychain(apiKey);
                break;

            case CONFIG_FILE:
                saveToConfigFile(apiKey);
                break;

            case ENVIRONMENT:
                throw new ApiKeyException(
                    "Cannot programmatically set environment variable. " +
                    "Please set manually: export " +
                    config.getEnvVarName() + "=your-api-key"
                );

            default:
                throw new ApiKeyException("Unknown storage location: " + location);
        }

        // 更新缓存
        cacheAndReturn(apiKey);
    }

    /**
     * 保存到Keychain
     */
    private void saveToKeychain(String apiKey) throws ApiKeyException {
        try {
            keychainService.setPassword(
                config.getKeychainService(),
                config.getKeychainAccount(),
                apiKey
            );
            log.info("API Key saved to system Keychain");
        } catch (KeychainException e) {
            throw new ApiKeyException("Failed to save to Keychain: " + e.getMessage(), e);
        }
    }

    /**
     * 保存到加密配置文件
     */
    private void saveToConfigFile(String apiKey) throws ApiKeyException {
        try {
            Path configPath = Paths.get(expandHome(config.getConfigFilePath()));

            // 创建目录
            Files.createDirectories(configPath.getParent());

            // 加密
            byte[] encryptedData = encryptionService.encrypt(
                apiKey.getBytes(StandardCharsets.UTF_8)
            );

            // 写入文件
            Files.write(configPath, encryptedData);

            // 设置文件权限（只有所有者可读写）
            setFilePermissions(configPath, "600");

            log.info("API Key saved to encrypted config file");

        } catch (Exception e) {
            throw new ApiKeyException("Failed to save to config file: " + e.getMessage(), e);
        }
    }

    /**
     * 验证API Key格式
     */
    private boolean validateApiKey(String apiKey) {
        if (apiKey == null || apiKey.trim().isEmpty()) {
            return false;
        }

        // Anthropic API Key格式：sk-ant-api03-xxx
        Pattern pattern = Pattern.compile("^sk-ant-api\\d{2}-[A-Za-z0-9_-]{95}$");
        return pattern.matcher(apiKey.trim()).matches();
    }

    /**
     * 缓存并返回
     */
    private String cacheAndReturn(String apiKey) {
        lock.writeLock().lock();
        try {
            this.cachedApiKey = apiKey;
            this.cacheTimestamp = System.currentTimeMillis();
            return apiKey;
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * 清除缓存
     */
    public void clearCache() {
        lock.writeLock().lock();
        try {
            this.cachedApiKey = null;
            this.cacheTimestamp = 0;
            log.info("API Key cache cleared");
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * 检查缓存是否过期
     */
    private boolean isExpired() {
        long elapsed = System.currentTimeMillis() - cacheTimestamp;
        return elapsed > config.getCacheTimeout().toMillis();
    }

    /**
     * 展开用户主目录
     */
    private String expandHome(String path) {
        if (path.startsWith("~/")) {
            return System.getProperty("user.home") + path.substring(1);
        }
        return path;
    }

    /**
     * 设置文件权限
     */
    private void setFilePermissions(Path path, String permissions) throws IOException {
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            // Windows: 使用ACL
            // 简化处理：确保只有当前用户可访问
            return;
        }

        // Unix/Linux/macOS: 使用chmod
        Set<PosixFilePermission> perms = PosixFilePermissions.fromString(
            "rw-------"
        );
        Files.setPosixFilePermissions(path, perms);
    }

    /**
     * 存储位置枚举
     */
    public enum StorageLocation {
        ENVIRONMENT,    // 环境变量
        KEYCHAIN,       // 系统Keychain
        CONFIG_FILE     // 加密配置文件
    }
}

/**
 * Keychain服务接口
 */
public interface KeychainService {

    /**
     * 获取密码
     */
    String getPassword(String service, String account) throws KeychainException;

    /**
     * 设置密码
     */
    void setPassword(String service, String account, String password)
        throws KeychainException;

    /**
     * 删除密码
     */
    void deletePassword(String service, String account) throws KeychainException;
}

/**
 * macOS Keychain实现
 */
public class MacOSKeychainService implements KeychainService {

    @Override
    public String getPassword(String service, String account)
            throws KeychainException {
        try {
            // 使用JNA调用macOS Security Framework
            // 或使用命令行工具：security find-generic-password
            ProcessBuilder pb = new ProcessBuilder(
                "security",
                "find-generic-password",
                "-s", service,
                "-a", account,
                "-w"  // 只输出密码
            );

            Process process = pb.start();
            String output = new String(
                process.getInputStream().readAllBytes(),
                StandardCharsets.UTF_8
            ).trim();

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                return null;
            }

            return output;

        } catch (Exception e) {
            throw new KeychainException("Failed to get password from Keychain", e);
        }
    }

    @Override
    public void setPassword(String service, String account, String password)
            throws KeychainException {
        try {
            // 先删除旧密码（如果存在）
            try {
                deletePassword(service, account);
            } catch (KeychainException e) {
                // 忽略：可能不存在
            }

            // 添加新密码
            ProcessBuilder pb = new ProcessBuilder(
                "security",
                "add-generic-password",
                "-s", service,
                "-a", account,
                "-w", password,
                "-U"  // 如果存在则更新
            );

            Process process = pb.start();
            int exitCode = process.waitFor();

            if (exitCode != 0) {
                String error = new String(
                    process.getErrorStream().readAllBytes(),
                    StandardCharsets.UTF_8
                );
                throw new KeychainException("Failed to set password: " + error);
            }

        } catch (Exception e) {
            throw new KeychainException("Failed to set password in Keychain", e);
        }
    }

    @Override
    public void deletePassword(String service, String account)
            throws KeychainException {
        try {
            ProcessBuilder pb = new ProcessBuilder(
                "security",
                "delete-generic-password",
                "-s", service,
                "-a", account
            );

            Process process = pb.start();
            process.waitFor();

        } catch (Exception e) {
            throw new KeychainException("Failed to delete password from Keychain", e);
        }
    }
}

/**
 * 加密服务
 */
public class EncryptionService {

    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 128;

    private final SecretKey key;

    public EncryptionService() throws NoSuchAlgorithmException {
        // 从系统派生密钥（实际应该使用更安全的密钥管理）
        this.key = deriveKey();
    }

    /**
     * 加密数据
     */
    public byte[] encrypt(byte[] plaintext) throws EncryptionException {
        try {
            // 生成随机IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            SecureRandom random = new SecureRandom();
            random.nextBytes(iv);

            // 加密
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key, parameterSpec);

            byte[] ciphertext = cipher.doFinal(plaintext);

            // 合并 IV + 密文
            ByteBuffer byteBuffer = ByteBuffer.allocate(iv.length + ciphertext.length);
            byteBuffer.put(iv);
            byteBuffer.put(ciphertext);

            return byteBuffer.array();

        } catch (Exception e) {
            throw new EncryptionException("Encryption failed", e);
        }
    }

    /**
     * 解密数据
     */
    public byte[] decrypt(byte[] encryptedData) throws EncryptionException {
        try {
            // 分离 IV 和密文
            ByteBuffer byteBuffer = ByteBuffer.wrap(encryptedData);

            byte[] iv = new byte[GCM_IV_LENGTH];
            byteBuffer.get(iv);

            byte[] ciphertext = new byte[byteBuffer.remaining()];
            byteBuffer.get(ciphertext);

            // 解密
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.DECRYPT_MODE, key, parameterSpec);

            return cipher.doFinal(ciphertext);

        } catch (Exception e) {
            throw new EncryptionException("Decryption failed", e);
        }
    }

    /**
     * 派生密钥
     */
    private SecretKey deriveKey() throws NoSuchAlgorithmException {
        // 实际应该使用PBKDF2或Argon2从密码派生
        // 这里简化处理：从系统信息生成
        String seed = System.getProperty("user.name") +
                     System.getProperty("os.name") +
                     "claude-code-secret";

        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] keyBytes = digest.digest(seed.getBytes(StandardCharsets.UTF_8));

        return new SecretKeySpec(keyBytes, "AES");
    }
}
```

## 3. 敏感信息过滤

### 3.1 敏感信息检测引擎

```mermaid
graph TB
    subgraph "检测层"
        Input[输入内容]
    end

    subgraph "规则引擎"
        R1[正则规则]
        R2[熵值检测]
        R3[ML模型检测]
        R4[自定义规则]
    end

    subgraph "敏感类型"
        T1[API密钥]
        T2[密码]
        T3[信用卡号]
        T4[私钥/证书]
        T5[邮箱/手机]
        T6[身份证号]
    end

    subgraph "处理策略"
        A1[阻止]
        A2[脱敏]
        A3[警告]
        A4[记录审计]
    end

    Input --> R1
    Input --> R2
    Input --> R3
    Input --> R4

    R1 --> T1
    R1 --> T2
    R1 --> T3
    R2 --> T1
    R3 --> T4

    T1 --> A1
    T2 --> A1
    T3 --> A2
    T4 --> A1
    T5 --> A3
    T6 --> A2

    A1 --> A4
    A2 --> A4
    A3 --> A4

    style Input fill:#e1f5ff
    style R1,R2,R3,R4 fill:#fff4e6
    style T1,T2,T3,T4,T5,T6 fill:#ffebee
    style A1,A2,A3,A4 fill:#e8f5e9
```

### 3.2 敏感信息过滤器实现

```java
/**
 * 敏感信息过滤器
 */
public class SensitiveInfoFilter {

    private final List<DetectionRule> rules = new ArrayList<>();
    private final MLDetector mlDetector;

    public SensitiveInfoFilter() {
        // 初始化检测规则
        initializeRules();
        this.mlDetector = new MLDetector();
    }

    /**
     * 扫描内容
     */
    public ScanResult scan(String content) {
        List<SensitiveMatch> matches = new ArrayList<>();

        // 1. 正则规则检测
        for (DetectionRule rule : rules) {
            matches.addAll(rule.detect(content));
        }

        // 2. 熵值检测（高熵字符串可能是密钥）
        matches.addAll(detectHighEntropyStrings(content));

        // 3. ML模型检测
        matches.addAll(mlDetector.detect(content));

        return new ScanResult(matches);
    }

    /**
     * 过滤敏感信息
     */
    public String filter(String content, FilterPolicy policy) {
        ScanResult scanResult = scan(content);

        if (scanResult.isEmpty()) {
            return content;
        }

        String filtered = content;

        for (SensitiveMatch match : scanResult.getMatches()) {
            String replacement = policy.getReplacementFor(match.getType());
            filtered = filtered.replace(match.getText(), replacement);
        }

        return filtered;
    }

    /**
     * 初始化检测规则
     */
    private void initializeRules() {
        // API密钥规则
        rules.add(new RegexRule(
            SensitiveType.API_KEY,
            "Anthropic API Key",
            Pattern.compile("sk-ant-api\\d{2}-[A-Za-z0-9_-]{95}"),
            Severity.CRITICAL
        ));

        rules.add(new RegexRule(
            SensitiveType.API_KEY,
            "OpenAI API Key",
            Pattern.compile("sk-[A-Za-z0-9]{48}"),
            Severity.CRITICAL
        ));

        rules.add(new RegexRule(
            SensitiveType.API_KEY,
            "AWS Access Key",
            Pattern.compile("AKIA[0-9A-Z]{16}"),
            Severity.CRITICAL
        ));

        // GitHub Token
        rules.add(new RegexRule(
            SensitiveType.API_KEY,
            "GitHub Token",
            Pattern.compile("gh[pousr]_[A-Za-z0-9]{36}"),
            Severity.CRITICAL
        ));

        // 私钥
        rules.add(new RegexRule(
            SensitiveType.PRIVATE_KEY,
            "RSA Private Key",
            Pattern.compile("-----BEGIN (RSA )?PRIVATE KEY-----[\\s\\S]+?-----END (RSA )?PRIVATE KEY-----"),
            Severity.CRITICAL
        ));

        rules.add(new RegexRule(
            SensitiveType.PRIVATE_KEY,
            "SSH Private Key",
            Pattern.compile("-----BEGIN OPENSSH PRIVATE KEY-----[\\s\\S]+?-----END OPENSSH PRIVATE KEY-----"),
            Severity.CRITICAL
        ));

        // 数据库连接串
        rules.add(new RegexRule(
            SensitiveType.PASSWORD,
            "Database Connection String",
            Pattern.compile("(mysql|postgresql|mongodb)://[^:]+:([^@]+)@"),
            Severity.HIGH
        ));

        // 信用卡号
        rules.add(new RegexRule(
            SensitiveType.CREDIT_CARD,
            "Credit Card Number",
            Pattern.compile("\\b(?:\\d{4}[- ]?){3}\\d{4}\\b"),
            Severity.HIGH
        ));

        // 邮箱
        rules.add(new RegexRule(
            SensitiveType.EMAIL,
            "Email Address",
            Pattern.compile("\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b"),
            Severity.MEDIUM
        ));

        // 手机号（中国）
        rules.add(new RegexRule(
            SensitiveType.PHONE,
            "Phone Number (CN)",
            Pattern.compile("1[3-9]\\d{9}"),
            Severity.MEDIUM
        ));

        // 身份证号（中国）
        rules.add(new RegexRule(
            SensitiveType.ID_CARD,
            "ID Card (CN)",
            Pattern.compile("[1-9]\\d{5}(18|19|20)\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])\\d{3}[0-9Xx]"),
            Severity.HIGH
        ));

        // JWT Token
        rules.add(new RegexRule(
            SensitiveType.TOKEN,
            "JWT Token",
            Pattern.compile("eyJ[A-Za-z0-9_-]*\\.eyJ[A-Za-z0-9_-]*\\.[A-Za-z0-9_-]*"),
            Severity.HIGH
        ));

        // Bearer Token
        rules.add(new RegexRule(
            SensitiveType.TOKEN,
            "Bearer Token",
            Pattern.compile("Bearer [A-Za-z0-9\\-._~+/]+=*"),
            Severity.HIGH
        ));
    }

    /**
     * 检测高熵字符串
     */
    private List<SensitiveMatch> detectHighEntropyStrings(String content) {
        List<SensitiveMatch> matches = new ArrayList<>();

        // 提取可能的密钥字符串（连续的字母数字，长度40+）
        Pattern pattern = Pattern.compile("\\b[A-Za-z0-9]{40,}\\b");
        Matcher matcher = pattern.matcher(content);

        while (matcher.find()) {
            String candidate = matcher.group();

            // 计算Shannon熵
            double entropy = calculateEntropy(candidate);

            // 高熵阈值：4.5（base64编码的随机数据约为6）
            if (entropy > 4.5) {
                matches.add(new SensitiveMatch(
                    SensitiveType.HIGH_ENTROPY_STRING,
                    "High Entropy String (potential secret)",
                    candidate,
                    matcher.start(),
                    matcher.end(),
                    Severity.HIGH,
                    Map.of("entropy", entropy)
                ));
            }
        }

        return matches;
    }

    /**
     * 计算Shannon熵
     */
    private double calculateEntropy(String text) {
        Map<Character, Integer> frequencyMap = new HashMap<>();

        // 统计字符频率
        for (char c : text.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        // 计算熵
        double entropy = 0.0;
        int length = text.length();

        for (int count : frequencyMap.values()) {
            double probability = (double) count / length;
            entropy -= probability * (Math.log(probability) / Math.log(2));
        }

        return entropy;
    }

    /**
     * 敏感类型枚举
     */
    public enum SensitiveType {
        API_KEY,              // API密钥
        PASSWORD,             // 密码
        PRIVATE_KEY,          // 私钥
        CREDIT_CARD,          // 信用卡
        EMAIL,                // 邮箱
        PHONE,                // 手机号
        ID_CARD,              // 身份证
        TOKEN,                // Token
        HIGH_ENTROPY_STRING   // 高熵字符串
    }

    /**
     * 严重程度
     */
    public enum Severity {
        CRITICAL,   // 严重：立即阻止
        HIGH,       // 高：阻止或脱敏
        MEDIUM,     // 中：警告或脱敏
        LOW         // 低：记录
    }

    /**
     * 检测规则接口
     */
    public interface DetectionRule {
        List<SensitiveMatch> detect(String content);
    }

    /**
     * 正则规则
     */
    public static class RegexRule implements DetectionRule {
        private final SensitiveType type;
        private final String name;
        private final Pattern pattern;
        private final Severity severity;

        public RegexRule(SensitiveType type, String name,
                        Pattern pattern, Severity severity) {
            this.type = type;
            this.name = name;
            this.pattern = pattern;
            this.severity = severity;
        }

        @Override
        public List<SensitiveMatch> detect(String content) {
            List<SensitiveMatch> matches = new ArrayList<>();
            Matcher matcher = pattern.matcher(content);

            while (matcher.find()) {
                matches.add(new SensitiveMatch(
                    type,
                    name,
                    matcher.group(),
                    matcher.start(),
                    matcher.end(),
                    severity,
                    Collections.emptyMap()
                ));
            }

            return matches;
        }
    }

    /**
     * 敏感信息匹配
     */
    public static class SensitiveMatch {
        private final SensitiveType type;
        private final String ruleName;
        private final String text;
        private final int start;
        private final int end;
        private final Severity severity;
        private final Map<String, Object> metadata;

        // Constructor, getters...
    }

    /**
     * 扫描结果
     */
    public static class ScanResult {
        private final List<SensitiveMatch> matches;

        public ScanResult(List<SensitiveMatch> matches) {
            this.matches = matches;
        }

        public boolean isEmpty() {
            return matches.isEmpty();
        }

        public boolean hasCritical() {
            return matches.stream()
                .anyMatch(m -> m.getSeverity() == Severity.CRITICAL);
        }

        public List<SensitiveMatch> getMatches() {
            return matches;
        }

        public Map<SensitiveType, Long> getTypeCount() {
            return matches.stream()
                .collect(Collectors.groupingBy(
                    SensitiveMatch::getType,
                    Collectors.counting()
                ));
        }
    }

    /**
     * 过滤策略
     */
    public static class FilterPolicy {

        private final Map<SensitiveType, String> replacements = new HashMap<>();

        public FilterPolicy() {
            // 默认替换策略
            replacements.put(SensitiveType.API_KEY, "[REDACTED_API_KEY]");
            replacements.put(SensitiveType.PASSWORD, "[REDACTED_PASSWORD]");
            replacements.put(SensitiveType.PRIVATE_KEY, "[REDACTED_PRIVATE_KEY]");
            replacements.put(SensitiveType.CREDIT_CARD, "[REDACTED_CARD]");
            replacements.put(SensitiveType.EMAIL, "[REDACTED_EMAIL]");
            replacements.put(SensitiveType.PHONE, "[REDACTED_PHONE]");
            replacements.put(SensitiveType.ID_CARD, "[REDACTED_ID]");
            replacements.put(SensitiveType.TOKEN, "[REDACTED_TOKEN]");
            replacements.put(SensitiveType.HIGH_ENTROPY_STRING, "[REDACTED_SECRET]");
        }

        public String getReplacementFor(SensitiveType type) {
            return replacements.getOrDefault(type, "[REDACTED]");
        }

        public void setReplacement(SensitiveType type, String replacement) {
            replacements.put(type, replacement);
        }
    }
}

/**
 * ML检测器（使用机器学习模型）
 */
public class MLDetector {

    /**
     * 使用ML模型检测敏感信息
     */
    public List<SensitiveInfoFilter.SensitiveMatch> detect(String content) {
        // TODO: 实现基于ML的检测
        // 可以使用预训练的NER模型识别敏感实体
        // 例如：HuggingFace Transformers, spaCy等

        return Collections.emptyList();
    }
}
```

## 4. 命令安全检查

### 4.1 命令过滤架构

```mermaid
graph TB
    subgraph "命令输入"
        Cmd[用户命令]
    end

    subgraph "预处理"
        Parse[解析命令]
        Tokenize[分词]
    end

    subgraph "检查层"
        WhiteCheck[白名单检查]
        BlackCheck[黑名单检查]
        PatternCheck[危险模式检查]
        InjectionCheck[注入检查]
    end

    subgraph "风险评估"
        RiskCalc[风险计算]
        Scoring[风险打分]
    end

    subgraph "决策"
        Allow[允许执行]
        Deny[拒绝执行]
        Confirm[需要确认]
    end

    Cmd --> Parse
    Parse --> Tokenize

    Tokenize --> WhiteCheck
    WhiteCheck -->|不在白名单| BlackCheck
    WhiteCheck -->|在白名单| Allow

    BlackCheck -->|在黑名单| Deny
    BlackCheck -->|不在黑名单| PatternCheck

    PatternCheck -->|危险模式| RiskCalc
    PatternCheck -->|安全| InjectionCheck

    InjectionCheck -->|有注入| Deny
    InjectionCheck -->|无注入| RiskCalc

    RiskCalc --> Scoring

    Scoring -->|低风险| Allow
    Scoring -->|中风险| Confirm
    Scoring -->|高风险| Deny

    style Cmd fill:#e1f5ff
    style WhiteCheck,BlackCheck,PatternCheck,InjectionCheck fill:#fff4e6
    style Allow fill:#e8f5e9
    style Deny fill:#ffebee
    style Confirm fill:#fff9c4
```

### 4.2 命令安全检查器实现

```java
/**
 * 命令安全检查器
 */
public class CommandSecurityChecker {

    private final CommandWhitelist whitelist;
    private final CommandBlacklist blacklist;
    private final List<DangerousPatternRule> patternRules;
    private final InjectionDetector injectionDetector;

    public CommandSecurityChecker() {
        this.whitelist = new CommandWhitelist();
        this.blacklist = new CommandBlacklist();
        this.patternRules = initializePatternRules();
        this.injectionDetector = new InjectionDetector();
    }

    /**
     * 检查命令
     */
    public SecurityCheckResult check(String command) {
        // 1. 解析命令
        ParsedCommand parsed = parseCommand(command);

        // 2. 白名单检查（快速通过）
        if (whitelist.contains(parsed.getBaseCommand())) {
            return SecurityCheckResult.allow("Command in whitelist");
        }

        // 3. 黑名单检查（快速拒绝）
        if (blacklist.contains(parsed.getBaseCommand())) {
            return SecurityCheckResult.deny(
                "Command in blacklist: " + parsed.getBaseCommand()
            );
        }

        // 4. 危险模式检查
        for (DangerousPatternRule rule : patternRules) {
            if (rule.matches(command)) {
                return SecurityCheckResult.deny(
                    "Dangerous pattern detected: " + rule.getDescription()
                );
            }
        }

        // 5. 注入检查
        if (injectionDetector.hasInjection(command)) {
            return SecurityCheckResult.deny("Command injection detected");
        }

        // 6. 风险评估
        int riskScore = calculateRiskScore(parsed);

        if (riskScore >= 80) {
            return SecurityCheckResult.deny("High risk command (score: " + riskScore + ")");
        } else if (riskScore >= 50) {
            return SecurityCheckResult.confirm(
                "Medium risk command (score: " + riskScore + ")",
                riskScore
            );
        } else {
            return SecurityCheckResult.allow("Low risk command");
        }
    }

    /**
     * 解析命令
     */
    private ParsedCommand parseCommand(String command) {
        // 移除前后空白
        command = command.trim();

        // 分离管道、重定向等
        List<String> segments = splitByOperators(command);

        // 解析第一个命令
        String firstSegment = segments.get(0).trim();
        String[] parts = firstSegment.split("\\s+");

        String baseCommand = parts[0];
        List<String> arguments = Arrays.asList(parts).subList(1, parts.length);

        return new ParsedCommand(
            command,
            baseCommand,
            arguments,
            segments
        );
    }

    /**
     * 按操作符分割
     */
    private List<String> splitByOperators(String command) {
        // 按 |, &&, ||, ;, >, >> 等分割
        List<String> segments = new ArrayList<>();
        StringBuilder current = new StringBuilder();
        boolean inQuote = false;
        char quoteChar = 0;

        for (int i = 0; i < command.length(); i++) {
            char c = command.charAt(i);

            // 处理引号
            if ((c == '"' || c == '\'') && (i == 0 || command.charAt(i - 1) != '\\')) {
                if (!inQuote) {
                    inQuote = true;
                    quoteChar = c;
                } else if (c == quoteChar) {
                    inQuote = false;
                }
            }

            // 在引号内，不分割
            if (inQuote) {
                current.append(c);
                continue;
            }

            // 检查操作符
            if (c == '|' || c == ';' || c == '>' || c == '&') {
                if (current.length() > 0) {
                    segments.add(current.toString());
                    current = new StringBuilder();
                }

                // 跳过双字符操作符的第二个字符
                if (i + 1 < command.length()) {
                    char next = command.charAt(i + 1);
                    if ((c == '|' && next == '|') ||
                        (c == '&' && next == '&') ||
                        (c == '>' && next == '>')) {
                        i++;
                    }
                }
            } else {
                current.append(c);
            }
        }

        if (current.length() > 0) {
            segments.add(current.toString());
        }

        return segments;
    }

    /**
     * 计算风险分数
     */
    private int calculateRiskScore(ParsedCommand parsed) {
        int score = 0;

        // 基础命令风险
        score += getCommandRisk(parsed.getBaseCommand());

        // 参数风险
        for (String arg : parsed.getArguments()) {
            score += getArgumentRisk(arg);
        }

        // 多命令链接
        if (parsed.getSegments().size() > 1) {
            score += 10 * (parsed.getSegments().size() - 1);
        }

        // 特殊字符
        if (containsSpecialChars(parsed.getFullCommand())) {
            score += 15;
        }

        // 权限提升
        if (hasPrivilegeEscalation(parsed)) {
            score += 50;
        }

        // 系统关键路径
        if (accessesCriticalPaths(parsed)) {
            score += 30;
        }

        return Math.min(score, 100);
    }

    /**
     * 获取命令风险
     */
    private int getCommandRisk(String command) {
        Map<String, Integer> riskMap = Map.ofEntries(
            // 低风险 (0-20)
            Map.entry("ls", 0),
            Map.entry("pwd", 0),
            Map.entry("echo", 0),
            Map.entry("cat", 5),
            Map.entry("grep", 5),
            Map.entry("find", 10),

            // 中风险 (20-50)
            Map.entry("git", 20),
            Map.entry("npm", 25),
            Map.entry("pip", 25),
            Map.entry("docker", 30),
            Map.entry("curl", 30),
            Map.entry("wget", 30),

            // 高风险 (50-100)
            Map.entry("rm", 60),
            Map.entry("chmod", 50),
            Map.entry("chown", 50),
            Map.entry("dd", 90),
            Map.entry("mkfs", 100),
            Map.entry("fdisk", 100),
            Map.entry("sudo", 80),
            Map.entry("su", 80)
        );

        return riskMap.getOrDefault(command, 40);  // 默认中等风险
    }

    /**
     * 获取参数风险
     */
    private int getArgumentRisk(String arg) {
        int risk = 0;

        // 递归删除
        if (arg.contains("-rf") || arg.contains("--recursive --force")) {
            risk += 30;
        }

        // 根目录操作
        if (arg.equals("/") || arg.startsWith("/etc") || arg.startsWith("/sys")) {
            risk += 40;
        }

        // 通配符
        if (arg.contains("*")) {
            risk += 10;
        }

        return risk;
    }

    /**
     * 检查是否包含特殊字符
     */
    private boolean containsSpecialChars(String command) {
        Pattern pattern = Pattern.compile("[`$()]");
        return pattern.matcher(command).find();
    }

    /**
     * 检查权限提升
     */
    private boolean hasPrivilegeEscalation(ParsedCommand parsed) {
        String cmd = parsed.getBaseCommand();
        return cmd.equals("sudo") || cmd.equals("su") || cmd.equals("doas");
    }

    /**
     * 检查是否访问关键路径
     */
    private boolean accessesCriticalPaths(ParsedCommand parsed) {
        String fullCommand = parsed.getFullCommand();

        List<String> criticalPaths = List.of(
            "/etc", "/sys", "/proc", "/dev",
            "/boot", "/root", "C:\\Windows", "C:\\System32"
        );

        for (String path : criticalPaths) {
            if (fullCommand.contains(path)) {
                return true;
            }
        }

        return false;
    }

    /**
     * 初始化危险模式规则
     */
    private List<DangerousPatternRule> initializePatternRules() {
        return List.of(
            // Fork Bomb
            new DangerousPatternRule(
                "Fork Bomb",
                Pattern.compile(":\\(\\)\\s*\\{\\s*:|:\\|:\\&"),
                "Potential fork bomb detected"
            ),

            // 删除根目录
            new DangerousPatternRule(
                "Delete Root",
                Pattern.compile("rm\\s+(-[rf]+\\s+)?/($|\\s)"),
                "Attempting to delete root directory"
            ),

            // 格式化磁盘
            new DangerousPatternRule(
                "Format Disk",
                Pattern.compile("(mkfs|fdisk|parted).*\\/dev\\/(sd|hd|nvme)"),
                "Attempting to format disk"
            ),

            // 覆盖磁盘
            new DangerousPatternRule(
                "Overwrite Disk",
                Pattern.compile("dd.*of=\\/dev\\/(sd|hd|nvme)"),
                "Attempting to overwrite disk"
            ),

            // 修改系统文件
            new DangerousPatternRule(
                "Modify System Files",
                Pattern.compile("(>|>>)\\s*\\/etc\\/"),
                "Attempting to modify system configuration"
            ),

            // 添加用户
            new DangerousPatternRule(
                "Add User",
                Pattern.compile("useradd|adduser"),
                "Attempting to add system user"
            ),

            // 修改密码
            new DangerousPatternRule(
                "Change Password",
                Pattern.compile("passwd|chpasswd"),
                "Attempting to change password"
            ),

            // Cron任务
            new DangerousPatternRule(
                "Cron Job",
                Pattern.compile("crontab\\s+-e"),
                "Attempting to modify cron jobs"
            ),

            // 下载并执行
            new DangerousPatternRule(
                "Download and Execute",
                Pattern.compile("(curl|wget).*\\|.*bash"),
                "Downloading and executing script"
            )
        );
    }

    /**
     * 解析后的命令
     */
    public static class ParsedCommand {
        private final String fullCommand;
        private final String baseCommand;
        private final List<String> arguments;
        private final List<String> segments;

        // Constructor, getters...
    }

    /**
     * 安全检查结果
     */
    public static class SecurityCheckResult {
        private final ResultType type;
        private final String reason;
        private final int riskScore;

        public static SecurityCheckResult allow(String reason) {
            return new SecurityCheckResult(ResultType.ALLOW, reason, 0);
        }

        public static SecurityCheckResult deny(String reason) {
            return new SecurityCheckResult(ResultType.DENY, reason, 100);
        }

        public static SecurityCheckResult confirm(String reason, int riskScore) {
            return new SecurityCheckResult(ResultType.CONFIRM, reason, riskScore);
        }

        public boolean isAllowed() {
            return type == ResultType.ALLOW;
        }

        public boolean needsConfirmation() {
            return type == ResultType.CONFIRM;
        }

        public enum ResultType {
            ALLOW,      // 允许
            DENY,       // 拒绝
            CONFIRM     // 需要确认
        }
    }

    /**
     * 危险模式规则
     */
    public static class DangerousPatternRule {
        private final String name;
        private final Pattern pattern;
        private final String description;

        public DangerousPatternRule(String name, Pattern pattern, String description) {
            this.name = name;
            this.pattern = pattern;
            this.description = description;
        }

        public boolean matches(String command) {
            return pattern.matcher(command).find();
        }

        public String getDescription() {
            return description;
        }
    }
}

/**
 * 命令白名单
 */
public class CommandWhitelist {

    private final Set<String> whitelist = Set.of(
        // 查看命令
        "ls", "pwd", "cat", "echo", "head", "tail",
        "less", "more", "wc", "grep", "find",

        // Git命令（只读）
        "git status", "git log", "git diff", "git show",
        "git branch", "git remote",

        // 包管理器（只读）
        "npm list", "pip list", "maven --version",

        // 系统信息
        "uname", "date", "whoami", "hostname"
    );

    public boolean contains(String command) {
        return whitelist.contains(command);
    }
}

/**
 * 命令黑名单
 */
public class CommandBlacklist {

    private final Set<String> blacklist = Set.of(
        // 系统破坏
        "mkfs", "fdisk", "parted", "dd",

        // 用户管理
        "useradd", "userdel", "adduser", "deluser",
        "passwd", "chpasswd",

        // 服务管理
        "systemctl", "service", "init",

        // 网络攻击
        "nc", "netcat", "nmap", "tcpdump",

        // 编译器（防止现场编译恶意代码）
        "gcc", "g++", "clang", "javac"
    );

    public boolean contains(String command) {
        return blacklist.contains(command);
    }
}

/**
 * 注入检测器
 */
public class InjectionDetector {

    /**
     * 检查命令注入
     */
    public boolean hasInjection(String command) {
        // 检查嵌套命令
        if (hasNestedCommand(command)) {
            return true;
        }

        // 检查路径遍历
        if (hasPathTraversal(command)) {
            return true;
        }

        // 检查Unicode混淆
        if (hasUnicodeObfuscation(command)) {
            return true;
        }

        return false;
    }

    /**
     * 检查嵌套命令
     */
    private boolean hasNestedCommand(String command) {
        // 检查反引号
        if (command.contains("`")) {
            return true;
        }

        // 检查$()
        if (command.contains("$(")) {
            return true;
        }

        return false;
    }

    /**
     * 检查路径遍历
     */
    private boolean hasPathTraversal(String command) {
        // 检查../
        Pattern pattern = Pattern.compile("\\.\\.[\\/\\\\]");
        return pattern.matcher(command).find();
    }

    /**
     * 检查Unicode混淆
     */
    private boolean hasUnicodeObfuscation(String command) {
        // 检查零宽字符
        return command.contains("\u200B") ||  // 零宽空格
               command.contains("\u200C") ||  // 零宽非连接符
               command.contains("\u200D") ||  // 零宽连接符
               command.contains("\uFEFF");    // 零宽非断空格
    }
}
```

## 5. 文件访问权限控制

### 5.1 文件访问控制架构

```mermaid
graph TB
    subgraph "文件请求"
        Req[文件操作请求]
    end

    subgraph "路径解析"
        Resolve[解析路径]
        Canonicalize[规范化]
        Validate[验证有效性]
    end

    subgraph "权限检查"
        SandboxCheck[沙箱检查]
        OwnerCheck[所有者检查]
        PermCheck[权限检查]
    end

    subgraph "敏感文件检查"
        SensFile[敏感文件检测]
        ExtCheck[扩展名检查]
    end

    subgraph "决策"
        Allow[允许访问]
        Deny[拒绝访问]
        AuditLog[记录审计]
    end

    Req --> Resolve
    Resolve --> Canonicalize
    Canonicalize --> Validate

    Validate --> SandboxCheck
    SandboxCheck -->|越界| Deny
    SandboxCheck -->|合法| OwnerCheck

    OwnerCheck --> PermCheck
    PermCheck --> SensFile

    SensFile -->|敏感文件| Deny
    SensFile -->|普通文件| ExtCheck

    ExtCheck -->|危险扩展名| Deny
    ExtCheck -->|安全扩展名| Allow

    Allow --> AuditLog
    Deny --> AuditLog

    style Req fill:#e1f5ff
    style SandboxCheck,OwnerCheck,PermCheck fill:#fff4e6
    style Allow fill:#e8f5e9
    style Deny fill:#ffebee
```

### 5.2 文件访问控制器实现

```java
/**
 * 文件访问控制器
 */
public class FileAccessController {

    private final Path sandboxRoot;
    private final SensitiveFileDetector sensitiveDetector;
    private final FilePermissionChecker permissionChecker;
    private final AuditLogger auditLogger;

    public FileAccessController(String projectRoot) {
        this.sandboxRoot = Paths.get(projectRoot).toAbsolutePath().normalize();
        this.sensitiveDetector = new SensitiveFileDetector();
        this.permissionChecker = new FilePermissionChecker();
        this.auditLogger = AuditLogger.getInstance();
    }

    /**
     * 检查文件访问权限
     */
    public AccessCheckResult checkAccess(
            String filePath,
            AccessType accessType) {

        try {
            // 1. 解析和规范化路径
            Path resolvedPath = resolveAndValidatePath(filePath);

            // 2. 沙箱检查
            if (!isWithinSandbox(resolvedPath)) {
                return AccessCheckResult.deny(
                    "Path is outside sandbox: " + resolvedPath,
                    AccessDenialReason.OUTSIDE_SANDBOX
                );
            }

            // 3. 敏感文件检查
            if (sensitiveDetector.isSensitive(resolvedPath)) {
                return AccessCheckResult.deny(
                    "Access to sensitive file denied: " + resolvedPath.getFileName(),
                    AccessDenialReason.SENSITIVE_FILE
                );
            }

            // 4. 文件扩展名检查
            if (isDangerousExtension(resolvedPath)) {
                return AccessCheckResult.deny(
                    "Dangerous file extension: " + getExtension(resolvedPath),
                    AccessDenialReason.DANGEROUS_EXTENSION
                );
            }

            // 5. 系统权限检查
            if (!permissionChecker.hasPermission(resolvedPath, accessType)) {
                return AccessCheckResult.deny(
                    "Insufficient file system permissions",
                    AccessDenialReason.NO_PERMISSION
                );
            }

            // 6. 大小限制检查（读取时）
            if (accessType == AccessType.READ && Files.exists(resolvedPath)) {
                long size = Files.size(resolvedPath);
                if (size > 100 * 1024 * 1024) {  // 100MB
                    return AccessCheckResult.deny(
                        "File too large: " + formatSize(size),
                        AccessDenialReason.FILE_TOO_LARGE
                    );
                }
            }

            // 记录审计
            auditLogger.logFileAccess(
                resolvedPath.toString(),
                accessType,
                AccessResult.ALLOWED
            );

            return AccessCheckResult.allow(resolvedPath);

        } catch (Exception e) {
            return AccessCheckResult.deny(
                "Error checking file access: " + e.getMessage(),
                AccessDenialReason.ERROR
            );
        }
    }

    /**
     * 解析和验证路径
     */
    private Path resolveAndValidatePath(String filePath) throws IOException {
        // 展开用户主目录
        if (filePath.startsWith("~/")) {
            filePath = System.getProperty("user.home") + filePath.substring(1);
        }

        Path path = Paths.get(filePath);

        // 如果是相对路径，相对于沙箱根目录解析
        if (!path.isAbsolute()) {
            path = sandboxRoot.resolve(path);
        }

        // 规范化路径（解析 .., . 等）
        path = path.normalize();

        // 解析符号链接
        if (Files.exists(path)) {
            path = path.toRealPath();
        }

        return path;
    }

    /**
     * 检查是否在沙箱内
     */
    private boolean isWithinSandbox(Path path) {
        return path.startsWith(sandboxRoot);
    }

    /**
     * 检查是否是危险扩展名
     */
    private boolean isDangerousExtension(Path path) {
        String ext = getExtension(path);

        Set<String> dangerousExtensions = Set.of(
            // 可执行文件
            "exe", "dll", "so", "dylib", "app",

            // 脚本（取决于策略，可能允许）
            // "sh", "bash", "bat", "cmd", "ps1",

            // 系统文件
            "sys", "drv",

            // 数据库
            "db", "sqlite", "mdb"
        );

        return dangerousExtensions.contains(ext.toLowerCase());
    }

    /**
     * 获取文件扩展名
     */
    private String getExtension(Path path) {
        String fileName = path.getFileName().toString();
        int dotIndex = fileName.lastIndexOf('.');
        if (dotIndex > 0 && dotIndex < fileName.length() - 1) {
            return fileName.substring(dotIndex + 1);
        }
        return "";
    }

    /**
     * 格式化文件大小
     */
    private String formatSize(long bytes) {
        if (bytes < 1024) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(1024));
        char pre = "KMGTPE".charAt(exp - 1);
        return String.format("%.1f %cB", bytes / Math.pow(1024, exp), pre);
    }

    /**
     * 访问类型
     */
    public enum AccessType {
        READ,       // 读取
        WRITE,      // 写入
        EXECUTE,    // 执行
        DELETE      // 删除
    }

    /**
     * 访问检查结果
     */
    public static class AccessCheckResult {
        private final boolean allowed;
        private final String reason;
        private final Path resolvedPath;
        private final AccessDenialReason denialReason;

        public static AccessCheckResult allow(Path resolvedPath) {
            return new AccessCheckResult(true, null, resolvedPath, null);
        }

        public static AccessCheckResult deny(String reason, AccessDenialReason denialReason) {
            return new AccessCheckResult(false, reason, null, denialReason);
        }

        public boolean isAllowed() {
            return allowed;
        }

        // Getters...
    }

    /**
     * 拒绝原因
     */
    public enum AccessDenialReason {
        OUTSIDE_SANDBOX,        // 沙箱外
        SENSITIVE_FILE,         // 敏感文件
        DANGEROUS_EXTENSION,    // 危险扩展名
        NO_PERMISSION,          // 无权限
        FILE_TOO_LARGE,         // 文件过大
        ERROR                   // 错误
    }
}

/**
 * 敏感文件检测器
 */
public class SensitiveFileDetector {

    private final Set<String> sensitiveFileNames = Set.of(
        // 密钥和证书
        ".ssh/id_rsa", ".ssh/id_ed25519", ".ssh/id_ecdsa",
        "private-key.pem", "certificate.pem",

        // 配置文件
        ".env", ".env.local", ".env.production",
        "secrets.yml", "secrets.yaml",
        "credentials.json", "service-account.json",

        // 数据库
        ".pgpass", ".my.cnf",

        // AWS
        ".aws/credentials", ".aws/config",

        // Docker
        "docker-compose.override.yml",

        // Git
        ".git/config"
    );

    private final Set<Pattern> sensitivePatterns = Set.of(
        Pattern.compile(".*\\.key$"),
        Pattern.compile(".*\\.pem$"),
        Pattern.compile(".*\\.p12$"),
        Pattern.compile(".*\\.pfx$"),
        Pattern.compile(".*secret.*", Pattern.CASE_INSENSITIVE),
        Pattern.compile(".*password.*", Pattern.CASE_INSENSITIVE),
        Pattern.compile(".*credential.*", Pattern.CASE_INSENSITIVE)
    );

    /**
     * 检查是否是敏感文件
     */
    public boolean isSensitive(Path path) {
        String pathStr = path.toString();
        String fileName = path.getFileName().toString();

        // 检查文件名
        if (sensitiveFileNames.contains(fileName)) {
            return true;
        }

        // 检查相对路径
        for (String sensitiveName : sensitiveFileNames) {
            if (pathStr.endsWith(sensitiveName)) {
                return true;
            }
        }

        // 检查模式
        for (Pattern pattern : sensitivePatterns) {
            if (pattern.matcher(fileName).matches()) {
                return true;
            }
        }

        return false;
    }
}

/**
 * 文件权限检查器
 */
public class FilePermissionChecker {

    /**
     * 检查是否有指定权限
     */
    public boolean hasPermission(Path path, FileAccessController.AccessType accessType) {
        try {
            switch (accessType) {
                case READ:
                    return Files.isReadable(path);

                case WRITE:
                    if (Files.exists(path)) {
                        return Files.isWritable(path);
                    } else {
                        // 检查父目录是否可写
                        return Files.isWritable(path.getParent());
                    }

                case EXECUTE:
                    return Files.isExecutable(path);

                case DELETE:
                    return Files.isWritable(path.getParent());

                default:
                    return false;
            }
        } catch (Exception e) {
            return false;
        }
    }
}
```

## 6. 用户确认机制 (Hooks系统)

### 6.1 Hooks系统架构

```mermaid
graph TB
    subgraph "操作触发"
        Op[危险操作]
    end

    subgraph "Hook触发"
        Detect[检测到危险操作]
        CreateHook[创建Hook]
    end

    subgraph "用户交互"
        ShowPrompt[显示确认提示]
        UserDecision{用户决策}
    end

    subgraph "决策处理"
        Remember[记住选择]
        Execute[执行操作]
        Cancel[取消操作]
    end

    subgraph "审计"
        Log[记录决策]
    end

    Op --> Detect
    Detect --> CreateHook
    CreateHook --> ShowPrompt

    ShowPrompt --> UserDecision

    UserDecision -->|确认| Remember
    UserDecision -->|拒绝| Cancel
    UserDecision -->|总是允许| Remember

    Remember --> Execute
    Execute --> Log
    Cancel --> Log

    style Op fill:#e1f5ff
    style ShowPrompt fill:#fff4e6
    style Execute fill:#e8f5e9
    style Cancel fill:#ffebee
```

### 6.2 Hooks系统实现

```java
/**
 * 用户确认Hooks系统
 */
public class ConfirmationHookSystem {

    private final HookRegistry hookRegistry;
    private final UserInteraction userInteraction;
    private final DecisionMemory decisionMemory;
    private final AuditLogger auditLogger;

    public ConfirmationHookSystem() {
        this.hookRegistry = new HookRegistry();
        this.userInteraction = new UserInteraction();
        this.decisionMemory = new DecisionMemory();
        this.auditLogger = AuditLogger.getInstance();

        // 注册默认Hooks
        registerDefaultHooks();
    }

    /**
     * 注册Hook
     */
    public void registerHook(String operationType, ConfirmationHook hook) {
        hookRegistry.register(operationType, hook);
    }

    /**
     * 请求确认
     */
    public boolean requestConfirmation(
            String operationType,
            OperationContext context) {

        // 1. 检查是否有记住的决策
        Decision remembered = decisionMemory.getDecision(operationType, context);
        if (remembered != null) {
            auditLogger.logHookDecision(
                operationType,
                context,
                remembered,
                true  // 使用缓存
            );
            return remembered.isAllowed();
        }

        // 2. 获取Hook
        ConfirmationHook hook = hookRegistry.getHook(operationType);
        if (hook == null) {
            // 无Hook，默认允许
            return true;
        }

        // 3. 构建确认提示
        ConfirmationPrompt prompt = hook.buildPrompt(context);

        // 4. 显示提示并获取用户决策
        UserDecision decision = userInteraction.prompt(prompt);

        // 5. 处理决策
        boolean allowed = decision.getChoice() == Choice.ALLOW ||
                         decision.getChoice() == Choice.ALWAYS_ALLOW;

        // 6. 记住决策（如果用户选择）
        if (decision.getChoice() == Choice.ALWAYS_ALLOW ||
            decision.getChoice() == Choice.NEVER_ALLOW) {
            decisionMemory.remember(
                operationType,
                context,
                new Decision(allowed, decision.getReason())
            );
        }

        // 7. 记录审计
        auditLogger.logHookDecision(
            operationType,
            context,
            new Decision(allowed, decision.getReason()),
            false  // 非缓存
        );

        return allowed;
    }

    /**
     * 注册默认Hooks
     */
    private void registerDefaultHooks() {
        // 文件删除Hook
        registerHook("file.delete", new FileDeletionHook());

        // 命令执行Hook（高风险命令）
        registerHook("command.execute.high_risk", new HighRiskCommandHook());

        // 网络请求Hook
        registerHook("network.request", new NetworkRequestHook());

        // Git操作Hook
        registerHook("git.commit", new GitCommitHook());
        registerHook("git.push", new GitPushHook());

        // 包安装Hook
        registerHook("package.install", new PackageInstallHook());
    }

    /**
     * Hook接口
     */
    public interface ConfirmationHook {
        /**
         * 构建确认提示
         */
        ConfirmationPrompt buildPrompt(OperationContext context);

        /**
         * 是否应该触发Hook
         */
        boolean shouldTrigger(OperationContext context);
    }

    /**
     * 文件删除Hook
     */
    public static class FileDeletionHook implements ConfirmationHook {

        @Override
        public ConfirmationPrompt buildPrompt(OperationContext context) {
            String filePath = context.getString("filePath");
            boolean isDirectory = context.getBoolean("isDirectory", false);
            int fileCount = context.getInt("fileCount", 1);

            String message = isDirectory ?
                String.format(
                    "Delete directory '%s' and all its contents (%d files)?",
                    filePath, fileCount
                ) :
                String.format("Delete file '%s'?", filePath);

            return ConfirmationPrompt.builder()
                .title("Confirm File Deletion")
                .message(message)
                .severity(isDirectory || fileCount > 10 ? Severity.HIGH : Severity.MEDIUM)
                .options(List.of(
                    PromptOption.ALLOW,
                    PromptOption.DENY,
                    PromptOption.ALWAYS_ALLOW_FOR_SESSION
                ))
                .defaultOption(PromptOption.DENY)
                .build();
        }

        @Override
        public boolean shouldTrigger(OperationContext context) {
            // 删除多个文件或删除目录时触发
            boolean isDirectory = context.getBoolean("isDirectory", false);
            int fileCount = context.getInt("fileCount", 1);

            return isDirectory || fileCount > 1;
        }
    }

    /**
     * 高风险命令Hook
     */
    public static class HighRiskCommandHook implements ConfirmationHook {

        @Override
        public ConfirmationPrompt buildPrompt(OperationContext context) {
            String command = context.getString("command");
            int riskScore = context.getInt("riskScore", 0);
            String riskReason = context.getString("riskReason");

            return ConfirmationPrompt.builder()
                .title("Confirm High-Risk Command")
                .message(String.format(
                    "Execute high-risk command (risk score: %d)?\n\nCommand: %s\n\nReason: %s",
                    riskScore, command, riskReason
                ))
                .severity(Severity.HIGH)
                .options(List.of(
                    PromptOption.ALLOW,
                    PromptOption.DENY
                ))
                .defaultOption(PromptOption.DENY)
                .build();
        }

        @Override
        public boolean shouldTrigger(OperationContext context) {
            return true;  // 高风险命令总是触发
        }
    }

    /**
     * Git Push Hook
     */
    public static class GitPushHook implements ConfirmationHook {

        @Override
        public ConfirmationPrompt buildPrompt(OperationContext context) {
            String branch = context.getString("branch");
            String remote = context.getString("remote");
            boolean isForce = context.getBoolean("isForce", false);

            String message = isForce ?
                String.format(
                    "Force push to %s/%s?\n\nWARNING: This may overwrite remote history!",
                    remote, branch
                ) :
                String.format("Push to %s/%s?", remote, branch);

            return ConfirmationPrompt.builder()
                .title("Confirm Git Push")
                .message(message)
                .severity(isForce ? Severity.CRITICAL : Severity.MEDIUM)
                .options(List.of(
                    PromptOption.ALLOW,
                    PromptOption.DENY,
                    isForce ? null : PromptOption.ALWAYS_ALLOW_FOR_SESSION
                ))
                .defaultOption(isForce ? PromptOption.DENY : PromptOption.ALLOW)
                .build();
        }

        @Override
        public boolean shouldTrigger(OperationContext context) {
            boolean isForce = context.getBoolean("isForce", false);
            String branch = context.getString("branch");

            // Force push 或推送到main/master总是触发
            return isForce || branch.equals("main") || branch.equals("master");
        }
    }

    /**
     * 操作上下文
     */
    public static class OperationContext {
        private final Map<String, Object> data = new HashMap<>();

        public void set(String key, Object value) {
            data.put(key, value);
        }

        public String getString(String key) {
            return (String) data.get(key);
        }

        public int getInt(String key, int defaultValue) {
            Object value = data.get(key);
            return value instanceof Integer ? (Integer) value : defaultValue;
        }

        public boolean getBoolean(String key, boolean defaultValue) {
            Object value = data.get(key);
            return value instanceof Boolean ? (Boolean) value : defaultValue;
        }

        // 用于决策记忆的唯一标识
        public String getFingerprint() {
            // 生成上下文指纹
            return data.entrySet().stream()
                .sorted(Map.Entry.comparingByKey())
                .map(e -> e.getKey() + "=" + e.getValue())
                .collect(Collectors.joining(","));
        }
    }

    /**
     * 确认提示
     */
    public static class ConfirmationPrompt {
        private final String title;
        private final String message;
        private final Severity severity;
        private final List<PromptOption> options;
        private final PromptOption defaultOption;

        // Builder pattern...
    }

    /**
     * 提示选项
     */
    public enum PromptOption {
        ALLOW("Allow"),
        DENY("Deny"),
        ALWAYS_ALLOW("Always Allow"),
        NEVER_ALLOW("Never Allow"),
        ALWAYS_ALLOW_FOR_SESSION("Allow for This Session");

        private final String label;

        PromptOption(String label) {
            this.label = label;
        }

        public String getLabel() {
            return label;
        }
    }

    /**
     * 用户决策
     */
    public static class UserDecision {
        private final Choice choice;
        private final String reason;

        public UserDecision(Choice choice, String reason) {
            this.choice = choice;
            this.reason = reason;
        }

        public Choice getChoice() {
            return choice;
        }

        public String getReason() {
            return reason;
        }
    }

    /**
     * 选择枚举
     */
    public enum Choice {
        ALLOW,
        DENY,
        ALWAYS_ALLOW,
        NEVER_ALLOW
    }

    /**
     * Hook注册表
     */
    public static class HookRegistry {
        private final Map<String, ConfirmationHook> hooks = new ConcurrentHashMap<>();

        public void register(String operationType, ConfirmationHook hook) {
            hooks.put(operationType, hook);
        }

        public ConfirmationHook getHook(String operationType) {
            return hooks.get(operationType);
        }
    }

    /**
     * 决策记忆
     */
    public static class DecisionMemory {
        private final Map<String, Decision> decisions = new ConcurrentHashMap<>();

        public void remember(String operationType, OperationContext context, Decision decision) {
            String key = operationType + ":" + context.getFingerprint();
            decisions.put(key, decision);
        }

        public Decision getDecision(String operationType, OperationContext context) {
            String key = operationType + ":" + context.getFingerprint();
            return decisions.get(key);
        }

        public void clear() {
            decisions.clear();
        }
    }

    /**
     * 决策
     */
    public static class Decision {
        private final boolean allowed;
        private final String reason;
        private final long timestamp;

        public Decision(boolean allowed, String reason) {
            this.allowed = allowed;
            this.reason = reason;
            this.timestamp = System.currentTimeMillis();
        }

        public boolean isAllowed() {
            return allowed;
        }

        // Getters...
    }
}

/**
 * 用户交互接口
 */
public class UserInteraction {

    /**
     * 显示确认提示
     */
    public ConfirmationHookSystem.UserDecision prompt(
            ConfirmationHookSystem.ConfirmationPrompt prompt) {

        System.out.println("\n" + "=".repeat(60));
        System.out.println(prompt.getTitle());
        System.out.println("=".repeat(60));
        System.out.println("\n" + prompt.getMessage());
        System.out.println("\nSeverity: " + prompt.getSeverity());
        System.out.println("\nOptions:");

        List<ConfirmationHookSystem.PromptOption> options = prompt.getOptions();
        for (int i = 0; i < options.size(); i++) {
            ConfirmationHookSystem.PromptOption option = options.get(i);
            if (option != null) {
                String marker = option == prompt.getDefaultOption() ? "*" : " ";
                System.out.printf("  %s[%d] %s\n", marker, i + 1, option.getLabel());
            }
        }

        System.out.print("\nYour choice: ");

        // 读取用户输入
        Scanner scanner = new Scanner(System.in);
        int choice = scanner.nextInt();

        if (choice < 1 || choice > options.size()) {
            choice = options.indexOf(prompt.getDefaultOption()) + 1;
        }

        ConfirmationHookSystem.PromptOption selected = options.get(choice - 1);

        // 转换为Choice
        ConfirmationHookSystem.Choice choiceEnum = switch (selected) {
            case ALLOW -> ConfirmationHookSystem.Choice.ALLOW;
            case DENY -> ConfirmationHookSystem.Choice.DENY;
            case ALWAYS_ALLOW -> ConfirmationHookSystem.Choice.ALWAYS_ALLOW;
            case NEVER_ALLOW -> ConfirmationHookSystem.Choice.NEVER_ALLOW;
            case ALWAYS_ALLOW_FOR_SESSION -> ConfirmationHookSystem.Choice.ALWAYS_ALLOW;
        };

        return new ConfirmationHookSystem.UserDecision(
            choiceEnum,
            "User selected: " + selected.getLabel()
        );
    }
}
```

## 7. 审计日志系统

### 7.1 审计日志架构

```mermaid
graph LR
    subgraph "事件源"
        E1[文件操作]
        E2[命令执行]
        E3[API调用]
        E4[权限检查]
    end

    subgraph "日志收集"
        Collector[事件收集器]
        Buffer[缓冲队列]
    end

    subgraph "日志处理"
        Filter[过滤器]
        Enricher[增强器]
        Formatter[格式化器]
    end

    subgraph "日志存储"
        FileLog[文件日志]
        DBLog[数据库]
        RemoteLog[远程日志服务]
    end

    subgraph "监控告警"
        Monitor[实时监控]
        Alert[异常告警]
    end

    E1 --> Collector
    E2 --> Collector
    E3 --> Collector
    E4 --> Collector

    Collector --> Buffer
    Buffer --> Filter
    Filter --> Enricher
    Enricher --> Formatter

    Formatter --> FileLog
    Formatter --> DBLog
    Formatter --> RemoteLog

    FileLog --> Monitor
    Monitor --> Alert

    style Collector fill:#e1f5ff
    style Filter,Enricher,Formatter fill:#fff4e6
    style FileLog,DBLog,RemoteLog fill:#e8f5e9
```

### 7.2 审计日志实现

```java
/**
 * 审计日志系统
 */
public class AuditLogger {

    private static final AuditLogger INSTANCE = new AuditLogger();

    private final BlockingQueue<AuditEvent> eventQueue;
    private final ExecutorService logWriter;
    private final List<AuditLogWriter> writers;
    private final AuditConfig config;

    private AuditLogger() {
        this.eventQueue = new LinkedBlockingQueue<>(10000);
        this.logWriter = Executors.newSingleThreadExecutor();
        this.writers = new ArrayList<>();
        this.config = AuditConfig.load();

        // 初始化writers
        initializeWriters();

        // 启动日志写入线程
        startLogWriter();
    }

    public static AuditLogger getInstance() {
        return INSTANCE;
    }

    /**
     * 记录文件访问
     */
    public void logFileAccess(String filePath,
                             FileAccessController.AccessType accessType,
                             AccessResult result) {
        AuditEvent event = AuditEvent.builder()
            .eventType(EventType.FILE_ACCESS)
            .timestamp(Instant.now())
            .severity(Severity.INFO)
            .data(Map.of(
                "filePath", filePath,
                "accessType", accessType.name(),
                "result", result.name()
            ))
            .build();

        logEvent(event);
    }

    /**
     * 记录命令执行
     */
    public void logCommandExecution(String command,
                                   int exitCode,
                                   long executionTime) {
        AuditEvent event = AuditEvent.builder()
            .eventType(EventType.COMMAND_EXECUTION)
            .timestamp(Instant.now())
            .severity(exitCode == 0 ? Severity.INFO : Severity.WARNING)
            .data(Map.of(
                "command", command,
                "exitCode", exitCode,
                "executionTimeMs", executionTime
            ))
            .build();

        logEvent(event);
    }

    /**
     * 记录API调用
     */
    public void logApiCall(String endpoint,
                          int statusCode,
                          long responseTime) {
        AuditEvent event = AuditEvent.builder()
            .eventType(EventType.API_CALL)
            .timestamp(Instant.now())
            .severity(statusCode >= 400 ? Severity.WARNING : Severity.INFO)
            .data(Map.of(
                "endpoint", endpoint,
                "statusCode", statusCode,
                "responseTimeMs", responseTime
            ))
            .build();

        logEvent(event);
    }

    /**
     * 记录Hook决策
     */
    public void logHookDecision(String operationType,
                               ConfirmationHookSystem.OperationContext context,
                               ConfirmationHookSystem.Decision decision,
                               boolean cached) {
        AuditEvent event = AuditEvent.builder()
            .eventType(EventType.HOOK_DECISION)
            .timestamp(Instant.now())
            .severity(decision.isAllowed() ? Severity.INFO : Severity.WARNING)
            .data(Map.of(
                "operationType", operationType,
                "decision", decision.isAllowed() ? "ALLOW" : "DENY",
                "reason", decision.getReason(),
                "cached", cached
            ))
            .build();

        logEvent(event);
    }

    /**
     * 记录安全事件
     */
    public void logSecurityEvent(String eventName,
                                Severity severity,
                                Map<String, Object> details) {
        AuditEvent event = AuditEvent.builder()
            .eventType(EventType.SECURITY)
            .timestamp(Instant.now())
            .severity(severity)
            .data(new HashMap<>(details))
            .build();

        event.getData().put("eventName", eventName);

        logEvent(event);
    }

    /**
     * 记录事件
     */
    private void logEvent(AuditEvent event) {
        // 添加上下文信息
        enrichEvent(event);

        // 放入队列
        try {
            if (!eventQueue.offer(event, 1, TimeUnit.SECONDS)) {
                System.err.println("Audit event queue full, event dropped: " + event);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    /**
     * 增强事件（添加上下文信息）
     */
    private void enrichEvent(AuditEvent event) {
        event.getData().put("hostname", getHostname());
        event.getData().put("username", System.getProperty("user.name"));
        event.getData().put("pid", ProcessHandle.current().pid());
        event.getData().put("threadId", Thread.currentThread().getId());
    }

    /**
     * 初始化Writers
     */
    private void initializeWriters() {
        // 文件Writer
        if (config.isFileLoggingEnabled()) {
            writers.add(new FileAuditWriter(config.getLogFilePath()));
        }

        // 数据库Writer（可选）
        if (config.isDatabaseLoggingEnabled()) {
            writers.add(new DatabaseAuditWriter(config.getDatabaseConfig()));
        }

        // 控制台Writer（调试）
        if (config.isConsoleLoggingEnabled()) {
            writers.add(new ConsoleAuditWriter());
        }
    }

    /**
     * 启动日志写入线程
     */
    private void startLogWriter() {
        logWriter.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    AuditEvent event = eventQueue.take();

                    // 写入所有writers
                    for (AuditLogWriter writer : writers) {
                        try {
                            writer.write(event);
                        } catch (Exception e) {
                            System.err.println("Failed to write audit log: " + e.getMessage());
                        }
                    }

                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
    }

    /**
     * 关闭
     */
    public void shutdown() {
        logWriter.shutdown();

        try {
            logWriter.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            logWriter.shutdownNow();
        }

        // 关闭所有writers
        writers.forEach(AuditLogWriter::close);
    }

    private String getHostname() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            return "unknown";
        }
    }

    /**
     * 审计事件
     */
    public static class AuditEvent {
        private final EventType eventType;
        private final Instant timestamp;
        private final Severity severity;
        private final Map<String, Object> data;

        // Builder pattern...

        public String toJson() {
            // 使用JSON库序列化
            return "{}";  // TODO: 实现JSON序列化
        }
    }

    /**
     * 事件类型
     */
    public enum EventType {
        FILE_ACCESS,
        COMMAND_EXECUTION,
        API_CALL,
        HOOK_DECISION,
        SECURITY,
        ERROR
    }

    /**
     * 访问结果
     */
    public enum AccessResult {
        ALLOWED,
        DENIED
    }

    /**
     * Writer接口
     */
    public interface AuditLogWriter {
        void write(AuditEvent event) throws IOException;
        void close();
    }

    /**
     * 文件Writer
     */
    public static class FileAuditWriter implements AuditLogWriter {

        private final Path logFilePath;
        private final FileChannel fileChannel;

        public FileAuditWriter(String logFilePath) throws IOException {
            this.logFilePath = Paths.get(logFilePath);

            // 创建日志目录
            Files.createDirectories(this.logFilePath.getParent());

            // 打开文件
            this.fileChannel = FileChannel.open(
                this.logFilePath,
                StandardOpenOption.CREATE,
                StandardOpenOption.APPEND
            );
        }

        @Override
        public void write(AuditEvent event) throws IOException {
            String line = formatEvent(event) + "\n";
            ByteBuffer buffer = ByteBuffer.wrap(line.getBytes(StandardCharsets.UTF_8));
            fileChannel.write(buffer);
        }

        private String formatEvent(AuditEvent event) {
            // 格式：[timestamp] [severity] [eventType] data
            return String.format(
                "[%s] [%s] [%s] %s",
                event.getTimestamp().toString(),
                event.getSeverity(),
                event.getEventType(),
                event.toJson()
            );
        }

        @Override
        public void close() {
            try {
                fileChannel.close();
            } catch (IOException e) {
                // Ignore
            }
        }
    }

    /**
     * 控制台Writer
     */
    public static class ConsoleAuditWriter implements AuditLogWriter {

        @Override
        public void write(AuditEvent event) {
            System.out.println("[AUDIT] " + event.toJson());
        }

        @Override
        public void close() {
            // No-op
        }
    }

    /**
     * 数据库Writer（示例）
     */
    public static class DatabaseAuditWriter implements AuditLogWriter {

        public DatabaseAuditWriter(Object databaseConfig) {
            // TODO: 初始化数据库连接
        }

        @Override
        public void write(AuditEvent event) {
            // TODO: 写入数据库
        }

        @Override
        public void close() {
            // TODO: 关闭数据库连接
        }
    }

    /**
     * 审计配置
     */
    public static class AuditConfig {
        private boolean fileLoggingEnabled = true;
        private String logFilePath = "~/.claude/audit.log";
        private boolean databaseLoggingEnabled = false;
        private Object databaseConfig;
        private boolean consoleLoggingEnabled = false;

        public static AuditConfig load() {
            // TODO: 从配置文件加载
            return new AuditConfig();
        }

        // Getters...
    }
}
```

## 8. 安全加固建议

### 8.1 部署安全检查清单

```java
/**
 * 安全检查清单
 */
public class SecurityChecklistpublic {

    /**
     * 运行安全检查
     */
    public SecurityCheckReport runSecurityCheck() {
        SecurityCheckReport report = new SecurityCheckReport();

        // 1. API密钥安全
        report.addCheck("API Key Security", checkApiKeySecurity());

        // 2. 文件权限
        report.addCheck("File Permissions", checkFilePermissions());

        // 3. 命令过滤配置
        report.addCheck("Command Filtering", checkCommandFiltering());

        // 4. 审计日志
        report.addCheck("Audit Logging", checkAuditLogging());

        // 5. 依赖安全
        report.addCheck("Dependency Security", checkDependencies());

        // 6. 网络安全
        report.addCheck("Network Security", checkNetworkSecurity());

        return report;
    }

    /**
     * 检查API密钥安全
     */
    private CheckResult checkApiKeySecurity() {
        List<String> issues = new ArrayList<>();
        List<String> recommendations = new ArrayList<>();

        // 检查是否使用环境变量
        if (System.getenv("ANTHROPIC_API_KEY") != null) {
            recommendations.add("API Key found in environment variable (good)");
        } else {
            issues.add("API Key not in environment variable");
            recommendations.add("Set API Key in environment variable for better security");
        }

        // 检查配置文件权限
        Path configPath = Paths.get(System.getProperty("user.home"), ".claude", "config.enc");
        if (Files.exists(configPath)) {
            try {
                Set<PosixFilePermission> perms = Files.getPosixFilePermissions(configPath);
                if (perms.size() > 2) {  // 应该只有owner read/write
                    issues.add("Config file has overly permissive permissions");
                    recommendations.add("Restrict config file permissions: chmod 600 " + configPath);
                }
            } catch (Exception e) {
                // Windows或其他不支持POSIX的系统
            }
        }

        return new CheckResult(issues.isEmpty(), issues, recommendations);
    }

    /**
     * 检查文件权限
     */
    private CheckResult checkFilePermissions() {
        // TODO: 实现
        return CheckResult.pass("File permissions are properly configured");
    }

    /**
     * 检查命令过滤
     */
    private CheckResult checkCommandFiltering() {
        // TODO: 实现
        return CheckResult.pass("Command filtering is enabled");
    }

    /**
     * 检查审计日志
     */
    private CheckResult checkAuditLogging() {
        // TODO: 实现
        return CheckResult.pass("Audit logging is enabled");
    }

    /**
     * 检查依赖安全
     */
    private CheckResult checkDependencies() {
        // TODO: 使用OWASP Dependency Check
        return CheckResult.pass("No known vulnerabilities in dependencies");
    }

    /**
     * 检查网络安全
     */
    private CheckResult checkNetworkSecurity() {
        // TODO: 实现
        return CheckResult.pass("Network security is configured");
    }

    /**
     * 检查结果
     */
    public static class CheckResult {
        private final boolean passed;
        private final List<String> issues;
        private final List<String> recommendations;

        public static CheckResult pass(String message) {
            return new CheckResult(true, List.of(), List.of(message));
        }

        // Constructor, getters...
    }

    /**
     * 安全检查报告
     */
    public static class SecurityCheckReport {
        private final Map<String, CheckResult> checks = new LinkedHashMap<>();

        public void addCheck(String name, CheckResult result) {
            checks.put(name, result);
        }

        public void printReport() {
            System.out.println("\n=== Security Check Report ===\n");

            int passed = 0;
            int failed = 0;

            for (Map.Entry<String, CheckResult> entry : checks.entrySet()) {
                String name = entry.getKey();
                CheckResult result = entry.getValue();

                String status = result.isPassed() ? "✓ PASS" : "✗ FAIL";
                System.out.printf("%s: %s\n", status, name);

                if (!result.getIssues().isEmpty()) {
                    System.out.println("  Issues:");
                    result.getIssues().forEach(issue ->
                        System.out.println("    - " + issue)
                    );
                }

                if (!result.getRecommendations().isEmpty()) {
                    System.out.println("  Recommendations:");
                    result.getRecommendations().forEach(rec ->
                        System.out.println("    - " + rec)
                    );
                }

                System.out.println();

                if (result.isPassed()) {
                    passed++;
                } else {
                    failed++;
                }
            }

            System.out.printf("Summary: %d passed, %d failed\n", passed, failed);
        }
    }
}
```

## 9. FAQ

### Q1: 如何安全存储多个API密钥？

```java
// 使用命名密钥
ApiKeyManager keyManager = new ApiKeyManager();

// 保存多个密钥
keyManager.saveApiKey("primary-key-value", StorageLocation.KEYCHAIN);
keyManager.saveApiKey("backup-key-value", StorageLocation.CONFIG_FILE);

// 获取指定密钥
String primaryKey = keyManager.getApiKey("primary");
String backupKey = keyManager.getApiKey("backup");
```

### Q2: 如何自定义敏感信息过滤规则？

```java
SensitiveInfoFilter filter = new SensitiveInfoFilter();

// 添加自定义规则
filter.addRule(new RegexRule(
    SensitiveType.CUSTOM,
    "Internal API Token",
    Pattern.compile("INTERNAL_TOKEN_[A-Z0-9]{32}"),
    Severity.CRITICAL
));

// 扫描内容
ScanResult result = filter.scan(content);
```

### Q3: 如何调整命令风险阈值？

```java
CommandSecurityChecker checker = new CommandSecurityChecker();

// 设置自定义风险阈值
checker.setRiskThreshold(RiskLevel.HIGH, 70);  // 默认80
checker.setRiskThreshold(RiskLevel.MEDIUM, 40);  // 默认50

// 添加自定义命令风险
checker.setCommandRisk("custom-command", 60);
```

## 10. 总结

安全是 Claude Code 的基石，本文详细介绍了：

1. **API Key管理**：多层存储、加密保护、自动轮换
2. **敏感信息过滤**：正则规则、熵值检测、ML模型
3. **命令安全检查**：白名单/黑名单、危险模式检测、风险评分
4. **文件访问控制**：沙箱隔离、路径验证、敏感文件保护
5. **用户确认机制**：Hooks系统、决策记忆、灵活配置
6. **审计日志**：完整记录、多种存储、实时监控
7. **安全加固**：检查清单、最佳实践、持续改进

通过这些多层防护机制，Claude Code 在提供强大功能的同时，确保了用户数据和系统的安全。

### 关键要点

1. 永不在代码中硬编码敏感信息
2. 使用系统 Keychain 或加密存储管理密钥
3. 实施多层防御，不依赖单一安全机制
4. 记录所有关键操作，便于审计和问题追踪
5. 为高风险操作添加用户确认机制
6. 定期运行安全检查，及时发现和修复问题

### 下一步

下一章我们将探讨**错误处理与恢复机制**，了解 Claude Code 如何优雅地处理各种异常情况，提供可靠的用户体验。
