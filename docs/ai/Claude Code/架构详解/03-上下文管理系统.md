---
title: Claude Codeæ¶æ„è¯¦è§£ï¼ˆä¸‰ï¼‰ï¼šä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ
date: 2025-01-14
permalink: /ai/claude-code/architecture/03-context-management.html
tags:
  - Claude Code
  - ä¸Šä¸‹æ–‡ç®¡ç†
  - Tokené¢„ç®—
  - æ™ºèƒ½æˆªæ–­
categories:
  - AI
  - Claude Code
---

# ç¬¬3ç¯‡ï¼šä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ

## å¼•è¨€

åœ¨AIé©±åŠ¨çš„åº”ç”¨ä¸­ï¼Œä¸Šä¸‹æ–‡(Context)æ˜¯å†³å®šAIè¡¨ç°çš„å…³é”®å› ç´ ã€‚Claude Codeéœ€è¦å¤„ç†å¤§é‡çš„é¡¹ç›®æ–‡ä»¶ã€å¯¹è¯å†å²ã€å·¥å…·è¾“å‡ºç­‰ä¿¡æ¯ï¼Œå¦‚ä½•åœ¨æœ‰é™çš„Tokené¢„ç®—å†…ï¼Œæ™ºèƒ½åœ°é€‰æ‹©ã€ç»„ç»‡å’Œä¼ é€’è¿™äº›ä¿¡æ¯ï¼Œæ˜¯ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿçš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚

### ä¸Šä¸‹æ–‡çš„é‡è¦æ€§

æƒ³è±¡ä½ åœ¨ä¸ä¸€ä¸ªå¤±å¿†ç—‡æ‚£è€…å¯¹è¯ï¼Œæ¯æ¬¡å¯¹è¯ä»–éƒ½ä¸è®°å¾—ä¹‹å‰è¯´è¿‡ä»€ä¹ˆã€‚è¿™å°±æ˜¯æ²¡æœ‰ä¸Šä¸‹æ–‡ç®¡ç†çš„AIåº”ç”¨çš„çŠ¶æ€ã€‚

**ä¸Šä¸‹æ–‡çš„ä½œç”¨**ï¼š
- âœ… **æä¾›èƒŒæ™¯ä¿¡æ¯**ï¼šè®©AIç†è§£å½“å‰ä»»åŠ¡çš„å®Œæ•´èƒŒæ™¯
- âœ… **ä¿æŒå¯¹è¯è¿è´¯**ï¼šè®°ä½ä¹‹å‰çš„å¯¹è¯å†…å®¹
- âœ… **é¿å…é‡å¤æ“ä½œ**ï¼šçŸ¥é“å“ªäº›æ–‡ä»¶å·²ç»è¯»å–è¿‡
- âœ… **æå‡å‡†ç¡®æ€§**ï¼šåŸºäºçœŸå®æ•°æ®è€ŒéçŒœæµ‹

### Claudeçš„ä¸Šä¸‹æ–‡çª—å£

Claude 3.5 Sonnetæ‹¥æœ‰**200K tokens**çš„ä¸Šä¸‹æ–‡çª—å£ï¼Œè¿™ç›¸å½“äºï¼š
- çº¦150,000ä¸ªè‹±æ–‡å•è¯
- çº¦500é¡µçš„æ–‡æœ¬
- æ•°ç™¾ä¸ªä¸­ç­‰å¤§å°çš„ä»£ç æ–‡ä»¶

ä½†æ˜¯ï¼Œæ›´å¤§çš„ä¸Šä¸‹æ–‡çª—å£å¹¶ä¸æ„å‘³ç€å¯ä»¥æ— èŠ‚åˆ¶åœ°ä½¿ç”¨ï¼š
- âš ï¸ **æˆæœ¬è€ƒè™‘**ï¼šæ¯1M input tokensçº¦$3
- âš ï¸ **æ€§èƒ½å½±å“**ï¼šæ›´å¤§çš„ä¸Šä¸‹æ–‡ä¼šå¢åŠ å“åº”å»¶è¿Ÿ
- âš ï¸ **ä¿¡æ¯å†—ä½™**ï¼šè¿‡å¤šæ— å…³ä¿¡æ¯åè€Œé™ä½AIæ•ˆæœ

### ä¸Šä¸‹æ–‡ç®¡ç†çš„æŒ‘æˆ˜

```mermaid
graph TB
    A[ä¸Šä¸‹æ–‡ç®¡ç†æŒ‘æˆ˜] --> B[Tokené¢„ç®—æœ‰é™]
    A --> C[ä¿¡æ¯ä¼˜å…ˆçº§]
    A --> D[åŠ¨æ€å˜åŒ–]
    A --> E[å¤šæºæ•´åˆ]

    B --> B1[å¦‚ä½•åœ¨é¢„ç®—å†…åŒ…å«æœ€é‡è¦çš„ä¿¡æ¯?]
    C --> C1[å“ªäº›ä¿¡æ¯æœ€é‡è¦?]
    C --> C2[å¦‚ä½•é‡åŒ–ä¼˜å…ˆçº§?]
    D --> D1[æ–‡ä»¶å†…å®¹å˜åŒ–]
    D --> D2[å¯¹è¯å†å²å¢é•¿]
    E --> E1[æ–‡ä»¶å†…å®¹]
    E --> E2[GitçŠ¶æ€]
    E --> E3[å·¥å…·è¾“å‡º]
    E --> E4[å¯¹è¯å†å²]

    style A fill:#ffe1f5,stroke:#333,stroke-width:3px
    style B fill:#fff4e1
    style C fill:#e1f5ff
```

---

## ä¸€ã€ä¸Šä¸‹æ–‡ç±»å‹å’Œæ¥æº

### 1.1 ä¸Šä¸‹æ–‡åˆ†ç±»ä½“ç³»

```mermaid
graph TB
    A[ä¸Šä¸‹æ–‡æ¥æº] --> B[é™æ€ä¸Šä¸‹æ–‡]
    A --> C[åŠ¨æ€ä¸Šä¸‹æ–‡]
    A --> D[ä¸´æ—¶ä¸Šä¸‹æ–‡]

    B --> B1[ç³»ç»Ÿæç¤ºè¯]
    B --> B2[å·¥å…·å®šä¹‰]
    B --> B3[é¡¹ç›®é…ç½®]

    C --> C1[æ–‡ä»¶å†…å®¹]
    C --> C2[GitçŠ¶æ€]
    C --> C3[å¯¹è¯å†å²]

    D --> D1[å·¥å…·æ‰§è¡Œç»“æœ]
    D --> D2[ä¸´æ—¶å˜é‡]
    D --> D3[ç”¨æˆ·æŒ‡å®šæ–‡ä»¶]

    B1 --> B1A[å›ºå®šä¸å˜<br/>é«˜ä¼˜å…ˆçº§]
    C1 --> C1A[é¢‘ç¹å˜åŒ–<br/>ä¸­ä¼˜å…ˆçº§]
    D1 --> D1A[å•æ¬¡ä½¿ç”¨<br/>ä½ä¼˜å…ˆçº§]

    style A fill:#e1f5ff,stroke:#333,stroke-width:3px
    style B fill:#e8f5e9
    style C fill:#fff4e1
    style D fill:#ffe1e1
```

### 1.2 ä¸Šä¸‹æ–‡æ¥æºè¯¦è§£

#### **é™æ€ä¸Šä¸‹æ–‡**

**ç‰¹ç‚¹**ï¼šåœ¨ä¼šè¯æœŸé—´åŸºæœ¬ä¸å˜

```typescript
/**
 * é™æ€ä¸Šä¸‹æ–‡æ¥å£
 */
interface StaticContext {
  systemPrompt: string;           // ç³»ç»Ÿæç¤ºè¯
  toolDefinitions: ToolDef[];     // å·¥å…·å®šä¹‰åˆ—è¡¨
  projectConfig: ProjectConfig;   // é¡¹ç›®é…ç½®
  environmentInfo: EnvInfo;       // ç¯å¢ƒä¿¡æ¯
}

/**
 * é¡¹ç›®é…ç½®
 */
interface ProjectConfig {
  name: string;                   // é¡¹ç›®åç§°
  version: string;                // ç‰ˆæœ¬å·
  workspaceRoot: string;          // å·¥ä½œåŒºæ ¹ç›®å½•
  language: string;               // ä¸»è¦ç¼–ç¨‹è¯­è¨€
  packageManager?: string;        // åŒ…ç®¡ç†å™¨
}

/**
 * ç¯å¢ƒä¿¡æ¯
 */
interface EnvInfo {
  platform: string;               // æ“ä½œç³»ç»Ÿ
  nodeVersion: string;            // Node.jsç‰ˆæœ¬
  currentDate: string;            // å½“å‰æ—¥æœŸ
  timezone: string;               // æ—¶åŒº
}
```

**ç¤ºä¾‹**ï¼š
```typescript
const staticContext: StaticContext = {
  systemPrompt: loadSystemPrompt(),
  toolDefinitions: toolRegistry.getAllDefinitions(),
  projectConfig: {
    name: 'my-app',
    version: '1.0.0',
    workspaceRoot: '/Users/john/projects/my-app',
    language: 'TypeScript',
    packageManager: 'npm'
  },
  environmentInfo: {
    platform: 'darwin',
    nodeVersion: 'v18.17.0',
    currentDate: '2025-01-14',
    timezone: 'Asia/Shanghai'
  }
};
```

#### **åŠ¨æ€ä¸Šä¸‹æ–‡**

**ç‰¹ç‚¹**ï¼šéšç€ç”¨æˆ·æ“ä½œå’Œé¡¹ç›®çŠ¶æ€å˜åŒ–

```typescript
/**
 * åŠ¨æ€ä¸Šä¸‹æ–‡æ¥å£
 */
interface DynamicContext {
  files: FileContext[];           // æ–‡ä»¶ä¸Šä¸‹æ–‡åˆ—è¡¨
  gitStatus: GitStatus;           // GitçŠ¶æ€
  conversationHistory: Message[]; // å¯¹è¯å†å²
  recentEdits: EditHistory[];     // æœ€è¿‘ç¼–è¾‘è®°å½•
}

/**
 * æ–‡ä»¶ä¸Šä¸‹æ–‡
 */
interface FileContext {
  path: string;                   // æ–‡ä»¶è·¯å¾„
  content: string;                // æ–‡ä»¶å†…å®¹
  language: string;               // ç¼–ç¨‹è¯­è¨€
  size: number;                   // æ–‡ä»¶å¤§å°(bytes)
  lastModified: number;           // æœ€åä¿®æ”¹æ—¶é—´
  relevanceScore?: number;        // ç›¸å…³æ€§è¯„åˆ†(0-1)
}

/**
 * GitçŠ¶æ€
 */
interface GitStatus {
  branch: string;                 // å½“å‰åˆ†æ”¯
  modified: string[];             // å·²ä¿®æ”¹æ–‡ä»¶
  untracked: string[];            // æœªè·Ÿè¸ªæ–‡ä»¶
  staged: string[];               // å·²æš‚å­˜æ–‡ä»¶
  commits: GitCommit[];           // æœ€è¿‘æäº¤
}

/**
 * ç¼–è¾‘å†å²
 */
interface EditHistory {
  filePath: string;               // æ–‡ä»¶è·¯å¾„
  timestamp: number;              // ç¼–è¾‘æ—¶é—´
  changeType: 'create' | 'modify' | 'delete'; // å˜æ›´ç±»å‹
  linesBefore: number;            // ä¿®æ”¹å‰è¡Œæ•°
  linesAfter: number;             // ä¿®æ”¹åè¡Œæ•°
}
```

#### **ä¸´æ—¶ä¸Šä¸‹æ–‡**

**ç‰¹ç‚¹**ï¼šä»…åœ¨å½“å‰è¯·æ±‚æˆ–å¯¹è¯è½®æ¬¡ä¸­æœ‰æ•ˆ

```typescript
/**
 * ä¸´æ—¶ä¸Šä¸‹æ–‡æ¥å£
 */
interface TemporaryContext {
  toolResults: ToolResult[];      // å·¥å…·æ‰§è¡Œç»“æœ
  userSpecifiedFiles: string[];   // ç”¨æˆ·æ˜ç¡®æŒ‡å®šçš„æ–‡ä»¶
  sessionVariables: Map<string, any>; // ä¼šè¯å˜é‡
  pendingOperations: Operation[]; // å¾…æ‰§è¡Œæ“ä½œ
}

/**
 * å·¥å…·æ‰§è¡Œç»“æœ
 */
interface ToolResult {
  toolName: string;               // å·¥å…·åç§°
  input: any;                     // è¾“å…¥å‚æ•°
  output: any;                    // è¾“å‡ºç»“æœ
  timestamp: number;              // æ‰§è¡Œæ—¶é—´
  duration: number;               // æ‰§è¡Œè€—æ—¶(ms)
  success: boolean;               // æ˜¯å¦æˆåŠŸ
}
```

### 1.3 ä¸Šä¸‹æ–‡æ”¶é›†å™¨å®ç°

```typescript
/**
 * ä¸Šä¸‹æ–‡æ”¶é›†å™¨ - ä»å„ä¸ªæ¥æºæ”¶é›†ä¸Šä¸‹æ–‡ä¿¡æ¯
 */
class ContextCollector {
  private workspaceRoot: string;
  private gitClient: GitClient;
  private fileWatcher: FileWatcher;

  constructor(workspaceRoot: string) {
    this.workspaceRoot = workspaceRoot;
    this.gitClient = new GitClient(workspaceRoot);
    this.fileWatcher = new FileWatcher(workspaceRoot);
  }

  /**
   * æ”¶é›†å®Œæ•´ä¸Šä¸‹æ–‡
   */
  async collectFullContext(options: CollectOptions): Promise<FullContext> {
    console.log('ğŸ” å¼€å§‹æ”¶é›†ä¸Šä¸‹æ–‡...');

    // å¹¶è¡Œæ”¶é›†å„ç±»ä¸Šä¸‹æ–‡
    const [
      staticCtx,
      dynamicCtx,
      temporaryCtx
    ] = await Promise.all([
      this.collectStaticContext(),
      this.collectDynamicContext(options),
      this.collectTemporaryContext(options)
    ]);

    return {
      static: staticCtx,
      dynamic: dynamicCtx,
      temporary: temporaryCtx,
      timestamp: Date.now()
    };
  }

  /**
   * æ”¶é›†é™æ€ä¸Šä¸‹æ–‡
   */
  private async collectStaticContext(): Promise<StaticContext> {
    return {
      systemPrompt: await this.loadSystemPrompt(),
      toolDefinitions: await this.loadToolDefinitions(),
      projectConfig: await this.loadProjectConfig(),
      environmentInfo: this.getEnvironmentInfo()
    };
  }

  /**
   * æ”¶é›†åŠ¨æ€ä¸Šä¸‹æ–‡
   */
  private async collectDynamicContext(
    options: CollectOptions
  ): Promise<DynamicContext> {
    const files = await this.collectRelevantFiles(options);
    const gitStatus = await this.gitClient.getStatus();
    const recentEdits = await this.fileWatcher.getRecentEdits(10);

    return {
      files,
      gitStatus,
      conversationHistory: options.conversationHistory || [],
      recentEdits
    };
  }

  /**
   * æ”¶é›†ä¸´æ—¶ä¸Šä¸‹æ–‡
   */
  private async collectTemporaryContext(
    options: CollectOptions
  ): Promise<TemporaryContext> {
    return {
      toolResults: options.recentToolResults || [],
      userSpecifiedFiles: options.userFiles || [],
      sessionVariables: options.variables || new Map(),
      pendingOperations: []
    };
  }

  /**
   * æ”¶é›†ç›¸å…³æ–‡ä»¶
   */
  private async collectRelevantFiles(
    options: CollectOptions
  ): Promise<FileContext[]> {
    const files: FileContext[] = [];

    // 1. ç”¨æˆ·æ˜ç¡®æŒ‡å®šçš„æ–‡ä»¶(æœ€é«˜ä¼˜å…ˆçº§)
    if (options.userFiles && options.userFiles.length > 0) {
      for (const filePath of options.userFiles) {
        const file = await this.readFileContext(filePath);
        if (file) {
          file.relevanceScore = 1.0; // æœ€é«˜ç›¸å…³æ€§
          files.push(file);
        }
      }
    }

    // 2. æœ€è¿‘ç¼–è¾‘çš„æ–‡ä»¶
    const recentEdits = await this.fileWatcher.getRecentEdits(5);
    for (const edit of recentEdits) {
      if (!files.some(f => f.path === edit.filePath)) {
        const file = await this.readFileContext(edit.filePath);
        if (file) {
          // åŸºäºæ—¶é—´è®¡ç®—ç›¸å…³æ€§(æ—¶é—´è¶Šè¿‘ç›¸å…³æ€§è¶Šé«˜)
          const ageMinutes = (Date.now() - edit.timestamp) / 60000;
          file.relevanceScore = Math.max(0.5, 1 - ageMinutes / 60);
          files.push(file);
        }
      }
    }

    // 3. Gitä¿®æ”¹çš„æ–‡ä»¶
    const gitStatus = await this.gitClient.getStatus();
    const modifiedFiles = [...gitStatus.modified, ...gitStatus.staged];
    for (const filePath of modifiedFiles) {
      if (!files.some(f => f.path === filePath)) {
        const file = await this.readFileContext(filePath);
        if (file) {
          file.relevanceScore = 0.7; // ä¸­ç­‰ç›¸å…³æ€§
          files.push(file);
        }
      }
    }

    return files;
  }

  /**
   * è¯»å–æ–‡ä»¶ä¸Šä¸‹æ–‡
   */
  private async readFileContext(filePath: string): Promise<FileContext | null> {
    try {
      const absolutePath = path.join(this.workspaceRoot, filePath);
      const content = await fs.readFile(absolutePath, 'utf-8');
      const stats = await fs.stat(absolutePath);

      return {
        path: filePath,
        content,
        language: this.detectLanguage(filePath),
        size: stats.size,
        lastModified: stats.mtimeMs
      };
    } catch (error) {
      console.warn(`æ— æ³•è¯»å–æ–‡ä»¶ ${filePath}:`, error.message);
      return null;
    }
  }

  /**
   * æ£€æµ‹æ–‡ä»¶è¯­è¨€
   */
  private detectLanguage(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const languageMap: Record<string, string> = {
      '.ts': 'typescript',
      '.tsx': 'typescript',
      '.js': 'javascript',
      '.jsx': 'javascript',
      '.py': 'python',
      '.java': 'java',
      '.go': 'go',
      '.rs': 'rust',
      '.cpp': 'cpp',
      '.c': 'c',
      '.md': 'markdown',
      '.json': 'json',
      '.yaml': 'yaml',
      '.yml': 'yaml'
    };
    return languageMap[ext] || 'plaintext';
  }

  /**
   * åŠ è½½ç³»ç»Ÿæç¤ºè¯
   */
  private async loadSystemPrompt(): Promise<string> {
    // ä»æ–‡ä»¶åŠ è½½æˆ–ä½¿ç”¨é»˜è®¤å€¼
    return DEFAULT_SYSTEM_PROMPT;
  }

  /**
   * åŠ è½½å·¥å…·å®šä¹‰
   */
  private async loadToolDefinitions(): Promise<ToolDef[]> {
    // ä»å·¥å…·æ³¨å†Œè¡¨è·å–
    return toolRegistry.getAllDefinitions();
  }

  /**
   * åŠ è½½é¡¹ç›®é…ç½®
   */
  private async loadProjectConfig(): Promise<ProjectConfig> {
    try {
      const pkgPath = path.join(this.workspaceRoot, 'package.json');
      const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));
      return {
        name: pkg.name || 'unknown',
        version: pkg.version || '0.0.0',
        workspaceRoot: this.workspaceRoot,
        language: 'TypeScript', // å¯ä»¥ä»package.jsonæ¨æ–­
        packageManager: 'npm'
      };
    } catch {
      return {
        name: path.basename(this.workspaceRoot),
        version: '0.0.0',
        workspaceRoot: this.workspaceRoot,
        language: 'unknown'
      };
    }
  }

  /**
   * è·å–ç¯å¢ƒä¿¡æ¯
   */
  private getEnvironmentInfo(): EnvInfo {
    return {
      platform: process.platform,
      nodeVersion: process.version,
      currentDate: new Date().toISOString().split('T')[0],
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    };
  }
}

/**
 * æ”¶é›†é€‰é¡¹
 */
interface CollectOptions {
  conversationHistory?: Message[];
  recentToolResults?: ToolResult[];
  userFiles?: string[];
  variables?: Map<string, any>;
}

/**
 * å®Œæ•´ä¸Šä¸‹æ–‡
 */
interface FullContext {
  static: StaticContext;
  dynamic: DynamicContext;
  temporary: TemporaryContext;
  timestamp: number;
}

export { ContextCollector, FullContext, CollectOptions };
```

---

## äºŒã€Tokenè®¡æ•°å’Œé¢„ç®—æ§åˆ¶

### 2.1 Tokenè®¡æ•°åŸç†

Tokenæ˜¯LLMå¤„ç†æ–‡æœ¬çš„åŸºæœ¬å•ä½ã€‚ä¸åŒçš„æ–‡æœ¬æœ‰ä¸åŒçš„Tokenæ•°é‡ï¼š

**Tokenè®¡æ•°è§„åˆ™**ï¼ˆè¿‘ä¼¼ï¼‰ï¼š
- è‹±æ–‡ï¼šçº¦4ä¸ªå­—ç¬¦ = 1 token
- ä¸­æ–‡ï¼šçº¦1.5ä¸ªå­—ç¬¦ = 1 token
- ä»£ç ï¼šçº¦3ä¸ªå­—ç¬¦ = 1 token
- ç©ºæ ¼å’Œæ ‡ç‚¹ï¼šä¹Ÿè®¡å…¥token

**ç¤ºä¾‹**ï¼š
```
æ–‡æœ¬ï¼šHello, world!
Tokenæ•°ï¼š3 (Hello, world, !)

æ–‡æœ¬ï¼šä½ å¥½ä¸–ç•Œ
Tokenæ•°ï¼šçº¦3 (ä½ å¥½, ä¸–ç•Œ)

ä»£ç ï¼šfunction hello() { return "world"; }
Tokenæ•°ï¼šçº¦10
```

### 2.2 Tokenè®¡æ•°å™¨å®ç°

```typescript
import { encoding_for_model } from 'tiktoken';

/**
 * Tokenè®¡æ•°å™¨ - ä½¿ç”¨tiktokenåº“ç²¾ç¡®è®¡ç®—tokenæ•°
 */
class TokenCounter {
  private encoding: any;
  private cache: Map<string, number>;

  constructor(model: string = 'claude-3-5-sonnet-20250929') {
    // åˆå§‹åŒ–ç¼–ç å™¨
    // Claudeä½¿ç”¨cl100k_baseç¼–ç (ä¸GPT-4ç›¸åŒ)
    this.encoding = encoding_for_model('gpt-4');
    this.cache = new Map();
  }

  /**
   * è®¡ç®—æ–‡æœ¬çš„tokenæ•°
   */
  count(text: string): number {
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(text);
    if (cached !== undefined) {
      return cached;
    }

    // ç¼–ç æ–‡æœ¬
    const tokens = this.encoding.encode(text);
    const count = tokens.length;

    // ç¼“å­˜ç»“æœ(é™åˆ¶ç¼“å­˜å¤§å°)
    if (this.cache.size < 10000) {
      this.cache.set(text, count);
    }

    return count;
  }

  /**
   * è®¡ç®—æ¶ˆæ¯åˆ—è¡¨çš„tokenæ•°
   */
  countMessages(messages: Message[]): number {
    let total = 0;

    for (const message of messages) {
      // æ¯æ¡æ¶ˆæ¯æœ‰å›ºå®šçš„æ ¼å¼å¼€é”€
      total += 4; // æ¶ˆæ¯è¾¹ç•Œtokens

      // è§’è‰²token
      total += this.count(message.role);

      // å†…å®¹tokens
      if (typeof message.content === 'string') {
        total += this.count(message.content);
      } else if (Array.isArray(message.content)) {
        for (const block of message.content) {
          if (block.type === 'text') {
            total += this.count(block.text);
          } else if (block.type === 'tool_use') {
            total += this.count(block.name);
            total += this.count(JSON.stringify(block.input));
          } else if (block.type === 'tool_result') {
            total += this.count(String(block.content));
          }
        }
      }
    }

    return total;
  }

  /**
   * è®¡ç®—ä¸Šä¸‹æ–‡çš„tokenæ•°
   */
  countContext(context: FullContext): ContextTokenStats {
    const stats: ContextTokenStats = {
      static: 0,
      dynamic: 0,
      temporary: 0,
      total: 0,
      breakdown: {}
    };

    // é™æ€ä¸Šä¸‹æ–‡
    stats.static += this.count(context.static.systemPrompt);
    stats.breakdown['systemPrompt'] = this.count(context.static.systemPrompt);

    // å·¥å…·å®šä¹‰
    const toolTokens = context.static.toolDefinitions.reduce(
      (sum, tool) => sum + this.count(JSON.stringify(tool)),
      0
    );
    stats.static += toolTokens;
    stats.breakdown['toolDefinitions'] = toolTokens;

    // åŠ¨æ€ä¸Šä¸‹æ–‡ - æ–‡ä»¶
    const fileTokens = context.dynamic.files.reduce(
      (sum, file) => sum + this.count(file.content),
      0
    );
    stats.dynamic += fileTokens;
    stats.breakdown['files'] = fileTokens;

    // å¯¹è¯å†å²
    const conversationTokens = this.countMessages(
      context.dynamic.conversationHistory
    );
    stats.dynamic += conversationTokens;
    stats.breakdown['conversation'] = conversationTokens;

    // GitçŠ¶æ€
    const gitTokens = this.count(JSON.stringify(context.dynamic.gitStatus));
    stats.dynamic += gitTokens;
    stats.breakdown['gitStatus'] = gitTokens;

    // ä¸´æ—¶ä¸Šä¸‹æ–‡ - å·¥å…·ç»“æœ
    const toolResultTokens = context.temporary.toolResults.reduce(
      (sum, result) => sum + this.count(JSON.stringify(result)),
      0
    );
    stats.temporary += toolResultTokens;
    stats.breakdown['toolResults'] = toolResultTokens;

    // æ€»è®¡
    stats.total = stats.static + stats.dynamic + stats.temporary;

    return stats;
  }

  /**
   * ä¼°ç®—æ–‡æœ¬çš„tokenæ•°(å¿«é€Ÿä½†ä¸ç²¾ç¡®)
   */
  estimate(text: string): number {
    // ç»Ÿè®¡ä¸­è‹±æ–‡å­—ç¬¦
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const otherChars = text.length - chineseChars;

    // ç²—ç•¥ä¼°ç®—
    return Math.ceil(chineseChars / 1.5 + otherChars / 4);
  }

  /**
   * æ¸…ç©ºç¼“å­˜
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * é‡Šæ”¾èµ„æº
   */
  dispose(): void {
    this.encoding.free();
    this.clearCache();
  }
}

/**
 * ä¸Šä¸‹æ–‡tokenç»Ÿè®¡
 */
interface ContextTokenStats {
  static: number;                 // é™æ€ä¸Šä¸‹æ–‡tokens
  dynamic: number;                // åŠ¨æ€ä¸Šä¸‹æ–‡tokens
  temporary: number;              // ä¸´æ—¶ä¸Šä¸‹æ–‡tokens
  total: number;                  // æ€»tokens
  breakdown: Record<string, number>; // è¯¦ç»†åˆ†è§£
}

export { TokenCounter, ContextTokenStats };
```

### 2.3 Tokené¢„ç®—ç®¡ç†å™¨

```mermaid
graph LR
    A[Tokené¢„ç®—ç®¡ç†] --> B[è®¾å®šé¢„ç®—]
    A --> C[å®æ—¶ç›‘æ§]
    A --> D[æ™ºèƒ½åˆ†é…]

    B --> B1[æ€»é¢„ç®—: 100K]
    B --> B2[é™æ€: 10K]
    B --> B3[åŠ¨æ€: 70K]
    B --> B4[ä¸´æ—¶: 20K]

    C --> C1[è®¡ç®—å½“å‰ä½¿ç”¨]
    C --> C2[é¢„æµ‹å¢é•¿]
    C --> C3[è§¦å‘è­¦å‘Š]

    D --> D1[æŒ‰ä¼˜å…ˆçº§åˆ†é…]
    D --> D2[åŠ¨æ€è°ƒæ•´]
    D --> D3[è¶…é™æˆªæ–­]

    style A fill:#e1f5ff,stroke:#333,stroke-width:3px
    style B fill:#e8f5e9
    style C fill:#fff4e1
    style D fill:#ffe1f5
```

```typescript
/**
 * Tokené¢„ç®—ç®¡ç†å™¨
 */
class TokenBudgetManager {
  private maxTokens: number;
  private tokenCounter: TokenCounter;
  private budgetAllocation: BudgetAllocation;

  constructor(maxTokens: number = 100000) {
    this.maxTokens = maxTokens;
    this.tokenCounter = new TokenCounter();
    this.budgetAllocation = this.calculateBudgetAllocation(maxTokens);
  }

  /**
   * è®¡ç®—é¢„ç®—åˆ†é…
   */
  private calculateBudgetAllocation(total: number): BudgetAllocation {
    return {
      total,
      static: Math.floor(total * 0.1),      // 10% é™æ€ä¸Šä¸‹æ–‡
      dynamic: Math.floor(total * 0.7),     // 70% åŠ¨æ€ä¸Šä¸‹æ–‡
      temporary: Math.floor(total * 0.2),   // 20% ä¸´æ—¶ä¸Šä¸‹æ–‡
      reserved: Math.floor(total * 0.1)     // 10% é¢„ç•™(è¾“å‡º)
    };
  }

  /**
   * æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦è¶…å‡ºé¢„ç®—
   */
  checkBudget(context: FullContext): BudgetCheckResult {
    const stats = this.tokenCounter.countContext(context);

    // è®¡ç®—å¯ç”¨äºè¾“å‡ºçš„tokens
    const availableForOutput = this.maxTokens - stats.total;

    const result: BudgetCheckResult = {
      isWithinBudget: stats.total <= (this.maxTokens - this.budgetAllocation.reserved),
      currentUsage: stats,
      budgetAllocation: this.budgetAllocation,
      availableForOutput,
      exceedBy: Math.max(0, stats.total - this.maxTokens),
      warnings: []
    };

    // ç”Ÿæˆè­¦å‘Š
    if (stats.static > this.budgetAllocation.static) {
      result.warnings.push(
        `é™æ€ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®—: ${stats.static} > ${this.budgetAllocation.static}`
      );
    }

    if (stats.dynamic > this.budgetAllocation.dynamic) {
      result.warnings.push(
        `åŠ¨æ€ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®—: ${stats.dynamic} > ${this.budgetAllocation.dynamic}`
      );
    }

    if (stats.temporary > this.budgetAllocation.temporary) {
      result.warnings.push(
        `ä¸´æ—¶ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®—: ${stats.temporary} > ${this.budgetAllocation.temporary}`
      );
    }

    if (availableForOutput < 1000) {
      result.warnings.push(
        `å¯ç”¨è¾“å‡ºç©ºé—´ä¸è¶³: ${availableForOutput} tokens`
      );
    }

    return result;
  }

  /**
   * ä¼˜åŒ–ä¸Šä¸‹æ–‡ä»¥é€‚åº”é¢„ç®—
   */
  optimizeContext(
    context: FullContext,
    checkResult: BudgetCheckResult
  ): FullContext {
    // å¦‚æœåœ¨é¢„ç®—å†…,ç›´æ¥è¿”å›
    if (checkResult.isWithinBudget) {
      console.log('âœ… ä¸Šä¸‹æ–‡åœ¨é¢„ç®—å†…,æ— éœ€ä¼˜åŒ–');
      return context;
    }

    console.log(`âš ï¸  ä¸Šä¸‹æ–‡è¶…å‡ºé¢„ç®— ${checkResult.exceedBy} tokens,å¼€å§‹ä¼˜åŒ–...`);

    let optimized = { ...context };

    // 1. ä¼˜åŒ–ä¸´æ—¶ä¸Šä¸‹æ–‡(æœ€ä½ä¼˜å…ˆçº§)
    if (checkResult.currentUsage.temporary > this.budgetAllocation.temporary) {
      optimized = this.optimizeTemporaryContext(optimized);
    }

    // 2. ä¼˜åŒ–åŠ¨æ€ä¸Šä¸‹æ–‡
    if (checkResult.currentUsage.dynamic > this.budgetAllocation.dynamic) {
      optimized = this.optimizeDynamicContext(optimized);
    }

    // 3. é‡æ–°æ£€æŸ¥
    const newCheck = this.checkBudget(optimized);
    if (newCheck.isWithinBudget) {
      console.log(`âœ… ä¼˜åŒ–å®Œæˆ,èŠ‚çœ ${checkResult.exceedBy - newCheck.exceedBy} tokens`);
      return optimized;
    }

    // 4. å¦‚æœè¿˜æ˜¯è¶…å‡º,è¿›è¡Œæ¿€è¿›æˆªæ–­
    console.log('âš ï¸  å¸¸è§„ä¼˜åŒ–ä¸è¶³,è¿›è¡Œæ¿€è¿›æˆªæ–­...');
    return this.aggressiveTruncate(optimized, this.maxTokens);
  }

  /**
   * ä¼˜åŒ–ä¸´æ—¶ä¸Šä¸‹æ–‡
   */
  private optimizeTemporaryContext(context: FullContext): FullContext {
    const optimized = { ...context };

    // é™åˆ¶å·¥å…·ç»“æœæ•°é‡(åªä¿ç•™æœ€è¿‘5ä¸ª)
    optimized.temporary = {
      ...context.temporary,
      toolResults: context.temporary.toolResults.slice(-5)
    };

    return optimized;
  }

  /**
   * ä¼˜åŒ–åŠ¨æ€ä¸Šä¸‹æ–‡
   */
  private optimizeDynamicContext(context: FullContext): FullContext {
    const optimized = { ...context };

    // 1. æˆªæ–­å¯¹è¯å†å²(ä¿ç•™æœ€è¿‘10è½®)
    optimized.dynamic = {
      ...context.dynamic,
      conversationHistory: context.dynamic.conversationHistory.slice(-10)
    };

    // 2. ç§»é™¤ä½ç›¸å…³æ€§æ–‡ä»¶
    const sortedFiles = [...context.dynamic.files].sort(
      (a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0)
    );

    // åªä¿ç•™ç›¸å…³æ€§>0.5çš„æ–‡ä»¶,æˆ–æœ€å¤š5ä¸ªæ–‡ä»¶
    optimized.dynamic.files = sortedFiles
      .filter(f => (f.relevanceScore || 0) > 0.5)
      .slice(0, 5);

    return optimized;
  }

  /**
   * æ¿€è¿›æˆªæ–­
   */
  private aggressiveTruncate(
    context: FullContext,
    maxTokens: number
  ): FullContext {
    // ä¿ç•™é™æ€ä¸Šä¸‹æ–‡
    // å¤§å¹…å‡å°‘åŠ¨æ€å’Œä¸´æ—¶ä¸Šä¸‹æ–‡
    return {
      ...context,
      dynamic: {
        ...context.dynamic,
        files: context.dynamic.files.slice(0, 2), // åªä¿ç•™2ä¸ªæ–‡ä»¶
        conversationHistory: context.dynamic.conversationHistory.slice(-5) // åªä¿ç•™5è½®å¯¹è¯
      },
      temporary: {
        ...context.temporary,
        toolResults: context.temporary.toolResults.slice(-2) // åªä¿ç•™2ä¸ªå·¥å…·ç»“æœ
      }
    };
  }

  /**
   * ç”Ÿæˆé¢„ç®—æŠ¥å‘Š
   */
  generateReport(context: FullContext): string {
    const stats = this.tokenCounter.countContext(context);
    const check = this.checkBudget(context);

    let report = '\n=== Tokené¢„ç®—æŠ¥å‘Š ===\n';
    report += `æ€»é¢„ç®—: ${this.maxTokens.toLocaleString()} tokens\n`;
    report += `å½“å‰ä½¿ç”¨: ${stats.total.toLocaleString()} tokens (${((stats.total / this.maxTokens) * 100).toFixed(1)}%)\n`;
    report += `\n--- åˆ†ç±»ç»Ÿè®¡ ---\n`;
    report += `é™æ€ä¸Šä¸‹æ–‡: ${stats.static.toLocaleString()} / ${this.budgetAllocation.static.toLocaleString()} tokens\n`;
    report += `åŠ¨æ€ä¸Šä¸‹æ–‡: ${stats.dynamic.toLocaleString()} / ${this.budgetAllocation.dynamic.toLocaleString()} tokens\n`;
    report += `ä¸´æ—¶ä¸Šä¸‹æ–‡: ${stats.temporary.toLocaleString()} / ${this.budgetAllocation.temporary.toLocaleString()} tokens\n`;
    report += `\n--- è¯¦ç»†åˆ†è§£ ---\n`;
    for (const [key, value] of Object.entries(stats.breakdown)) {
      report += `${key}: ${value.toLocaleString()} tokens\n`;
    }
    report += `\nå¯ç”¨è¾“å‡ºç©ºé—´: ${check.availableForOutput.toLocaleString()} tokens\n`;

    if (check.warnings.length > 0) {
      report += `\nâš ï¸  è­¦å‘Š:\n`;
      check.warnings.forEach(w => report += `  - ${w}\n`);
    }

    return report;
  }
}

/**
 * é¢„ç®—åˆ†é…
 */
interface BudgetAllocation {
  total: number;                  // æ€»é¢„ç®—
  static: number;                 // é™æ€ä¸Šä¸‹æ–‡é¢„ç®—
  dynamic: number;                // åŠ¨æ€ä¸Šä¸‹æ–‡é¢„ç®—
  temporary: number;              // ä¸´æ—¶ä¸Šä¸‹æ–‡é¢„ç®—
  reserved: number;               // é¢„ç•™(è¾“å‡º)
}

/**
 * é¢„ç®—æ£€æŸ¥ç»“æœ
 */
interface BudgetCheckResult {
  isWithinBudget: boolean;        // æ˜¯å¦åœ¨é¢„ç®—å†…
  currentUsage: ContextTokenStats; // å½“å‰ä½¿ç”¨æƒ…å†µ
  budgetAllocation: BudgetAllocation; // é¢„ç®—åˆ†é…
  availableForOutput: number;     // å¯ç”¨è¾“å‡ºç©ºé—´
  exceedBy: number;               // è¶…å‡ºé‡
  warnings: string[];             // è­¦å‘Šä¿¡æ¯
}

export { TokenBudgetManager, BudgetAllocation, BudgetCheckResult };
```

---

## ä¸‰ã€æ™ºèƒ½æˆªæ–­ç®—æ³•

### 3.1 æˆªæ–­ç­–ç•¥

```mermaid
flowchart TD
    Start[å¼€å§‹æˆªæ–­] --> CalcTokens[è®¡ç®—æ€»tokens]
    CalcTokens --> CheckBudget{è¶…å‡ºé¢„ç®—?}

    CheckBudget -->|å¦| End[ç»“æŸ]
    CheckBudget -->|æ˜¯| CalcExceed[è®¡ç®—è¶…å‡ºé‡]

    CalcExceed --> Strategy1[ç­–ç•¥1: ç§»é™¤ä½ä¼˜å…ˆçº§é¡¹]
    Strategy1 --> ReCheck1{è¾¾åˆ°é¢„ç®—?}

    ReCheck1 -->|æ˜¯| End
    ReCheck1 -->|å¦| Strategy2[ç­–ç•¥2: æˆªæ–­å¤§æ–‡ä»¶]

    Strategy2 --> ReCheck2{è¾¾åˆ°é¢„ç®—?}
    ReCheck2 -->|æ˜¯| End
    ReCheck2 -->|å¦| Strategy3[ç­–ç•¥3: å‹ç¼©å¯¹è¯å†å²]

    Strategy3 --> ReCheck3{è¾¾åˆ°é¢„ç®—?}
    ReCheck3 -->|æ˜¯| End
    ReCheck3 -->|å¦| Strategy4[ç­–ç•¥4: æ¿€è¿›æˆªæ–­]

    Strategy4 --> End

    style Start fill:#e8f5e9
    style End fill:#e8f5e9
    style CheckBudget fill:#fff4e1
    style Strategy1 fill:#e1f5ff
    style Strategy2 fill:#e1f5ff
    style Strategy3 fill:#e1f5ff
    style Strategy4 fill:#ffe1e1
```

### 3.2 æ™ºèƒ½æˆªæ–­å™¨å®ç°

```typescript
/**
 * æ™ºèƒ½æˆªæ–­å™¨
 */
class SmartTruncator {
  private tokenCounter: TokenCounter;
  private maxTokens: number;

  constructor(maxTokens: number = 100000) {
    this.tokenCounter = new TokenCounter();
    this.maxTokens = maxTokens;
  }

  /**
   * æˆªæ–­ä¸Šä¸‹æ–‡é¡¹åˆ—è¡¨
   */
  truncate(
    items: ContextItem[],
    targetTokens: number
  ): ContextItem[] {
    console.log(`ğŸ”ª å¼€å§‹æˆªæ–­: ${items.length}é¡¹ -> ç›®æ ‡${targetTokens} tokens`);

    // 1. è®¡ç®—æ¯é¡¹çš„tokenæ•°
    const itemsWithTokens = items.map(item => ({
      ...item,
      tokens: this.tokenCounter.count(item.content)
    }));

    // 2. æŒ‰ä¼˜å…ˆçº§æ’åº(é«˜ä¼˜å…ˆçº§ä¼˜å…ˆä¿ç•™)
    const sorted = itemsWithTokens.sort((a, b) => b.priority - a.priority);

    // 3. è´ªå¿ƒç®—æ³•:ä»é«˜ä¼˜å…ˆçº§å¼€å§‹ç´¯åŠ 
    const result: ContextItem[] = [];
    let totalTokens = 0;

    for (const item of sorted) {
      // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ç©ºé—´
      if (totalTokens + item.tokens <= targetTokens) {
        // å®Œæ•´ä¿ç•™
        result.push(item);
        totalTokens += item.tokens;
      } else {
        // æ£€æŸ¥å‰©ä½™ç©ºé—´
        const remaining = targetTokens - totalTokens;

        if (remaining > 100) {
          // æœ‰è¶³å¤Ÿç©ºé—´,å°è¯•éƒ¨åˆ†æˆªæ–­
          const truncated = this.truncateItem(item, remaining);
          if (truncated) {
            result.push(truncated);
            totalTokens += truncated.tokens;
          }
        }

        // é¢„ç®—å·²æ»¡,åœæ­¢
        break;
      }
    }

    console.log(`âœ… æˆªæ–­å®Œæˆ: ${result.length}é¡¹, ${totalTokens} tokens`);

    return result;
  }

  /**
   * æˆªæ–­å•ä¸ªé¡¹
   */
  private truncateItem(
    item: ContextItem,
    maxTokens: number
  ): ContextItem | null {
    // æ— æ³•æˆªæ–­çš„ç±»å‹
    if (item.type === 'system' || item.type === 'tool_definition') {
      return null;
    }

    // æ–‡ä»¶å†…å®¹å¯ä»¥æˆªæ–­
    if (item.type === 'file') {
      return this.truncateFileContent(item, maxTokens);
    }

    // å¯¹è¯å¯ä»¥æˆªæ–­
    if (item.type === 'conversation') {
      return this.truncateConversation(item, maxTokens);
    }

    // å·¥å…·ç»“æœå¯ä»¥æˆªæ–­
    if (item.type === 'tool_result') {
      return this.truncateToolResult(item, maxTokens);
    }

    return null;
  }

  /**
   * æˆªæ–­æ–‡ä»¶å†…å®¹
   */
  private truncateFileContent(
    item: ContextItem,
    maxTokens: number
  ): ContextItem {
    const lines = item.content.split('\n');
    let truncated = '';
    let tokens = 0;

    // ä¿ç•™æ–‡ä»¶å¤´éƒ¨
    for (const line of lines) {
      const lineTokens = this.tokenCounter.count(line + '\n');
      if (tokens + lineTokens > maxTokens - 50) {
        break;
      }
      truncated += line + '\n';
      tokens += lineTokens;
    }

    truncated += '\n... (truncated)\n';

    return {
      ...item,
      content: truncated,
      tokens,
      metadata: {
        ...item.metadata,
        truncated: true,
        originalTokens: item.tokens
      }
    };
  }

  /**
   * æˆªæ–­å¯¹è¯
   */
  private truncateConversation(
    item: ContextItem,
    maxTokens: number
  ): ContextItem {
    // è§£æå¯¹è¯æ¶ˆæ¯
    const messages = JSON.parse(item.content) as Message[];

    // ä¿ç•™æœ€è¿‘çš„æ¶ˆæ¯
    let truncated: Message[] = [];
    let tokens = 0;

    for (let i = messages.length - 1; i >= 0; i--) {
      const msgTokens = this.tokenCounter.count(
        JSON.stringify(messages[i])
      );

      if (tokens + msgTokens > maxTokens) {
        break;
      }

      truncated.unshift(messages[i]);
      tokens += msgTokens;
    }

    return {
      ...item,
      content: JSON.stringify(truncated),
      tokens,
      metadata: {
        ...item.metadata,
        truncated: true,
        keptMessages: truncated.length,
        totalMessages: messages.length
      }
    };
  }

  /**
   * æˆªæ–­å·¥å…·ç»“æœ
   */
  private truncateToolResult(
    item: ContextItem,
    maxTokens: number
  ): ContextItem {
    // å·¥å…·ç»“æœé€šå¸¸æ˜¯JSONæˆ–æ–‡æœ¬
    let truncated = item.content.slice(0, maxTokens * 4); // ç²—ç•¥ä¼°ç®—
    truncated += '\n... (truncated)';

    return {
      ...item,
      content: truncated,
      tokens: this.tokenCounter.count(truncated),
      metadata: {
        ...item.metadata,
        truncated: true
      }
    };
  }

  /**
   * æŒ‰ç±»å‹åˆ†ç»„æˆªæ–­
   */
  truncateByType(
    items: ContextItem[],
    budgets: Record<string, number>
  ): ContextItem[] {
    const result: ContextItem[] = [];

    // æŒ‰ç±»å‹åˆ†ç»„
    const grouped = new Map<string, ContextItem[]>();
    for (const item of items) {
      const list = grouped.get(item.type) || [];
      list.push(item);
      grouped.set(item.type, list);
    }

    // å¯¹æ¯ä¸ªç±»å‹åº”ç”¨é¢„ç®—
    for (const [type, budget] of Object.entries(budgets)) {
      const typeItems = grouped.get(type) || [];
      const truncated = this.truncate(typeItems, budget);
      result.push(...truncated);
    }

    return result;
  }
}

/**
 * ä¸Šä¸‹æ–‡é¡¹æ¥å£
 */
interface ContextItem {
  type: 'system' | 'file' | 'conversation' | 'tool_result' | 'tool_definition';
  content: string;
  priority: number;               // ä¼˜å…ˆçº§(0-10)
  tokens: number;                 // tokenæ•°
  metadata?: Record<string, any>; // å…ƒæ•°æ®
}

export { SmartTruncator, ContextItem };
```

---

## å››ã€ä¸Šä¸‹æ–‡ä¼˜å…ˆçº§æ’åº

### 4.1 ä¼˜å…ˆçº§çŸ©é˜µ

| ä¸Šä¸‹æ–‡ç±»å‹ | åŸºç¡€ä¼˜å…ˆçº§ | è°ƒæ•´å› ç´  | æœ€ç»ˆèŒƒå›´ |
|-----------|----------|---------|---------|
| ç³»ç»Ÿæç¤ºè¯ | 10 | å›ºå®š | 10 |
| å½“å‰æ–‡ä»¶ | 9 | ç”¨æˆ·æ˜ç¡®æŒ‡å®š+1 | 9-10 |
| æœ€è¿‘ç¼–è¾‘ | 8 | æ—¶é—´è¡°å‡ | 5-8 |
| é”™è¯¯ä¿¡æ¯ | 8 | - | 8 |
| ç”¨æˆ·æŒ‡å®šæ–‡ä»¶ | 7-9 | æŒ‡å®šæ–¹å¼ | 7-9 |
| ç›¸å…³æ–‡ä»¶ | 7 | ç›¸å…³åº¦è¯„åˆ† | 4-7 |
| å·¥å…·è¾“å‡º | 6 | æœ€è¿‘ä½¿ç”¨+1 | 6-7 |
| GitçŠ¶æ€ | 5 | ä¿®æ”¹é‡ | 4-6 |
| é¡¹ç›®ä¿¡æ¯ | 5 | - | 5 |
| å†å²å¯¹è¯ | 4 | æ—¶é—´è¡°å‡ | 2-4 |
| æ—§æ–‡ä»¶ | 3 | ç›¸å…³åº¦ | 1-3 |

### 4.2 ä¼˜å…ˆçº§è®¡ç®—å™¨

```typescript
/**
 * ä¼˜å…ˆçº§è®¡ç®—å™¨
 */
class PriorityCalculator {
  /**
   * è®¡ç®—ä¸Šä¸‹æ–‡é¡¹çš„ä¼˜å…ˆçº§
   */
  calculate(item: ContextItem, context: PriorityContext): number {
    let priority = item.basePriority || 5;

    // 1. æ—¶é—´è¡°å‡
    if (item.timestamp) {
      priority *= this.calculateTimeDecay(item.timestamp);
    }

    // 2. ç›¸å…³æ€§åŠ æƒ
    if (item.relevanceScore !== undefined) {
      priority *= item.relevanceScore;
    }

    // 3. ç”¨æˆ·æ˜ç¡®æŒ‡å®š
    if (item.explicitlyRequested) {
      priority += 2;
    }

    // 4. æœ€è¿‘ä½¿ç”¨åŠ æƒ
    if (this.isRecentlyUsed(item, context)) {
      priority += 1;
    }

    // 5. é”™è¯¯ç›¸å…³åŠ æƒ
    if (this.isErrorRelated(item, context)) {
      priority += 1;
    }

    // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
    return Math.max(0, Math.min(10, priority));
  }

  /**
   * è®¡ç®—æ—¶é—´è¡°å‡å› å­
   */
  private calculateTimeDecay(timestamp: number): number {
    const ageMs = Date.now() - timestamp;
    const ageHours = ageMs / (1000 * 60 * 60);

    // æŒ‡æ•°è¡°å‡: æ¯å°æ—¶è¡°å‡å› å­
    // 1å°æ—¶: 1.0
    // 24å°æ—¶: 0.5
    // 168å°æ—¶(7å¤©): 0.1
    return Math.exp(-ageHours / 24);
  }

  /**
   * æ˜¯å¦æœ€è¿‘ä½¿ç”¨
   */
  private isRecentlyUsed(
    item: ContextItem,
    context: PriorityContext
  ): boolean {
    if (!item.filePath) return false;

    return context.recentlyAccessedFiles?.includes(item.filePath) || false;
  }

  /**
   * æ˜¯å¦ä¸é”™è¯¯ç›¸å…³
   */
  private isErrorRelated(
    item: ContextItem,
    context: PriorityContext
  ): boolean {
    if (!context.recentError) return false;

    // æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦åœ¨é”™è¯¯å †æ ˆä¸­
    if (item.filePath && context.recentError.includes(item.filePath)) {
      return true;
    }

    // æ£€æŸ¥å†…å®¹æ˜¯å¦åŒ…å«é”™è¯¯å…³é”®å­—
    if (context.errorKeywords?.some(kw => item.content.includes(kw))) {
      return true;
    }

    return false;
  }

  /**
   * æ‰¹é‡è®¡ç®—ä¼˜å…ˆçº§
   */
  calculateBatch(
    items: ContextItem[],
    context: PriorityContext
  ): ContextItemWithPriority[] {
    return items.map(item => ({
      ...item,
      calculatedPriority: this.calculate(item, context)
    }));
  }

  /**
   * æ’åºä¸Šä¸‹æ–‡é¡¹(æŒ‰ä¼˜å…ˆçº§é™åº)
   */
  sort(items: ContextItemWithPriority[]): ContextItemWithPriority[] {
    return [...items].sort((a, b) => b.calculatedPriority - a.calculatedPriority);
  }
}

/**
 * ä¼˜å…ˆçº§ä¸Šä¸‹æ–‡(ç”¨äºè®¡ç®—ä¼˜å…ˆçº§çš„è¾…åŠ©ä¿¡æ¯)
 */
interface PriorityContext {
  recentlyAccessedFiles?: string[];  // æœ€è¿‘è®¿é—®çš„æ–‡ä»¶
  recentError?: string;              // æœ€è¿‘çš„é”™è¯¯ä¿¡æ¯
  errorKeywords?: string[];          // é”™è¯¯å…³é”®å­—
  currentTask?: string;              // å½“å‰ä»»åŠ¡
}

/**
 * å¸¦ä¼˜å…ˆçº§çš„ä¸Šä¸‹æ–‡é¡¹
 */
interface ContextItemWithPriority extends ContextItem {
  calculatedPriority: number;        // è®¡ç®—åçš„ä¼˜å…ˆçº§
  basePriority?: number;             // åŸºç¡€ä¼˜å…ˆçº§
  timestamp?: number;                // æ—¶é—´æˆ³
  relevanceScore?: number;           // ç›¸å…³æ€§è¯„åˆ†(0-1)
  explicitlyRequested?: boolean;     // æ˜¯å¦ç”¨æˆ·æ˜ç¡®è¯·æ±‚
  filePath?: string;                 // æ–‡ä»¶è·¯å¾„
}

export { PriorityCalculator, PriorityContext, ContextItemWithPriority };
```

### 4.3 åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´

```typescript
/**
 * åŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´å™¨
 */
class DynamicPriorityAdjuster {
  private calculator: PriorityCalculator;
  private history: AdjustmentHistory[];

  constructor() {
    this.calculator = new PriorityCalculator();
    this.history = [];
  }

  /**
   * æ ¹æ®AIåé¦ˆè°ƒæ•´ä¼˜å…ˆçº§
   */
  adjustBasedOnFeedback(
    items: ContextItemWithPriority[],
    feedback: AIFeedback
  ): ContextItemWithPriority[] {
    const adjusted = [...items];

    // å¦‚æœAIè¯´ä¸Šä¸‹æ–‡ä¸è¶³
    if (feedback.type === 'insufficient_context') {
      // æå‡ç›¸å…³æ–‡ä»¶çš„ä¼˜å…ˆçº§
      feedback.requestedFiles?.forEach(filePath => {
        const item = adjusted.find(i => i.filePath === filePath);
        if (item) {
          item.calculatedPriority += 1;
          this.recordAdjustment('boost', filePath, 1);
        }
      });
    }

    // å¦‚æœAIè¯´ä¸Šä¸‹æ–‡è¿‡å¤š
    if (feedback.type === 'too_much_context') {
      // é™ä½ä¸ç›¸å…³æ–‡ä»¶çš„ä¼˜å…ˆçº§
      feedback.unusedFiles?.forEach(filePath => {
        const item = adjusted.find(i => i.filePath === filePath);
        if (item) {
          item.calculatedPriority -= 0.5;
          this.recordAdjustment('reduce', filePath, 0.5);
        }
      });
    }

    return adjusted;
  }

  /**
   * æ ¹æ®ç”¨æˆ·è¡Œä¸ºè°ƒæ•´
   */
  adjustBasedOnUserBehavior(
    items: ContextItemWithPriority[],
    behavior: UserBehavior
  ): ContextItemWithPriority[] {
    const adjusted = [...items];

    // ç”¨æˆ·æ‰“å¼€äº†æŸä¸ªæ–‡ä»¶
    if (behavior.action === 'file_opened') {
      const item = adjusted.find(i => i.filePath === behavior.filePath);
      if (item) {
        item.explicitlyRequested = true;
        item.calculatedPriority += 2;
        this.recordAdjustment('user_opened', behavior.filePath!, 2);
      }
    }

    // ç”¨æˆ·ç¼–è¾‘äº†æŸä¸ªæ–‡ä»¶
    if (behavior.action === 'file_edited') {
      const item = adjusted.find(i => i.filePath === behavior.filePath);
      if (item) {
        item.timestamp = Date.now();
        item.calculatedPriority += 1;
        this.recordAdjustment('user_edited', behavior.filePath!, 1);
      }
    }

    return adjusted;
  }

  /**
   * è®°å½•è°ƒæ•´å†å²
   */
  private recordAdjustment(
    type: string,
    target: string,
    amount: number
  ): void {
    this.history.push({
      type,
      target,
      amount,
      timestamp: Date.now()
    });

    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.history.length > 100) {
      this.history.shift();
    }
  }

  /**
   * è·å–è°ƒæ•´å†å²
   */
  getHistory(): AdjustmentHistory[] {
    return [...this.history];
  }
}

/**
 * AIåé¦ˆ
 */
interface AIFeedback {
  type: 'insufficient_context' | 'too_much_context' | 'optimal';
  requestedFiles?: string[];      // AIè¯·æ±‚çš„æ–‡ä»¶
  unusedFiles?: string[];         // AIæœªä½¿ç”¨çš„æ–‡ä»¶
  message?: string;               // åé¦ˆæ¶ˆæ¯
}

/**
 * ç”¨æˆ·è¡Œä¸º
 */
interface UserBehavior {
  action: 'file_opened' | 'file_edited' | 'file_closed';
  filePath?: string;
  timestamp: number;
}

/**
 * è°ƒæ•´å†å²
 */
interface AdjustmentHistory {
  type: string;                   // è°ƒæ•´ç±»å‹
  target: string;                 // è°ƒæ•´ç›®æ ‡
  amount: number;                 // è°ƒæ•´é‡
  timestamp: number;              // æ—¶é—´æˆ³
}

export { DynamicPriorityAdjuster, AIFeedback, UserBehavior };
```

---

## äº”ã€ç¼“å­˜æœºåˆ¶è®¾è®¡

### 5.1 å¤šçº§ç¼“å­˜æ¶æ„

```mermaid
graph TB
    A[è¯·æ±‚ä¸Šä¸‹æ–‡] --> B{L1: å†…å­˜ç¼“å­˜}
    B -->|å‘½ä¸­ 95%| C[ç›´æ¥è¿”å›]
    B -->|æœªå‘½ä¸­ 5%| D{L2: ç£ç›˜ç¼“å­˜}

    D -->|å‘½ä¸­ 80%| E[åŠ è½½åˆ°L1]
    D -->|æœªå‘½ä¸­ 20%| F[ä»æºè¯»å–]

    F --> G[å†™å…¥L2]
    G --> H[å†™å…¥L1]
    E --> H
    H --> C

    F --> I[æ–‡ä»¶ç³»ç»Ÿ]
    F --> J[Gitä»“åº“]
    F --> K[ç½‘ç»œAPI]

    style A fill:#e8f5e9
    style B fill:#fff4e1
    style C fill:#e8f5e9
    style D fill:#e1f5ff
    style F fill:#ffe1e1
```

### 5.2 LRUç¼“å­˜å®ç°

```typescript
/**
 * LRU(æœ€è¿‘æœ€å°‘ä½¿ç”¨)ç¼“å­˜
 */
class LRUCache<K, V> {
  private capacity: number;
  private cache: Map<K, CacheNode<K, V>>;
  private head: CacheNode<K, V> | null = null;
  private tail: CacheNode<K, V> | null = null;

  constructor(capacity: number = 100) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  /**
   * è·å–ç¼“å­˜å€¼
   */
  get(key: K): V | undefined {
    const node = this.cache.get(key);
    if (!node) {
      return undefined;
    }

    // ç§»åˆ°é“¾è¡¨å¤´éƒ¨(æœ€è¿‘ä½¿ç”¨)
    this.moveToHead(node);

    return node.value;
  }

  /**
   * è®¾ç½®ç¼“å­˜å€¼
   */
  set(key: K, value: V, ttl?: number): void {
    let node = this.cache.get(key);

    if (node) {
      // æ›´æ–°ç°æœ‰èŠ‚ç‚¹
      node.value = value;
      node.timestamp = Date.now();
      node.ttl = ttl;
      this.moveToHead(node);
    } else {
      // åˆ›å»ºæ–°èŠ‚ç‚¹
      node = {
        key,
        value,
        timestamp: Date.now(),
        ttl,
        prev: null,
        next: null
      };

      this.cache.set(key, node);
      this.addToHead(node);

      // æ£€æŸ¥å®¹é‡
      if (this.cache.size > this.capacity) {
        // ç§»é™¤æœ€ä¹…æœªä½¿ç”¨çš„èŠ‚ç‚¹
        const removed = this.removeTail();
        if (removed) {
          this.cache.delete(removed.key);
        }
      }
    }
  }

  /**
   * åˆ é™¤ç¼“å­˜å€¼
   */
  delete(key: K): boolean {
    const node = this.cache.get(key);
    if (!node) {
      return false;
    }

    this.removeNode(node);
    this.cache.delete(key);
    return true;
  }

  /**
   * æ¸…ç©ºç¼“å­˜
   */
  clear(): void {
    this.cache.clear();
    this.head = null;
    this.tail = null;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
   */
  private isExpired(node: CacheNode<K, V>): boolean {
    if (!node.ttl) {
      return false;
    }
    return Date.now() - node.timestamp > node.ttl;
  }

  /**
   * æ¸…ç†è¿‡æœŸé¡¹
   */
  cleanup(): number {
    let removed = 0;
    const toRemove: K[] = [];

    for (const [key, node] of this.cache.entries()) {
      if (this.isExpired(node)) {
        toRemove.push(key);
      }
    }

    for (const key of toRemove) {
      this.delete(key);
      removed++;
    }

    return removed;
  }

  /**
   * ç§»åŠ¨èŠ‚ç‚¹åˆ°å¤´éƒ¨
   */
  private moveToHead(node: CacheNode<K, V>): void {
    this.removeNode(node);
    this.addToHead(node);
  }

  /**
   * æ·»åŠ èŠ‚ç‚¹åˆ°å¤´éƒ¨
   */
  private addToHead(node: CacheNode<K, V>): void {
    node.prev = null;
    node.next = this.head;

    if (this.head) {
      this.head.prev = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }
  }

  /**
   * ç§»é™¤èŠ‚ç‚¹
   */
  private removeNode(node: CacheNode<K, V>): void {
    if (node.prev) {
      node.prev.next = node.next;
    } else {
      this.head = node.next;
    }

    if (node.next) {
      node.next.prev = node.prev;
    } else {
      this.tail = node.prev;
    }
  }

  /**
   * ç§»é™¤å°¾éƒ¨èŠ‚ç‚¹
   */
  private removeTail(): CacheNode<K, V> | null {
    const node = this.tail;
    if (node) {
      this.removeNode(node);
    }
    return node;
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡
   */
  getStats(): CacheStats {
    return {
      size: this.cache.size,
      capacity: this.capacity,
      usage: this.cache.size / this.capacity
    };
  }
}

/**
 * ç¼“å­˜èŠ‚ç‚¹
 */
interface CacheNode<K, V> {
  key: K;
  value: V;
  timestamp: number;
  ttl?: number;
  prev: CacheNode<K, V> | null;
  next: CacheNode<K, V> | null;
}

/**
 * ç¼“å­˜ç»Ÿè®¡
 */
interface CacheStats {
  size: number;
  capacity: number;
  usage: number;
}

export { LRUCache, CacheNode, CacheStats };
```

### 5.3 å¤šçº§ç¼“å­˜ç®¡ç†å™¨

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';
import * as crypto from 'crypto';

/**
 * å¤šçº§ç¼“å­˜ç®¡ç†å™¨
 */
class MultiLevelCache {
  private l1Cache: LRUCache<string, string>;     // å†…å­˜ç¼“å­˜
  private l2Path: string;                        // ç£ç›˜ç¼“å­˜è·¯å¾„
  private stats: MultiLevelCacheStats;

  constructor(config: CacheConfig) {
    this.l1Cache = new LRUCache(config.l1MaxSize || 100);
    this.l2Path = config.l2Path || './.cache/context';
    this.stats = {
      l1Hits: 0,
      l1Misses: 0,
      l2Hits: 0,
      l2Misses: 0
    };

    // ç¡®ä¿L2ç¼“å­˜ç›®å½•å­˜åœ¨
    this.ensureCacheDir();
  }

  /**
   * è·å–ç¼“å­˜
   */
  async get(key: string): Promise<string | null> {
    // L1ç¼“å­˜
    const l1Result = this.l1Cache.get(key);
    if (l1Result !== undefined) {
      this.stats.l1Hits++;
      return l1Result;
    }
    this.stats.l1Misses++;

    // L2ç¼“å­˜
    const l2Result = await this.getFromL2(key);
    if (l2Result) {
      this.stats.l2Hits++;
      // æå‡åˆ°L1
      this.l1Cache.set(key, l2Result);
      return l2Result;
    }
    this.stats.l2Misses++;

    return null;
  }

  /**
   * è®¾ç½®ç¼“å­˜
   */
  async set(key: string, value: string, ttl?: number): Promise<void> {
    // å†™å…¥L1
    this.l1Cache.set(key, value, ttl);

    // å¼‚æ­¥å†™å…¥L2(ä¸é˜»å¡)
    this.saveToL2(key, value, ttl).catch(err => {
      console.error('L2ç¼“å­˜å†™å…¥å¤±è´¥:', err);
    });
  }

  /**
   * ä»L2ç¼“å­˜è¯»å–
   */
  private async getFromL2(key: string): Promise<string | null> {
    try {
      const filePath = this.getCacheFilePath(key);
      const data = await fs.readFile(filePath, 'utf-8');
      const cached: L2CacheEntry = JSON.parse(data);

      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      if (cached.ttl && Date.now() - cached.timestamp > cached.ttl) {
        await fs.unlink(filePath); // åˆ é™¤è¿‡æœŸæ–‡ä»¶
        return null;
      }

      return cached.value;
    } catch {
      return null;
    }
  }

  /**
   * ä¿å­˜åˆ°L2ç¼“å­˜
   */
  private async saveToL2(
    key: string,
    value: string,
    ttl?: number
  ): Promise<void> {
    const filePath = this.getCacheFilePath(key);
    const entry: L2CacheEntry = {
      key,
      value,
      timestamp: Date.now(),
      ttl
    };

    await fs.writeFile(filePath, JSON.stringify(entry), 'utf-8');
  }

  /**
   * è·å–ç¼“å­˜æ–‡ä»¶è·¯å¾„
   */
  private getCacheFilePath(key: string): string {
    // ä½¿ç”¨keyçš„å“ˆå¸Œå€¼ä½œä¸ºæ–‡ä»¶å
    const hash = crypto.createHash('md5').update(key).digest('hex');
    return path.join(this.l2Path, `${hash}.json`);
  }

  /**
   * ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
   */
  private async ensureCacheDir(): Promise<void> {
    try {
      await fs.mkdir(this.l2Path, { recursive: true });
    } catch (err) {
      console.error('åˆ›å»ºç¼“å­˜ç›®å½•å¤±è´¥:', err);
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  async cleanup(): Promise<void> {
    // æ¸…ç†L1
    const l1Removed = this.l1Cache.cleanup();
    console.log(`L1ç¼“å­˜æ¸…ç†: ç§»é™¤${l1Removed}é¡¹`);

    // æ¸…ç†L2
    try {
      const files = await fs.readdir(this.l2Path);
      let l2Removed = 0;

      for (const file of files) {
        const filePath = path.join(this.l2Path, file);
        try {
          const data = await fs.readFile(filePath, 'utf-8');
          const entry: L2CacheEntry = JSON.parse(data);

          if (entry.ttl && Date.now() - entry.timestamp > entry.ttl) {
            await fs.unlink(filePath);
            l2Removed++;
          }
        } catch {
          // å¿½ç•¥æ— æ•ˆæ–‡ä»¶
        }
      }

      console.log(`L2ç¼“å­˜æ¸…ç†: ç§»é™¤${l2Removed}é¡¹`);
    } catch (err) {
      console.error('L2ç¼“å­˜æ¸…ç†å¤±è´¥:', err);
    }
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): MultiLevelCacheStats {
    const l1Stats = this.l1Cache.getStats();

    return {
      ...this.stats,
      l1Size: l1Stats.size,
      l1Capacity: l1Stats.capacity,
      l1HitRate: this.stats.l1Hits / (this.stats.l1Hits + this.stats.l1Misses) || 0,
      l2HitRate: this.stats.l2Hits / (this.stats.l2Hits + this.stats.l2Misses) || 0
    };
  }

  /**
   * é‡ç½®ç»Ÿè®¡
   */
  resetStats(): void {
    this.stats = {
      l1Hits: 0,
      l1Misses: 0,
      l2Hits: 0,
      l2Misses: 0
    };
  }
}

/**
 * ç¼“å­˜é…ç½®
 */
interface CacheConfig {
  l1MaxSize?: number;             // L1ç¼“å­˜æœ€å¤§å®¹é‡
  l2Path?: string;                // L2ç¼“å­˜è·¯å¾„
}

/**
 * L2ç¼“å­˜æ¡ç›®
 */
interface L2CacheEntry {
  key: string;
  value: string;
  timestamp: number;
  ttl?: number;
}

/**
 * å¤šçº§ç¼“å­˜ç»Ÿè®¡
 */
interface MultiLevelCacheStats {
  l1Hits: number;
  l1Misses: number;
  l2Hits: number;
  l2Misses: number;
  l1Size?: number;
  l1Capacity?: number;
  l1HitRate?: number;
  l2HitRate?: number;
}

export { MultiLevelCache, CacheConfig, MultiLevelCacheStats };
```

---

## å…­ã€æ–‡ä»¶ç›‘å¬å’Œå¢é‡æ›´æ–°

### 6.1 æ–‡ä»¶ç›‘å¬å™¨

```typescript
import chokidar from 'chokidar';
import { EventEmitter } from 'events';

/**
 * æ–‡ä»¶ç›‘å¬å™¨
 */
class FileWatcher extends EventEmitter {
  private watcher: chokidar.FSWatcher | null = null;
  private editHistory: EditHistory[] = [];
  private maxHistorySize: number = 100;

  constructor(private workspaceRoot: string) {
    super();
  }

  /**
   * å¯åŠ¨ç›‘å¬
   */
  start(): void {
    console.log(`ğŸ‘€ å¼€å§‹ç›‘å¬æ–‡ä»¶å˜åŒ–: ${this.workspaceRoot}`);

    this.watcher = chokidar.watch(this.workspaceRoot, {
      ignored: /(^|[\/\\])\../, // å¿½ç•¥éšè—æ–‡ä»¶
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 500,
        pollInterval: 100
      }
    });

    // ç›‘å¬æ–‡ä»¶å˜åŒ–äº‹ä»¶
    this.watcher
      .on('add', (path) => this.onFileAdded(path))
      .on('change', (path) => this.onFileChanged(path))
      .on('unlink', (path) => this.onFileDeleted(path));
  }

  /**
   * åœæ­¢ç›‘å¬
   */
  async stop(): Promise<void> {
    if (this.watcher) {
      await this.watcher.close();
      this.watcher = null;
      console.log('âœ… æ–‡ä»¶ç›‘å¬å·²åœæ­¢');
    }
  }

  /**
   * æ–‡ä»¶æ·»åŠ äº‹ä»¶
   */
  private onFileAdded(filePath: string): void {
    console.log(`â• æ–‡ä»¶æ·»åŠ : ${filePath}`);

    const edit: EditHistory = {
      filePath,
      timestamp: Date.now(),
      changeType: 'create',
      linesBefore: 0,
      linesAfter: 0
    };

    this.addToHistory(edit);
    this.emit('file:added', edit);
  }

  /**
   * æ–‡ä»¶ä¿®æ”¹äº‹ä»¶
   */
  private onFileChanged(filePath: string): void {
    console.log(`âœï¸  æ–‡ä»¶ä¿®æ”¹: ${filePath}`);

    const edit: EditHistory = {
      filePath,
      timestamp: Date.now(),
      changeType: 'modify',
      linesBefore: 0,
      linesAfter: 0
    };

    this.addToHistory(edit);
    this.emit('file:changed', edit);
  }

  /**
   * æ–‡ä»¶åˆ é™¤äº‹ä»¶
   */
  private onFileDeleted(filePath: string): void {
    console.log(`âŒ æ–‡ä»¶åˆ é™¤: ${filePath}`);

    const edit: EditHistory = {
      filePath,
      timestamp: Date.now(),
      changeType: 'delete',
      linesBefore: 0,
      linesAfter: 0
    };

    this.addToHistory(edit);
    this.emit('file:deleted', edit);
  }

  /**
   * æ·»åŠ åˆ°å†å²è®°å½•
   */
  private addToHistory(edit: EditHistory): void {
    this.editHistory.push(edit);

    // é™åˆ¶å†å²è®°å½•å¤§å°
    if (this.editHistory.length > this.maxHistorySize) {
      this.editHistory.shift();
    }
  }

  /**
   * è·å–æœ€è¿‘ç¼–è¾‘è®°å½•
   */
  getRecentEdits(count: number = 10): EditHistory[] {
    return this.editHistory.slice(-count);
  }

  /**
   * è·å–ç‰¹å®šæ–‡ä»¶çš„ç¼–è¾‘å†å²
   */
  getFileEditHistory(filePath: string): EditHistory[] {
    return this.editHistory.filter(e => e.filePath === filePath);
  }

  /**
   * æ¸…ç©ºå†å²è®°å½•
   */
  clearHistory(): void {
    this.editHistory = [];
  }
}

export { FileWatcher };
```

### 6.2 å¢é‡æ›´æ–°ç®¡ç†å™¨

```typescript
/**
 * å¢é‡æ›´æ–°ç®¡ç†å™¨
 */
class IncrementalUpdateManager {
  private fileCache: Map<string, FileSnapshot>;
  private fileWatcher: FileWatcher;

  constructor(workspaceRoot: string) {
    this.fileCache = new Map();
    this.fileWatcher = new FileWatcher(workspaceRoot);

    // ç›‘å¬æ–‡ä»¶å˜åŒ–
    this.fileWatcher.on('file:changed', (edit) => {
      this.handleFileChange(edit);
    });

    this.fileWatcher.start();
  }

  /**
   * å¤„ç†æ–‡ä»¶å˜åŒ–
   */
  private async handleFileChange(edit: EditHistory): Promise<void> {
    const oldSnapshot = this.fileCache.get(edit.filePath);
    if (!oldSnapshot) {
      // é¦–æ¬¡è¯»å–,å…¨é‡åŠ è½½
      await this.loadFullFile(edit.filePath);
      return;
    }

    // è®¡ç®—å·®å¼‚
    const newContent = await fs.readFile(edit.filePath, 'utf-8');
    const diff = this.calculateDiff(oldSnapshot.content, newContent);

    // æ›´æ–°ç¼“å­˜
    this.fileCache.set(edit.filePath, {
      path: edit.filePath,
      content: newContent,
      timestamp: Date.now(),
      diff
    });

    console.log(`ğŸ“ å¢é‡æ›´æ–°: ${edit.filePath}`);
    console.log(`  æ·»åŠ : ${diff.added.length}è¡Œ, åˆ é™¤: ${diff.removed.length}è¡Œ`);
  }

  /**
   * åŠ è½½å®Œæ•´æ–‡ä»¶
   */
  private async loadFullFile(filePath: string): Promise<void> {
    const content = await fs.readFile(filePath, 'utf-8');

    this.fileCache.set(filePath, {
      path: filePath,
      content,
      timestamp: Date.now()
    });
  }

  /**
   * è®¡ç®—æ–‡ä»¶å·®å¼‚
   */
  private calculateDiff(
    oldContent: string,
    newContent: string
  ): FileDiff {
    const oldLines = oldContent.split('\n');
    const newLines = newContent.split('\n');

    const added: DiffLine[] = [];
    const removed: DiffLine[] = [];
    const modified: DiffLine[] = [];

    // ç®€å•çš„é€è¡Œæ¯”è¾ƒ(å®é™…åº”ç”¨ä¸­å¯ä½¿ç”¨diffç®—æ³•å¦‚Myers)
    const maxLen = Math.max(oldLines.length, newLines.length);

    for (let i = 0; i < maxLen; i++) {
      const oldLine = oldLines[i];
      const newLine = newLines[i];

      if (oldLine === undefined) {
        // æ–°å¢è¡Œ
        added.push({ lineNumber: i + 1, content: newLine });
      } else if (newLine === undefined) {
        // åˆ é™¤è¡Œ
        removed.push({ lineNumber: i + 1, content: oldLine });
      } else if (oldLine !== newLine) {
        // ä¿®æ”¹è¡Œ
        modified.push({
          lineNumber: i + 1,
          content: newLine,
          oldContent: oldLine
        });
      }
    }

    return { added, removed, modified };
  }

  /**
   * è·å–æ–‡ä»¶å¿«ç…§
   */
  getFileSnapshot(filePath: string): FileSnapshot | undefined {
    return this.fileCache.get(filePath);
  }

  /**
   * è·å–å˜åŒ–æ‘˜è¦
   */
  getChangesSummary(since: number): ChangesSummary {
    const changes: ChangesSummary = {
      filesChanged: 0,
      linesAdded: 0,
      linesRemoved: 0,
      files: []
    };

    for (const [path, snapshot] of this.fileCache.entries()) {
      if (snapshot.timestamp >= since && snapshot.diff) {
        changes.filesChanged++;
        changes.linesAdded += snapshot.diff.added.length;
        changes.linesRemoved += snapshot.diff.removed.length;
        changes.files.push(path);
      }
    }

    return changes;
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  clearCache(): void {
    this.fileCache.clear();
  }

  /**
   * åœæ­¢ç›‘å¬
   */
  async dispose(): Promise<void> {
    await this.fileWatcher.stop();
    this.clearCache();
  }
}

/**
 * æ–‡ä»¶å¿«ç…§
 */
interface FileSnapshot {
  path: string;
  content: string;
  timestamp: number;
  diff?: FileDiff;
}

/**
 * æ–‡ä»¶å·®å¼‚
 */
interface FileDiff {
  added: DiffLine[];
  removed: DiffLine[];
  modified: DiffLine[];
}

/**
 * å·®å¼‚è¡Œ
 */
interface DiffLine {
  lineNumber: number;
  content: string;
  oldContent?: string;
}

/**
 * å˜åŒ–æ‘˜è¦
 */
interface ChangesSummary {
  filesChanged: number;
  linesAdded: number;
  linesRemoved: number;
  files: string[];
}

export { IncrementalUpdateManager, FileSnapshot, FileDiff, ChangesSummary };
```

---

## ä¸ƒã€ä¸Šä¸‹æ–‡å‹ç¼©æŠ€æœ¯

### 7.1 å‹ç¼©ç­–ç•¥

```typescript
/**
 * ä¸Šä¸‹æ–‡å‹ç¼©å™¨
 */
class ContextCompressor {
  /**
   * å‹ç¼©æ–‡ä»¶å†…å®¹
   */
  compressFileContent(content: string, targetTokens: number): string {
    // ç­–ç•¥1: ç§»é™¤æ³¨é‡Š
    let compressed = this.removeComments(content);

    // ç­–ç•¥2: ç§»é™¤ç©ºè¡Œ
    compressed = this.removeEmptyLines(compressed);

    // ç­–ç•¥3: æå–é‡è¦éƒ¨åˆ†(ç±»å®šä¹‰ã€å‡½æ•°ç­¾åç­‰)
    if (this.estimateTokens(compressed) > targetTokens) {
      compressed = this.extractImportantParts(compressed);
    }

    return compressed;
  }

  /**
   * ç§»é™¤æ³¨é‡Š
   */
  private removeComments(content: string): string {
    // ç§»é™¤å•è¡Œæ³¨é‡Š
    content = content.replace(/\/\/.*$/gm, '');

    // ç§»é™¤å¤šè¡Œæ³¨é‡Š
    content = content.replace(/\/\*[\s\S]*?\*\//g, '');

    return content;
  }

  /**
   * ç§»é™¤ç©ºè¡Œ
   */
  private removeEmptyLines(content: string): string {
    return content
      .split('\n')
      .filter(line => line.trim().length > 0)
      .join('\n');
  }

  /**
   * æå–é‡è¦éƒ¨åˆ†
   */
  private extractImportantParts(content: string): string {
    const lines = content.split('\n');
    const important: string[] = [];

    // æå–: importè¯­å¥ã€ç±»å®šä¹‰ã€å‡½æ•°å®šä¹‰ã€æ¥å£å®šä¹‰
    const importantPatterns = [
      /^import\s/,
      /^export\s/,
      /^class\s/,
      /^interface\s/,
      /^type\s/,
      /^function\s/,
      /^const\s+\w+\s*=/,
      /^\s*async\s+function/,
      /^\s*public\s+/,
      /^\s*private\s+/
    ];

    for (const line of lines) {
      if (importantPatterns.some(pattern => pattern.test(line))) {
        important.push(line);
      }
    }

    return important.join('\n') + '\n\n// ... (other code omitted)';
  }

  /**
   * ç”Ÿæˆä»£ç æ‘˜è¦
   */
  generateCodeSummary(content: string): string {
    const summary: string[] = [];

    // æå–imports
    const imports = this.extractImports(content);
    if (imports.length > 0) {
      summary.push('**Imports:**');
      summary.push(imports.join('\n'));
      summary.push('');
    }

    // æå–ç±»å’Œå‡½æ•°å®šä¹‰
    const definitions = this.extractDefinitions(content);
    if (definitions.length > 0) {
      summary.push('**Definitions:**');
      definitions.forEach(def => {
        summary.push(`- ${def}`);
      });
      summary.push('');
    }

    return summary.join('\n');
  }

  /**
   * æå–importè¯­å¥
   */
  private extractImports(content: string): string[] {
    const imports: string[] = [];
    const lines = content.split('\n');

    for (const line of lines) {
      if (/^import\s/.test(line)) {
        imports.push(line);
      }
    }

    return imports;
  }

  /**
   * æå–å®šä¹‰
   */
  private extractDefinitions(content: string): string[] {
    const definitions: string[] = [];
    const lines = content.split('\n');

    const definitionPatterns = [
      { pattern: /^class\s+(\w+)/, prefix: 'Class' },
      { pattern: /^interface\s+(\w+)/, prefix: 'Interface' },
      { pattern: /^type\s+(\w+)/, prefix: 'Type' },
      { pattern: /^function\s+(\w+)/, prefix: 'Function' },
      { pattern: /^const\s+(\w+)\s*=/, prefix: 'Const' }
    ];

    for (const line of lines) {
      for (const { pattern, prefix } of definitionPatterns) {
        const match = line.match(pattern);
        if (match) {
          definitions.push(`${prefix}: ${match[1]}`);
          break;
        }
      }
    }

    return definitions;
  }

  /**
   * å‹ç¼©å¯¹è¯å†å²
   */
  async compressConversationHistory(
    messages: Message[],
    targetTokens: number,
    aiClient?: any
  ): Promise<Message[]> {
    // å¦‚æœtokenæ•°åœ¨é¢„ç®—å†…,ç›´æ¥è¿”å›
    const currentTokens = this.estimateTokens(JSON.stringify(messages));
    if (currentTokens <= targetTokens) {
      return messages;
    }

    // ç­–ç•¥1: ä¿ç•™æœ€è¿‘Næ¡æ¶ˆæ¯
    let compressed = messages.slice(-10);

    // ç­–ç•¥2: å¦‚æœè¿˜æ˜¯è¶…å‡º,ä½¿ç”¨AIç”Ÿæˆæ‘˜è¦
    if (this.estimateTokens(JSON.stringify(compressed)) > targetTokens && aiClient) {
      const summary = await this.generateConversationSummary(messages, aiClient);
      return [
        {
          role: 'system',
          content: `Previous conversation summary:\n${summary}`
        },
        ...messages.slice(-3) // ä¿ç•™æœ€è¿‘3æ¡
      ];
    }

    return compressed;
  }

  /**
   * ç”Ÿæˆå¯¹è¯æ‘˜è¦
   */
  private async generateConversationSummary(
    messages: Message[],
    aiClient: any
  ): Promise<string> {
    const response = await aiClient.messages.create({
      model: 'claude-3-5-sonnet-20250929',
      max_tokens: 500,
      messages: [
        {
          role: 'user',
          content: `è¯·æ€»ç»“ä»¥ä¸‹å¯¹è¯çš„ä¸»è¦å†…å®¹:\n\n${JSON.stringify(messages)}`
        }
      ]
    });

    return response.content[0].text;
  }

  /**
   * ä¼°ç®—tokenæ•°
   */
  private estimateTokens(text: string): number {
    // ç²—ç•¥ä¼°ç®—: 4å­—ç¬¦ â‰ˆ 1 token
    return Math.ceil(text.length / 4);
  }
}

export { ContextCompressor };
```

---

## å…«ã€ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ•´åˆ

### 8.1 å®Œæ•´çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨

```typescript
/**
 * ä¸Šä¸‹æ–‡ç®¡ç†å™¨ - æ•´åˆæ‰€æœ‰ä¸Šä¸‹æ–‡ç®¡ç†åŠŸèƒ½
 */
class ContextManager {
  private collector: ContextCollector;
  private tokenCounter: TokenCounter;
  private budgetManager: TokenBudgetManager;
  private truncator: SmartTruncator;
  private priorityCalculator: PriorityCalculator;
  private cache: MultiLevelCache;
  private compressor: ContextCompressor;

  constructor(config: ContextManagerConfig) {
    this.collector = new ContextCollector(config.workspaceRoot);
    this.tokenCounter = new TokenCounter();
    this.budgetManager = new TokenBudgetManager(config.maxTokens);
    this.truncator = new SmartTruncator(config.maxTokens);
    this.priorityCalculator = new PriorityCalculator();
    this.cache = new MultiLevelCache(config.cacheConfig || {});
    this.compressor = new ContextCompressor();
  }

  /**
   * å‡†å¤‡ä¸Šä¸‹æ–‡ - ä¸»å…¥å£
   */
  async prepareContext(options: PrepareOptions): Promise<PreparedContext> {
    console.log('ğŸ”„ å¼€å§‹å‡†å¤‡ä¸Šä¸‹æ–‡...');

    // 1. æ”¶é›†åŸå§‹ä¸Šä¸‹æ–‡
    const rawContext = await this.collector.collectFullContext({
      conversationHistory: options.conversationHistory,
      recentToolResults: options.toolResults,
      userFiles: options.userFiles
    });

    // 2. è®¡ç®—ä¼˜å…ˆçº§
    const contextItems = this.convertToItems(rawContext);
    const prioritized = this.priorityCalculator.calculateBatch(
      contextItems,
      options.priorityContext || {}
    );

    // 3. æ£€æŸ¥tokené¢„ç®—
    const budgetCheck = this.budgetManager.checkBudget(rawContext);

    // 4. å¦‚æœè¶…å‡ºé¢„ç®—,è¿›è¡Œä¼˜åŒ–
    let optimizedItems = prioritized;
    if (!budgetCheck.isWithinBudget) {
      console.log('âš ï¸  è¶…å‡ºé¢„ç®—,è¿›è¡Œä¼˜åŒ–...');

      // æ’åº
      optimizedItems = this.priorityCalculator.sort(prioritized);

      // æˆªæ–­
      const targetTokens = this.budgetManager.budgetAllocation.total -
        this.budgetManager.budgetAllocation.reserved;
      optimizedItems = this.truncator.truncate(optimizedItems, targetTokens);
    }

    // 5. è½¬æ¢å›å®Œæ•´ä¸Šä¸‹æ–‡æ ¼å¼
    const finalContext = this.convertToFullContext(optimizedItems, rawContext);

    // 6. ç”ŸæˆæŠ¥å‘Š
    const report = this.budgetManager.generateReport(finalContext);
    console.log(report);

    return {
      context: finalContext,
      metadata: {
        totalItems: contextItems.length,
        includedItems: optimizedItems.length,
        totalTokens: this.tokenCounter.countContext(finalContext).total,
        budgetUtilization: budgetCheck.currentUsage.total / budgetCheck.budgetAllocation.total,
        optimized: !budgetCheck.isWithinBudget
      }
    };
  }

  /**
   * å°†FullContextè½¬æ¢ä¸ºContextItemæ•°ç»„
   */
  private convertToItems(context: FullContext): ContextItem[] {
    const items: ContextItem[] = [];

    // é™æ€ä¸Šä¸‹æ–‡
    items.push({
      type: 'system',
      content: context.static.systemPrompt,
      priority: 10,
      tokens: this.tokenCounter.count(context.static.systemPrompt)
    });

    // åŠ¨æ€ä¸Šä¸‹æ–‡ - æ–‡ä»¶
    for (const file of context.dynamic.files) {
      items.push({
        type: 'file',
        content: file.content,
        priority: 7,
        tokens: this.tokenCounter.count(file.content),
        metadata: {
          path: file.path,
          language: file.language
        },
        filePath: file.path,
        relevanceScore: file.relevanceScore,
        timestamp: file.lastModified
      });
    }

    // å¯¹è¯å†å²
    if (context.dynamic.conversationHistory.length > 0) {
      items.push({
        type: 'conversation',
        content: JSON.stringify(context.dynamic.conversationHistory),
        priority: 4,
        tokens: this.tokenCounter.countMessages(context.dynamic.conversationHistory)
      });
    }

    // å·¥å…·ç»“æœ
    for (const result of context.temporary.toolResults) {
      items.push({
        type: 'tool_result',
        content: JSON.stringify(result),
        priority: 6,
        tokens: this.tokenCounter.count(JSON.stringify(result)),
        timestamp: result.timestamp
      });
    }

    return items;
  }

  /**
   * å°†ContextItemæ•°ç»„è½¬æ¢å›FullContext
   */
  private convertToFullContext(
    items: ContextItem[],
    original: FullContext
  ): FullContext {
    const result: FullContext = {
      static: { ...original.static },
      dynamic: {
        files: [],
        gitStatus: original.dynamic.gitStatus,
        conversationHistory: [],
        recentEdits: original.dynamic.recentEdits
      },
      temporary: {
        toolResults: [],
        userSpecifiedFiles: original.temporary.userSpecifiedFiles,
        sessionVariables: original.temporary.sessionVariables,
        pendingOperations: []
      },
      timestamp: Date.now()
    };

    // é‡æ–°ç»„è£…
    for (const item of items) {
      if (item.type === 'system') {
        result.static.systemPrompt = item.content;
      } else if (item.type === 'file' && item.metadata?.path) {
        result.dynamic.files.push({
          path: item.metadata.path,
          content: item.content,
          language: item.metadata.language,
          size: item.content.length,
          lastModified: item.timestamp || Date.now(),
          relevanceScore: item.relevanceScore
        });
      } else if (item.type === 'conversation') {
        result.dynamic.conversationHistory = JSON.parse(item.content);
      } else if (item.type === 'tool_result') {
        result.temporary.toolResults.push(JSON.parse(item.content));
      }
    }

    return result;
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  async cleanup(): Promise<void> {
    await this.cache.cleanup();
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): ContextManagerStats {
    return {
      cache: this.cache.getStats(),
      budget: this.budgetManager.budgetAllocation
    };
  }
}

/**
 * ä¸Šä¸‹æ–‡ç®¡ç†å™¨é…ç½®
 */
interface ContextManagerConfig {
  workspaceRoot: string;
  maxTokens?: number;
  cacheConfig?: CacheConfig;
}

/**
 * å‡†å¤‡é€‰é¡¹
 */
interface PrepareOptions {
  conversationHistory?: Message[];
  toolResults?: ToolResult[];
  userFiles?: string[];
  priorityContext?: PriorityContext;
}

/**
 * å‡†å¤‡å¥½çš„ä¸Šä¸‹æ–‡
 */
interface PreparedContext {
  context: FullContext;
  metadata: {
    totalItems: number;
    includedItems: number;
    totalTokens: number;
    budgetUtilization: number;
    optimized: boolean;
  };
}

/**
 * ä¸Šä¸‹æ–‡ç®¡ç†å™¨ç»Ÿè®¡
 */
interface ContextManagerStats {
  cache: MultiLevelCacheStats;
  budget: BudgetAllocation;
}

export { ContextManager, ContextManagerConfig, PrepareOptions, PreparedContext };
```

---

## ä¹ã€æœ€ä½³å®è·µ

### 9.1 è®¾è®¡å»ºè®®

**1. åˆ†å±‚ç®¡ç†**
```typescript
// âœ… å¥½çš„åšæ³•: æŒ‰å±‚çº§ç»„ç»‡ä¸Šä¸‹æ–‡
const context = {
  static: {
    systemPrompt: '...',
    toolDefs: [...]
  },
  dynamic: {
    files: [...],
    conversation: [...]
  },
  temporary: {
    toolResults: [...]
  }
};

// âŒ ä¸å¥½çš„åšæ³•: æ··åœ¨ä¸€èµ·
const context = {
  systemPrompt: '...',
  files: [...],
  conversation: [...],
  toolResults: [...]
};
```

**2. ä¼˜å…ˆçº§æ˜ç¡®**
```typescript
// âœ… å¥½çš„åšæ³•: æ˜ç¡®å®šä¹‰ä¼˜å…ˆçº§ç­–ç•¥
const priorityRules = {
  userExplicit: 10,
  currentFile: 9,
  recentEdit: 8,
  errorRelated: 8,
  relatedFile: 7
};

// âŒ ä¸å¥½çš„åšæ³•: ç¡¬ç¼–ç æˆ–éšæ„è®¾ç½®
const priority = 5; // ä¸ºä»€ä¹ˆæ˜¯5?
```

**3. Tokené¢„ç®—æ§åˆ¶**
```typescript
// âœ… å¥½çš„åšæ³•: é¢„ç•™è¾“å‡ºç©ºé—´
const budget = {
  input: maxTokens * 0.9,    // 90% è¾“å…¥
  output: maxTokens * 0.1     // 10% è¾“å‡º
};

// âŒ ä¸å¥½çš„åšæ³•: ç”¨æ»¡æ‰€æœ‰tokens
const budget = maxTokens; // æ²¡æœ‰è¾“å‡ºç©ºé—´
```

### 9.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

**1. ä½¿ç”¨ç¼“å­˜**
```typescript
// âœ… ç¼“å­˜æ–‡ä»¶å†…å®¹
const cached = await cache.get(filePath);
if (cached) {
  return cached;
}

const content = await fs.readFile(filePath);
await cache.set(filePath, content);
return content;
```

**2. æ‡’åŠ è½½**
```typescript
// âœ… åªåœ¨éœ€è¦æ—¶åŠ è½½
async getContext() {
  const files = await this.loadRequiredFiles(); // åªåŠ è½½å¿…è¦æ–‡ä»¶
  return { files };
}

// âŒ é¢„åŠ è½½æ‰€æœ‰
async getContext() {
  const allFiles = await this.loadAllFiles(); // å¯èƒ½å¾ˆæ…¢
  return { files: allFiles };
}
```

**3. å¹¶è¡Œå¤„ç†**
```typescript
// âœ… å¹¶è¡Œæ”¶é›†
const [files, gitStatus, recentEdits] = await Promise.all([
  this.collectFiles(),
  this.getGitStatus(),
  this.getRecentEdits()
]);

// âŒ ä¸²è¡Œå¤„ç†
const files = await this.collectFiles();
const gitStatus = await this.getGitStatus();
const recentEdits = await this.getRecentEdits();
```

### 9.3 å¸¸è§é™·é˜±

**é™·é˜±1: å¿½ç•¥Tokené¢„ç®—**
```typescript
// âŒ é—®é¢˜ä»£ç 
async prepareContext() {
  const files = await this.loadAllFiles(); // å¯èƒ½è¶…å‡ºé¢„ç®—
  return { files };
}

// âœ… æ­£ç¡®åšæ³•
async prepareContext() {
  let files = await this.loadAllFiles();
  const tokens = this.countTokens(files);

  if (tokens > this.maxTokens) {
    files = this.truncateFiles(files, this.maxTokens);
  }

  return { files };
}
```

**é™·é˜±2: ç¼“å­˜å¤±æ•ˆ**
```typescript
// âŒ é—®é¢˜ä»£ç 
const content = cache.get(filePath); // æ²¡æœ‰æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¿®æ”¹

// âœ… æ­£ç¡®åšæ³•
const cached = cache.get(filePath);
const stat = await fs.stat(filePath);

if (cached && cached.mtime === stat.mtimeMs) {
  return cached.content;
}

// é‡æ–°è¯»å–
const content = await fs.readFile(filePath);
cache.set(filePath, { content, mtime: stat.mtimeMs });
```

**é™·é˜±3: å†…å­˜æ³„æ¼**
```typescript
// âŒ é—®é¢˜ä»£ç 
class ContextManager {
  private cache = new Map(); // æ— é™å¢é•¿

  addToCache(key, value) {
    this.cache.set(key, value);
  }
}

// âœ… æ­£ç¡®åšæ³•
class ContextManager {
  private cache: LRUCache; // é™åˆ¶å¤§å°

  constructor() {
    this.cache = new LRUCache(100); // æœ€å¤š100é¡¹
  }
}
```

---

## åã€å¸¸è§é—®é¢˜FAQ

### Q1: å¦‚ä½•é€‰æ‹©åˆé€‚çš„Tokené¢„ç®—?

**å»ºè®®**:
```typescript
// æ ¹æ®ä»»åŠ¡å¤æ‚åº¦è°ƒæ•´
const budgetByTask = {
  simple: 50000,    // ç®€å•ä»»åŠ¡(ä»£ç æ ¼å¼åŒ–ç­‰)
  medium: 100000,   // ä¸­ç­‰ä»»åŠ¡(ä»£ç é‡æ„ç­‰)
  complex: 150000   // å¤æ‚ä»»åŠ¡(æ¶æ„è®¾è®¡ç­‰)
};

// ç›‘æ§å®é™…ä½¿ç”¨æƒ…å†µ
const stats = contextManager.getStats();
if (stats.budgetUtilization > 0.9) {
  console.warn('é¢„ç®—ä½¿ç”¨ç‡è¿‡é«˜,è€ƒè™‘å¢åŠ é¢„ç®—æˆ–ä¼˜åŒ–ä¸Šä¸‹æ–‡');
}
```

### Q2: ä¸Šä¸‹æ–‡è¿‡å¤§å¯¼è‡´å“åº”æ…¢æ€ä¹ˆåŠ?

**è§£å†³æ–¹æ¡ˆ**:
1. **å¯ç”¨ç¼“å­˜**: é¿å…é‡å¤è¯»å–æ–‡ä»¶
2. **æ™ºèƒ½æˆªæ–­**: ç§»é™¤ä½ä¼˜å…ˆçº§å†…å®¹
3. **å‹ç¼©å†…å®¹**: ç§»é™¤æ³¨é‡Šã€ç©ºè¡Œ
4. **åˆ†æ‰¹å¤„ç†**: å°†å¤§ä»»åŠ¡æ‹†åˆ†

```typescript
// ç¤ºä¾‹: åˆ†æ‰¹å¤„ç†å¤§é‡æ–‡ä»¶
async function processLargeCodebase(files: string[]) {
  const batchSize = 10;

  for (let i = 0; i < files.length; i += batchSize) {
    const batch = files.slice(i, i + batchSize);
    await processFiles(batch);
  }
}
```

### Q3: å¦‚ä½•å¤„ç†é¢‘ç¹å˜åŒ–çš„æ–‡ä»¶?

**ç­–ç•¥**:
```typescript
// 1. ä½¿ç”¨æ–‡ä»¶ç›‘å¬
const watcher = new FileWatcher(workspaceRoot);
watcher.on('file:changed', async (edit) => {
  // å¤±æ•ˆç¼“å­˜
  cache.delete(edit.filePath);

  // é€šçŸ¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨
  contextManager.onFileChanged(edit);
});

// 2. è®¾ç½®è¾ƒçŸ­çš„ç¼“å­˜TTL
cache.set(filePath, content, 60000); // 1åˆ†é’Ÿè¿‡æœŸ
```

### Q4: å¤šä¸ªç”¨æˆ·å…±äº«ä¸Šä¸‹æ–‡ç¼“å­˜æ˜¯å¦å®‰å…¨?

**æ³¨æ„äº‹é¡¹**:
```typescript
// âŒ ä¸å®‰å…¨: ç›´æ¥å…±äº«
const sharedCache = new LRUCache(1000);

// âœ… å®‰å…¨: æŒ‰ç”¨æˆ·éš”ç¦»
class UserContextCache {
  private caches = new Map<string, LRUCache>();

  getCache(userId: string): LRUCache {
    if (!this.caches.has(userId)) {
      this.caches.set(userId, new LRUCache(100));
    }
    return this.caches.get(userId)!;
  }
}
```

### Q5: å¦‚ä½•è°ƒè¯•ä¸Šä¸‹æ–‡é—®é¢˜?

**è°ƒè¯•æŠ€å·§**:
```typescript
// 1. å¯ç”¨è¯¦ç»†æ—¥å¿—
contextManager.setDebugMode(true);

// 2. å¯¼å‡ºä¸Šä¸‹æ–‡å¿«ç…§
const snapshot = contextManager.exportSnapshot();
fs.writeFileSync('context-snapshot.json', JSON.stringify(snapshot, null, 2));

// 3. åˆ†æTokenåˆ†å¸ƒ
const report = budgetManager.generateReport(context);
console.log(report);
```

---

## åä¸€ã€å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1: å®ç°åŸºç¡€ä¸Šä¸‹æ–‡æ”¶é›†å™¨

**ç›®æ ‡**: æ”¶é›†é¡¹ç›®çš„åŸºæœ¬ä¸Šä¸‹æ–‡ä¿¡æ¯

```typescript
class BasicContextCollector {
  /**
   * æ”¶é›†é¡¹ç›®ä¸Šä¸‹æ–‡
   * è¦æ±‚:
   * 1. è¯»å–package.json
   * 2. è·å–gitçŠ¶æ€
   * 3. åˆ—å‡ºsrcç›®å½•ä¸‹çš„æ‰€æœ‰.tsæ–‡ä»¶
   * 4. è®¡ç®—æ€»Tokenæ•°
   */
  async collect(workspaceRoot: string): Promise<ProjectContext> {
    // ä½ çš„å®ç°...
  }
}

interface ProjectContext {
  name: string;
  files: string[];
  gitBranch: string;
  totalTokens: number;
}
```

### ç»ƒä¹ 2: å®ç°æ™ºèƒ½æ–‡ä»¶é€‰æ‹©

**ç›®æ ‡**: æ ¹æ®ç”¨æˆ·æŸ¥è¯¢é€‰æ‹©æœ€ç›¸å…³çš„æ–‡ä»¶

```typescript
class SmartFileSelector {
  /**
   * é€‰æ‹©ç›¸å…³æ–‡ä»¶
   * è¦æ±‚:
   * 1. åˆ†æç”¨æˆ·æŸ¥è¯¢ä¸­çš„å…³é”®è¯
   * 2. åœ¨æ–‡ä»¶ä¸­æœç´¢å…³é”®è¯
   * 3. è®¡ç®—ç›¸å…³æ€§è¯„åˆ†
   * 4. è¿”å›Top Nä¸ªæœ€ç›¸å…³çš„æ–‡ä»¶
   */
  async selectFiles(
    userQuery: string,
    allFiles: string[],
    topN: number = 5
  ): Promise<RankedFile[]> {
    // ä½ çš„å®ç°...
  }
}

interface RankedFile {
  path: string;
  relevance: number;
  matchedKeywords: string[];
}
```

### ç»ƒä¹ 3: å®ç°Tokené¢„ç®—ä¼˜åŒ–å™¨

**ç›®æ ‡**: åœ¨Tokené¢„ç®—å†…æœ€å¤§åŒ–ä¸Šä¸‹æ–‡ä»·å€¼

```typescript
class TokenBudgetOptimizer {
  /**
   * ä¼˜åŒ–ä¸Šä¸‹æ–‡
   * è¦æ±‚:
   * 1. è®¡ç®—æ¯ä¸ªé¡¹çš„"ä»·å€¼å¯†åº¦"(ä¼˜å…ˆçº§/Tokenæ•°)
   * 2. ä½¿ç”¨è´ªå¿ƒç®—æ³•é€‰æ‹©é¡¹
   * 3. ç¡®ä¿ä¸è¶…å‡ºé¢„ç®—
   * 4. è¿”å›ä¼˜åŒ–åçš„é¡¹åˆ—è¡¨
   */
  optimize(
    items: ContextItem[],
    maxTokens: number
  ): ContextItem[] {
    // ä½ çš„å®ç°...
  }

  /**
   * è®¡ç®—ä»·å€¼å¯†åº¦
   */
  private calculateValueDensity(item: ContextItem): number {
    // ä½ çš„å®ç°...
  }
}
```

**æç¤º**:
- ç»ƒä¹ 1: ä½¿ç”¨`fs.readFile`å’Œ`child_process.exec`
- ç»ƒä¹ 2: å¯ä»¥ä½¿ç”¨ç®€å•çš„TF-IDFç®—æ³•
- ç»ƒä¹ 3: è´ªå¿ƒç®—æ³•æŒ‰ä»·å€¼å¯†åº¦é™åºæ’åº

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **ä¸Šä¸‹æ–‡åˆ†ç±»**
   - é™æ€ä¸Šä¸‹æ–‡: ä¸å˜çš„åŸºç¡€ä¿¡æ¯
   - åŠ¨æ€ä¸Šä¸‹æ–‡: éšé¡¹ç›®çŠ¶æ€å˜åŒ–
   - ä¸´æ—¶ä¸Šä¸‹æ–‡: å•æ¬¡å¯¹è¯æœ‰æ•ˆ

2. **Tokenç®¡ç†**
   - ç²¾ç¡®è®¡æ•°: ä½¿ç”¨tiktokenåº“
   - é¢„ç®—åˆ†é…: é™æ€10%ã€åŠ¨æ€70%ã€ä¸´æ—¶20%
   - é¢„ç•™ç©ºé—´: è‡³å°‘10%ç”¨äºè¾“å‡º

3. **æ™ºèƒ½æˆªæ–­**
   - ä¼˜å…ˆçº§æ’åº: ç³»ç»Ÿ>å½“å‰æ–‡ä»¶>æœ€è¿‘ç¼–è¾‘>å†å²å¯¹è¯
   - åˆ†å±‚æˆªæ–­: å…ˆä¸´æ—¶ã€å†åŠ¨æ€ã€ä¿æŠ¤é™æ€
   - éƒ¨åˆ†ä¿ç•™: å¤§æ–‡ä»¶æˆªå–é‡è¦éƒ¨åˆ†

4. **ç¼“å­˜ä¼˜åŒ–**
   - å¤šçº§ç¼“å­˜: L1å†…å­˜ + L2ç£ç›˜
   - LRUç­–ç•¥: è‡ªåŠ¨æ·˜æ±°æœ€ä¹…æœªç”¨
   - TTLè¿‡æœŸ: é¿å…è¿‡æœŸæ•°æ®

5. **å¢é‡æ›´æ–°**
   - æ–‡ä»¶ç›‘å¬: å®æ—¶æ„ŸçŸ¥å˜åŒ–
   - å·®å¼‚è®¡ç®—: åªæ›´æ–°å˜åŒ–éƒ¨åˆ†
   - æ™ºèƒ½å¤±æ•ˆ: ç²¾å‡†å¤±æ•ˆç¼“å­˜

### æœ€ä½³å®è·µæ€»ç»“

âœ… **DO åº”è¯¥åšçš„**:
- æ˜ç¡®å®šä¹‰ä¼˜å…ˆçº§ç­–ç•¥
- é¢„ç•™å……è¶³çš„è¾“å‡ºTokenç©ºé—´
- å¯ç”¨å¤šçº§ç¼“å­˜
- ç›‘æ§Tokenä½¿ç”¨æƒ…å†µ
- å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜

âŒ **DON'T ä¸åº”è¯¥åšçš„**:
- å°†æ‰€æœ‰æ–‡ä»¶éƒ½åŠ å…¥ä¸Šä¸‹æ–‡
- å¿½ç•¥Tokené¢„ç®—é™åˆ¶
- ç¼“å­˜æ°¸ä¸è¿‡æœŸ
- ç¡¬ç¼–ç ä¼˜å…ˆçº§å€¼
- é˜»å¡ä¸»çº¿ç¨‹è¯»å–å¤§æ–‡ä»¶

### æ€§èƒ½æŒ‡æ ‡

ä¼˜ç§€çš„ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿåº”è¯¥è¾¾åˆ°:
- Tokené¢„ç®—åˆ©ç”¨ç‡: 70-90%
- ç¼“å­˜å‘½ä¸­ç‡: >90%
- ä¸Šä¸‹æ–‡å‡†å¤‡æ—¶é—´: <1ç§’
- å†…å­˜å ç”¨: <500MB
- æ–‡ä»¶å˜åŒ–å“åº”: <100ms

### ä¸‹ä¸€æ­¥

åœ¨æŒæ¡äº†ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿå,ä½ å¯ä»¥:

1. **æ·±å…¥å­¦ä¹ ç¬¬4ç¯‡**: ä¼šè¯ä¸çŠ¶æ€ç®¡ç†
2. **å®è·µé¡¹ç›®**: æ„å»ºè‡ªå·±çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨
3. **æ€§èƒ½ä¼˜åŒ–**: é’ˆå¯¹å¤§å‹é¡¹ç›®ä¼˜åŒ–
4. **æ‰©å±•åŠŸèƒ½**: æ”¯æŒæ›´å¤šæ–‡ä»¶ç±»å‹å’Œæ•°æ®æº

---

## æ‰©å±•é˜…è¯»

### æ¨èèµ„æº

1. **TokenåŒ–åŸç†**
   - [Tiktokenåº“æ–‡æ¡£](https://github.com/openai/tiktoken)
   - [BPEç®—æ³•è¯¦è§£](https://huggingface.co/learn/nlp-course/chapter6/5)

2. **ç¼“å­˜ç­–ç•¥**
   - [LRUç®—æ³•å®ç°](https://leetcode.com/problems/lru-cache/)
   - [ç¼“å­˜è®¾è®¡æ¨¡å¼](https://martinfowler.com/articles/patterns-of-distributed-systems/cache.html)

3. **æ–‡ä»¶ç›‘å¬**
   - [Chokidaråº“æ–‡æ¡£](https://github.com/paulmillr/chokidar)
   - [æ–‡ä»¶ç³»ç»Ÿäº‹ä»¶](https://nodejs.org/api/fs.html#fswatchfilename-options-listener)

4. **Diffç®—æ³•**
   - [Myers Diffç®—æ³•](https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/)
   - [Google Diff-Match-Patch](https://github.com/google/diff-match-patch)

---

**ç³»åˆ—æ–‡ç« å¯¼èˆª**:
- [ç¬¬1ç¯‡: æ•´ä½“æ¶æ„è®¾è®¡](./01-æ•´ä½“æ¶æ„è®¾è®¡.md)
- [ç¬¬2ç¯‡: æ ¸å¿ƒå¼•æ“å®ç°](./02-æ ¸å¿ƒå¼•æ“å®ç°.md)
- [ç¬¬3ç¯‡: ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ](./03-ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ.md) (å½“å‰)
- [ç¬¬4ç¯‡: ä¼šè¯ä¸çŠ¶æ€ç®¡ç†](./04-ä¼šè¯ä¸çŠ¶æ€ç®¡ç†.md) (å³å°†å‘å¸ƒ)

---

**æ–‡æ¡£ä¿¡æ¯**:
- å­—æ•°ç»Ÿè®¡: ~9,500å­—
- ä»£ç ç¤ºä¾‹: 20+
- Mermaidå›¾: 5ä¸ª
- æœ€åæ›´æ–°: 2025-01-14
