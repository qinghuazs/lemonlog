---
title: Claude Codeæ¶æ„è¯¦è§£ï¼ˆåï¼‰ï¼šæµè§ˆå™¨è‡ªåŠ¨åŒ–é›†æˆ
date: 2025-01-16
permalink: /ai/claude-code/architecture/10-browser-automation.html
tags:
  - Claude Code
  - æµè§ˆå™¨è‡ªåŠ¨åŒ–
  - Playwright
  - MCP
categories:
  - AI
  - Claude Code
---

# ç¬¬10ç¯‡ï¼šæµè§ˆå™¨è‡ªåŠ¨åŒ–é›†æˆ

## å¼•è¨€

æµè§ˆå™¨è‡ªåŠ¨åŒ–æ˜¯ç°ä»£è½¯ä»¶å¼€å‘ä¸­ä¸å¯æˆ–ç¼ºçš„èƒ½åŠ›ï¼Œæ— è®ºæ˜¯ Web åº”ç”¨æµ‹è¯•ã€ç½‘é¡µæ•°æ®æŠ“å–ï¼Œè¿˜æ˜¯è‡ªåŠ¨åŒ–è¿ç»´ä»»åŠ¡ï¼Œéƒ½éœ€è¦ä¸æµè§ˆå™¨è¿›è¡Œäº¤äº’ã€‚Claude Code é€šè¿‡ Playwright MCP Server æä¾›äº†å¼ºå¤§çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–èƒ½åŠ›ï¼Œè®© AI èƒ½å¤Ÿåƒäººç±»ä¸€æ ·æ“ä½œæµè§ˆå™¨ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦æµè§ˆå™¨è‡ªåŠ¨åŒ–ï¼Ÿ

åœ¨ AI è¾…åŠ©å¼€å‘ä¸­ï¼Œæµè§ˆå™¨è‡ªåŠ¨åŒ–æœ‰ä»¥ä¸‹åº”ç”¨åœºæ™¯ï¼š

1. **è‡ªåŠ¨åŒ–æµ‹è¯•**ï¼šè‡ªåŠ¨æ‰§è¡Œ Web åº”ç”¨çš„ç«¯åˆ°ç«¯æµ‹è¯•
2. **ç½‘é¡µæ•°æ®é‡‡é›†**ï¼šä»åŠ¨æ€ç½‘é¡µä¸­æå–æ•°æ®
3. **UI äº¤äº’è°ƒè¯•**ï¼šæ¨¡æ‹Ÿç”¨æˆ·æ“ä½œï¼Œå®šä½å‰ç«¯é—®é¢˜
4. **æˆªå›¾å’Œæ–‡æ¡£ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆåº”ç”¨æˆªå›¾å’Œæ–‡æ¡£
5. **ç½‘ç«™ç›‘æ§**ï¼šå®šæœŸæ£€æŸ¥ç½‘ç«™å¯ç”¨æ€§å’ŒåŠŸèƒ½æ­£å¸¸æ€§

### æœ¬æ–‡ç›®æ ‡

é€šè¿‡æœ¬æ–‡ï¼Œä½ å°†å­¦ä¹ åˆ°ï¼š
- Playwright MCP Server çš„å®ç°åŸç†
- é¡µé¢å¿«ç…§å’Œ DOM è§£æï¼ˆAccessibility Treeï¼‰
- å…ƒç´ å®šä½å’Œäº¤äº’ï¼ˆclickã€typeã€select ç­‰ï¼‰
- ç½‘ç»œè¯·æ±‚ç›‘æ§å’Œæ‹¦æˆª
- æˆªå›¾å’Œ PDF ç”Ÿæˆ
- è‡ªåŠ¨åŒ–æµ‹è¯•åœºæ™¯
- å®Œæ•´çš„ Web è‡ªåŠ¨åŒ–å®æˆ˜æ¡ˆä¾‹

---

## ä¸€ã€Playwright ç®€ä»‹

### 1.1 ä»€ä¹ˆæ˜¯ Playwrightï¼Ÿ

Playwright æ˜¯å¾®è½¯å¼€æºçš„ç«¯åˆ°ç«¯æµ‹è¯•æ¡†æ¶ï¼Œæ”¯æŒå¤šç§æµè§ˆå™¨ï¼ˆChromiumã€Firefoxã€WebKitï¼‰å’Œå¤šç§è¯­è¨€ï¼ˆJavaScriptã€TypeScriptã€Pythonã€Javaã€.NETï¼‰ã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- ğŸŒ **å¤šæµè§ˆå™¨æ”¯æŒ**ï¼šChromiumã€Firefoxã€WebKit
- ğŸ“± **ç§»åŠ¨ç«¯æ¨¡æ‹Ÿ**ï¼šæ¨¡æ‹Ÿç§»åŠ¨è®¾å¤‡å’Œè§¦æ‘¸æ“ä½œ
- ğŸš€ **è‡ªåŠ¨ç­‰å¾…**ï¼šè‡ªåŠ¨ç­‰å¾…å…ƒç´ å¯æ“ä½œ
- ğŸ­ **æµè§ˆå™¨ä¸Šä¸‹æ–‡**ï¼šéš”ç¦»çš„æµè§ˆå™¨ä¼šè¯
- ğŸ“¸ **æˆªå›¾å’Œè§†é¢‘**ï¼šè‡ªåŠ¨æˆªå›¾å’Œå½•åˆ¶è§†é¢‘
- ğŸ” **å¼ºå¤§çš„é€‰æ‹©å™¨**ï¼šCSSã€XPathã€æ–‡æœ¬ã€è§’è‰²ç­‰

### 1.2 Playwright æ¶æ„

```mermaid
graph TB
    subgraph "Playwrightæ¶æ„"
        A[Test Code<br/>æµ‹è¯•ä»£ç ] --> B[Playwright API]
        B --> C1[Chromium Driver]
        B --> C2[Firefox Driver]
        B --> C3[WebKit Driver]

        C1 --> D1[Chromium Browser]
        C2 --> D2[Firefox Browser]
        C3 --> D3[WebKit Browser]

        D1 --> E[Web Application]
        D2 --> E
        D3 --> E
    end

    style A fill:#e1f5ff
    style B fill:#ffe1f5
    style E fill:#e1ffe1
```

### 1.3 Playwright ä¸ Selenium çš„åŒºåˆ«

| ç‰¹æ€§ | Playwright | Selenium |
|------|-----------|----------|
| **æµè§ˆå™¨æ§åˆ¶** | ç›´æ¥æ§åˆ¶æµè§ˆå™¨å†…æ ¸ | é€šè¿‡ WebDriver åè®® |
| **è‡ªåŠ¨ç­‰å¾…** | å†…ç½®è‡ªåŠ¨ç­‰å¾…æœºåˆ¶ | éœ€è¦æ‰‹åŠ¨ç­‰å¾… |
| **ç½‘ç»œæ‹¦æˆª** | åŸç”Ÿæ”¯æŒ | éœ€è¦é¢å¤–å·¥å…· |
| **å¤šæ ‡ç­¾é¡µ** | åŸç”Ÿæ”¯æŒï¼ŒAPI å‹å¥½ | æ”¯æŒä½† API å¤æ‚ |
| **é€Ÿåº¦** | æ›´å¿«ï¼ˆç›´æ¥æ§åˆ¶ï¼‰ | è¾ƒæ…¢ï¼ˆåè®®é€šä¿¡ï¼‰ |
| **æµè§ˆå™¨æ”¯æŒ** | Chromiumã€Firefoxã€WebKit | æ‰€æœ‰ä¸»æµæµè§ˆå™¨ |

---

## äºŒã€Playwright MCP Server å®ç°

### 2.1 æ•´ä½“æ¶æ„

Claude Code é€šè¿‡ MCPï¼ˆModel Context Protocolï¼‰ä¸ Playwright Server é€šä¿¡ï¼Œå®ç°æµè§ˆå™¨è‡ªåŠ¨åŒ–èƒ½åŠ›ã€‚

```mermaid
graph TB
    subgraph "Claude Code"
        A[Claude AI] --> B[MCP Client]
    end

    subgraph "Playwright MCP Server"
        B --> C[JSON-RPC Handler]
        C --> D[Tool Router]
        D --> E1[Browser Manager]
        D --> E2[Page Manager]
        D --> E3[Element Manager]

        E1 --> F[Playwright API]
        E2 --> F
        E3 --> F
    end

    subgraph "Browser"
        F --> G[Chromium/Firefox/WebKit]
        G --> H[Web Page]
    end

    style A fill:#e1f5ff
    style F fill:#ffe1f5
    style H fill:#e1ffe1
```

### 2.2 æ ¸å¿ƒç»„ä»¶

#### **BrowserManagerï¼ˆæµè§ˆå™¨ç®¡ç†å™¨ï¼‰**

è´Ÿè´£æµè§ˆå™¨å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼š

```typescript
/**
 * æµè§ˆå™¨ç®¡ç†å™¨
 * ç®¡ç†æµè§ˆå™¨å®ä¾‹çš„åˆ›å»ºã€é…ç½®å’Œé”€æ¯
 */
class BrowserManager {
  private browser: Browser | null = null;
  private context: BrowserContext | null = null;
  private page: Page | null = null;

  /**
   * å¯åŠ¨æµè§ˆå™¨
   */
  async launch(options: LaunchOptions = {}): Promise<void> {
    const playwright = require('playwright');

    // é»˜è®¤é…ç½®
    const defaultOptions: LaunchOptions = {
      headless: false,  // æ˜¾ç¤ºæµè§ˆå™¨çª—å£
      slowMo: 0,        // æ“ä½œå»¶è¿Ÿï¼ˆmsï¼‰
      timeout: 30000,   // è¶…æ—¶æ—¶é—´
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage'
      ]
    };

    // å¯åŠ¨æµè§ˆå™¨
    this.browser = await playwright.chromium.launch({
      ...defaultOptions,
      ...options
    });

    // åˆ›å»ºæµè§ˆå™¨ä¸Šä¸‹æ–‡
    this.context = await this.browser.newContext({
      viewport: { width: 1280, height: 720 },
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
      locale: 'en-US',
      timezoneId: 'America/New_York',
      permissions: ['geolocation', 'notifications']
    });

    // åˆ›å»ºé¡µé¢
    this.page = await this.context.newPage();

    console.error('[BrowserManager] Browser launched successfully');
  }

  /**
   * è·å–å½“å‰é¡µé¢
   */
  getPage(): Page {
    if (!this.page) {
      throw new Error('Browser not launched. Call launch() first.');
    }
    return this.page;
  }

  /**
   * è°ƒæ•´çª—å£å¤§å°
   */
  async resize(width: number, height: number): Promise<void> {
    await this.getPage().setViewportSize({ width, height });
  }

  /**
   * å…³é—­æµè§ˆå™¨
   */
  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
      this.context = null;
      this.page = null;
      console.error('[BrowserManager] Browser closed');
    }
  }
}
```

#### **PageManagerï¼ˆé¡µé¢ç®¡ç†å™¨ï¼‰**

è´Ÿè´£é¡µé¢å¯¼èˆªå’ŒçŠ¶æ€ç®¡ç†ï¼š

```typescript
/**
 * é¡µé¢ç®¡ç†å™¨
 * ç®¡ç†é¡µé¢å¯¼èˆªã€ç½‘ç»œç›‘æ§ã€æ§åˆ¶å°æ¶ˆæ¯ç­‰
 */
class PageManager {
  private page: Page;
  private consoleMessages: ConsoleMessage[] = [];
  private networkRequests: Request[] = [];
  private dialogs: Dialog[] = [];

  constructor(page: Page) {
    this.page = page;
    this.setupListeners();
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬
   */
  private setupListeners(): void {
    // ç›‘å¬æ§åˆ¶å°æ¶ˆæ¯
    this.page.on('console', (msg) => {
      this.consoleMessages.push(msg);
      console.error(`[Console] ${msg.type()}: ${msg.text()}`);
    });

    // ç›‘å¬ç½‘ç»œè¯·æ±‚
    this.page.on('request', (request) => {
      this.networkRequests.push(request);
      console.error(`[Network] ${request.method()} ${request.url()}`);
    });

    // ç›‘å¬å¯¹è¯æ¡†
    this.page.on('dialog', (dialog) => {
      this.dialogs.push(dialog);
      console.error(`[Dialog] ${dialog.type()}: ${dialog.message()}`);
    });

    // ç›‘å¬é¡µé¢é”™è¯¯
    this.page.on('pageerror', (error) => {
      console.error('[PageError]', error);
    });
  }

  /**
   * å¯¼èˆªåˆ° URL
   */
  async navigate(url: string, options?: NavigationOptions): Promise<string> {
    try {
      console.error(`[PageManager] Navigating to: ${url}`);

      const response = await this.page.goto(url, {
        waitUntil: 'domcontentloaded',
        timeout: 30000,
        ...options
      });

      const status = response?.status() || 0;
      const finalUrl = this.page.url();

      return `Navigated to ${finalUrl} (Status: ${status})`;
    } catch (error) {
      throw new Error(`Navigation failed: ${error.message}`);
    }
  }

  /**
   * åé€€
   */
  async goBack(): Promise<string> {
    await this.page.goBack();
    return `Navigated back to ${this.page.url()}`;
  }

  /**
   * å‰è¿›
   */
  async goForward(): Promise<string> {
    await this.page.goForward();
    return `Navigated forward to ${this.page.url()}`;
  }

  /**
   * åˆ·æ–°é¡µé¢
   */
  async reload(): Promise<string> {
    await this.page.reload();
    return 'Page reloaded';
  }

  /**
   * ç­‰å¾…åŠ è½½å®Œæˆ
   */
  async waitForLoad(state: 'load' | 'domcontentloaded' | 'networkidle' = 'load'): Promise<void> {
    await this.page.waitForLoadState(state);
  }

  /**
   * è·å–æ§åˆ¶å°æ¶ˆæ¯
   */
  getConsoleMessages(onlyErrors = false): string {
    let messages = this.consoleMessages;

    if (onlyErrors) {
      messages = messages.filter(msg => msg.type() === 'error');
    }

    return messages
      .map(msg => `[${msg.type()}] ${msg.text()}`)
      .join('\n');
  }

  /**
   * è·å–ç½‘ç»œè¯·æ±‚
   */
  getNetworkRequests(): string {
    return this.networkRequests
      .map(req => `${req.method()} ${req.url()} -> ${req.response()?.status() || 'pending'}`)
      .join('\n');
  }

  /**
   * æ¸…ç©ºè®°å½•
   */
  clearRecords(): void {
    this.consoleMessages = [];
    this.networkRequests = [];
    this.dialogs = [];
  }
}
```

#### **ElementManagerï¼ˆå…ƒç´ ç®¡ç†å™¨ï¼‰**

è´Ÿè´£å…ƒç´ å®šä½å’Œäº¤äº’ï¼š

```typescript
/**
 * å…ƒç´ ç®¡ç†å™¨
 * è´Ÿè´£å…ƒç´ å®šä½ã€äº¤äº’å’Œæ“ä½œ
 */
class ElementManager {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * ç‚¹å‡»å…ƒç´ 
   */
  async click(selector: string, options?: ClickOptions): Promise<string> {
    try {
      // ç­‰å¾…å…ƒç´ å¯è§
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });

      // ç‚¹å‡»å…ƒç´ 
      await this.page.click(selector, {
        timeout: 5000,
        ...options
      });

      return `Clicked element: ${selector}`;
    } catch (error) {
      throw new Error(`Click failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * è¾“å…¥æ–‡æœ¬
   */
  async type(selector: string, text: string, options?: TypeOptions): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });

      // æ¸…ç©ºè¾“å…¥æ¡†
      await this.page.fill(selector, '');

      // è¾“å…¥æ–‡æœ¬
      if (options?.slowly) {
        await this.page.type(selector, text, { delay: 100 });
      } else {
        await this.page.fill(selector, text);
      }

      // æ˜¯å¦æäº¤ï¼ˆæŒ‰ Enterï¼‰
      if (options?.submit) {
        await this.page.press(selector, 'Enter');
      }

      return `Typed text into ${selector}`;
    } catch (error) {
      throw new Error(`Type failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * é€‰æ‹©ä¸‹æ‹‰é€‰é¡¹
   */
  async select(selector: string, values: string[]): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });
      await this.page.selectOption(selector, values);
      return `Selected options in ${selector}: ${values.join(', ')}`;
    } catch (error) {
      throw new Error(`Select failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * å‹¾é€‰/å–æ¶ˆå‹¾é€‰å¤é€‰æ¡†
   */
  async check(selector: string, checked: boolean): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });

      if (checked) {
        await this.page.check(selector);
      } else {
        await this.page.uncheck(selector);
      }

      return `${checked ? 'Checked' : 'Unchecked'} ${selector}`;
    } catch (error) {
      throw new Error(`Check failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * æ‚¬åœ
   */
  async hover(selector: string): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state: 'visible', timeout: 10000 });
      await this.page.hover(selector);
      return `Hovered over ${selector}`;
    } catch (error) {
      throw new Error(`Hover failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * æ‹–æ‹½
   */
  async drag(sourceSelector: string, targetSelector: string): Promise<string> {
    try {
      await this.page.waitForSelector(sourceSelector, { state: 'visible', timeout: 10000 });
      await this.page.waitForSelector(targetSelector, { state: 'visible', timeout: 10000 });

      const source = await this.page.locator(sourceSelector);
      const target = await this.page.locator(targetSelector);

      await source.dragTo(target);

      return `Dragged ${sourceSelector} to ${targetSelector}`;
    } catch (error) {
      throw new Error(`Drag failed: ${error.message}`);
    }
  }

  /**
   * ç­‰å¾…å…ƒç´ 
   */
  async waitFor(selector: string, state: 'visible' | 'hidden' | 'attached' = 'visible'): Promise<string> {
    try {
      await this.page.waitForSelector(selector, { state, timeout: 30000 });
      return `Element ${selector} is now ${state}`;
    } catch (error) {
      throw new Error(`Wait failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * è·å–å…ƒç´ æ–‡æœ¬
   */
  async getText(selector: string): Promise<string> {
    try {
      const element = await this.page.waitForSelector(selector, { timeout: 10000 });
      const text = await element.textContent();
      return text || '';
    } catch (error) {
      throw new Error(`Get text failed for ${selector}: ${error.message}`);
    }
  }

  /**
   * è·å–å…ƒç´ å±æ€§
   */
  async getAttribute(selector: string, attribute: string): Promise<string> {
    try {
      const element = await this.page.waitForSelector(selector, { timeout: 10000 });
      const value = await element.getAttribute(attribute);
      return value || '';
    } catch (error) {
      throw new Error(`Get attribute failed: ${error.message}`);
    }
  }
}
```

### 2.3 MCP Server å®ç°

å®Œæ•´çš„ Playwright MCP Server å®ç°ï¼š

```typescript
import { Browser, BrowserContext, Page } from 'playwright';
import { chromium } from 'playwright';

/**
 * Playwright MCP Server
 * æä¾›æµè§ˆå™¨è‡ªåŠ¨åŒ–èƒ½åŠ›
 */
class PlaywrightMCPServer {
  private browserManager: BrowserManager;
  private pageManager: PageManager | null = null;
  private elementManager: ElementManager | null = null;
  private tools: Map<string, any> = new Map();

  constructor() {
    this.browserManager = new BrowserManager();
    this.registerTools();
  }

  /**
   * æ³¨å†Œæ‰€æœ‰å·¥å…·
   */
  private registerTools(): void {
    // æµè§ˆå™¨æ§åˆ¶å·¥å…·
    this.registerTool({
      name: 'browser_navigate',
      description: 'Navigate to a URL',
      inputSchema: {
        type: 'object',
        properties: {
          url: {
            type: 'string',
            description: 'The URL to navigate to'
          }
        },
        required: ['url']
      }
    }, this.handleNavigate.bind(this));

    this.registerTool({
      name: 'browser_snapshot',
      description: 'Capture accessibility snapshot of the current page. This returns the DOM structure which is better than a screenshot for understanding page content.',
      inputSchema: {
        type: 'object',
        properties: {}
      }
    }, this.handleSnapshot.bind(this));

    this.registerTool({
      name: 'browser_click',
      description: 'Click on an element',
      inputSchema: {
        type: 'object',
        properties: {
          element: {
            type: 'string',
            description: 'Human-readable element description'
          },
          ref: {
            type: 'string',
            description: 'Element reference from snapshot'
          }
        },
        required: ['element', 'ref']
      }
    }, this.handleClick.bind(this));

    this.registerTool({
      name: 'browser_type',
      description: 'Type text into an editable element',
      inputSchema: {
        type: 'object',
        properties: {
          element: {
            type: 'string',
            description: 'Human-readable element description'
          },
          ref: {
            type: 'string',
            description: 'Element reference from snapshot'
          },
          text: {
            type: 'string',
            description: 'Text to type'
          },
          submit: {
            type: 'boolean',
            description: 'Press Enter after typing'
          }
        },
        required: ['element', 'ref', 'text']
      }
    }, this.handleType.bind(this));

    this.registerTool({
      name: 'browser_select_option',
      description: 'Select an option in a dropdown',
      inputSchema: {
        type: 'object',
        properties: {
          element: {
            type: 'string',
            description: 'Human-readable element description'
          },
          ref: {
            type: 'string',
            description: 'Element reference from snapshot'
          },
          values: {
            type: 'array',
            items: { type: 'string' },
            description: 'Values to select'
          }
        },
        required: ['element', 'ref', 'values']
      }
    }, this.handleSelectOption.bind(this));

    this.registerTool({
      name: 'browser_take_screenshot',
      description: 'Take a screenshot of the current page',
      inputSchema: {
        type: 'object',
        properties: {
          filename: {
            type: 'string',
            description: 'Filename for the screenshot'
          },
          fullPage: {
            type: 'boolean',
            description: 'Take full page screenshot'
          }
        }
      }
    }, this.handleScreenshot.bind(this));

    this.registerTool({
      name: 'browser_console_messages',
      description: 'Get all console messages from the page',
      inputSchema: {
        type: 'object',
        properties: {
          onlyErrors: {
            type: 'boolean',
            description: 'Only return error messages'
          }
        }
      }
    }, this.handleConsoleMessages.bind(this));

    this.registerTool({
      name: 'browser_network_requests',
      description: 'Get all network requests since loading the page',
      inputSchema: {
        type: 'object',
        properties: {}
      }
    }, this.handleNetworkRequests.bind(this));

    this.registerTool({
      name: 'browser_evaluate',
      description: 'Execute JavaScript code in the page context',
      inputSchema: {
        type: 'object',
        properties: {
          function: {
            type: 'string',
            description: 'JavaScript function to execute'
          }
        },
        required: ['function']
      }
    }, this.handleEvaluate.bind(this));

    this.registerTool({
      name: 'browser_close',
      description: 'Close the browser',
      inputSchema: {
        type: 'object',
        properties: {}
      }
    }, this.handleClose.bind(this));

    console.error(`[Playwright MCP] Registered ${this.tools.size} tools`);
  }

  /**
   * æ³¨å†Œå·¥å…·
   */
  private registerTool(tool: any, handler: (params: any) => Promise<string>): void {
    this.tools.set(tool.name, { tool, handler });
  }

  /**
   * ç¡®ä¿æµè§ˆå™¨å·²å¯åŠ¨
   */
  private async ensureBrowser(): Promise<void> {
    if (!this.browserManager.getPage) {
      await this.browserManager.launch();
      const page = this.browserManager.getPage();
      this.pageManager = new PageManager(page);
      this.elementManager = new ElementManager(page);
    }
  }

  // ========== å·¥å…·å¤„ç†å‡½æ•° ==========

  async handleNavigate(params: { url: string }): Promise<string> {
    await this.ensureBrowser();
    return await this.pageManager!.navigate(params.url);
  }

  async handleSnapshot(params: {}): Promise<string> {
    await this.ensureBrowser();
    const page = this.browserManager.getPage();

    // è·å– accessibility tree
    const snapshot = await page.accessibility.snapshot();

    // æ ¼å¼åŒ–è¾“å‡º
    return this.formatAccessibilityTree(snapshot);
  }

  private formatAccessibilityTree(node: any, indent = 0): string {
    if (!node) return '';

    const spaces = '  '.repeat(indent);
    let output = `${spaces}[${node.role}]`;

    if (node.name) {
      output += ` ${node.name}`;
    }

    if (node.value) {
      output += ` (value: ${node.value})`;
    }

    output += '\n';

    if (node.children) {
      for (const child of node.children) {
        output += this.formatAccessibilityTree(child, indent + 1);
      }
    }

    return output;
  }

  async handleClick(params: { element: string; ref: string }): Promise<string> {
    await this.ensureBrowser();
    return await this.elementManager!.click(params.ref);
  }

  async handleType(params: { element: string; ref: string; text: string; submit?: boolean }): Promise<string> {
    await this.ensureBrowser();
    return await this.elementManager!.type(params.ref, params.text, { submit: params.submit });
  }

  async handleSelectOption(params: { element: string; ref: string; values: string[] }): Promise<string> {
    await this.ensureBrowser();
    return await this.elementManager!.select(params.ref, params.values);
  }

  async handleScreenshot(params: { filename?: string; fullPage?: boolean }): Promise<string> {
    await this.ensureBrowser();
    const page = this.browserManager.getPage();

    const filename = params.filename || `screenshot-${Date.now()}.png`;

    await page.screenshot({
      path: filename,
      fullPage: params.fullPage || false
    });

    return `Screenshot saved to ${filename}`;
  }

  async handleConsoleMessages(params: { onlyErrors?: boolean }): Promise<string> {
    await this.ensureBrowser();
    return this.pageManager!.getConsoleMessages(params.onlyErrors);
  }

  async handleNetworkRequests(params: {}): Promise<string> {
    await this.ensureBrowser();
    return this.pageManager!.getNetworkRequests();
  }

  async handleEvaluate(params: { function: string }): Promise<string> {
    await this.ensureBrowser();
    const page = this.browserManager.getPage();

    try {
      const result = await page.evaluate(params.function);
      return JSON.stringify(result, null, 2);
    } catch (error) {
      throw new Error(`Evaluate failed: ${error.message}`);
    }
  }

  async handleClose(params: {}): Promise<string> {
    await this.browserManager.close();
    this.pageManager = null;
    this.elementManager = null;
    return 'Browser closed';
  }

  // ========== MCP åè®®å¤„ç† ==========

  async handleToolsList(): Promise<{ tools: any[] }> {
    const tools = Array.from(this.tools.values()).map(t => t.tool);
    return { tools };
  }

  async handleToolCall(params: { name: string; arguments: any }): Promise<any> {
    const toolEntry = this.tools.get(params.name);

    if (!toolEntry) {
      throw new Error(`Tool not found: ${params.name}`);
    }

    try {
      const result = await toolEntry.handler(params.arguments);

      return {
        content: [
          {
            type: 'text',
            text: result
          }
        ],
        isError: false
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `Error: ${error.message}`
          }
        ],
        isError: true
      };
    }
  }

  async start(): Promise<void> {
    // å®ç° MCP Server å¯åŠ¨é€»è¾‘
    // ï¼ˆä¸å‰æ–‡ Git MCP Server ç±»ä¼¼ï¼‰
    console.error('[Playwright MCP] Server started');
  }
}

// å¯¼å‡º
export { PlaywrightMCPServer };
```

---

## ä¸‰ã€é¡µé¢å¿«ç…§å’Œ DOM è§£æ

### 3.1 Accessibility Tree ä»‹ç»

Accessibility Treeï¼ˆæ— éšœç¢æ ‘ï¼‰æ˜¯æµè§ˆå™¨ä¸ºè¾…åŠ©æŠ€æœ¯ï¼ˆå¦‚å±å¹•é˜…è¯»å™¨ï¼‰æä¾›çš„ DOM ç»“æ„è¡¨ç¤ºã€‚å®ƒæ¯”åŸå§‹ DOM æ›´ç®€æ´ï¼ŒåªåŒ…å«æœ‰æ„ä¹‰çš„å…ƒç´ å’Œä¿¡æ¯ã€‚

```mermaid
graph TB
    A[åŸå§‹ DOM] --> B[Accessibility Tree]

    subgraph "åŸå§‹ DOMï¼ˆå¤æ‚ï¼‰"
        C[div] --> D[span]
        C --> E[div]
        E --> F[input]
        E --> G[label]
    end

    subgraph "Accessibility Treeï¼ˆç®€æ´ï¼‰"
        H[group] --> I[textbox 'Username']
    end

    style B fill:#e1ffe1
```

**ä¸ºä»€ä¹ˆä½¿ç”¨ Accessibility Treeï¼Ÿ**

1. âœ… **ç»“æ„æ¸…æ™°**ï¼šè¿‡æ»¤æ‰æ— æ„ä¹‰çš„ DOM èŠ‚ç‚¹
2. âœ… **è¯­ä¹‰ä¸°å¯Œ**ï¼šåŒ…å«å…ƒç´ çš„è§’è‰²ï¼ˆroleï¼‰å’Œåç§°ï¼ˆnameï¼‰
3. âœ… **ä½“ç§¯å°**ï¼šç›¸æ¯”å®Œæ•´ DOMï¼Œæ•°æ®é‡å°å¾—å¤š
4. âœ… **AI å‹å¥½**ï¼šæ˜“äº AI ç†è§£é¡µé¢ç»“æ„

### 3.2 è·å– Accessibility Tree

```typescript
/**
 * è·å–é¡µé¢çš„ Accessibility Tree
 */
async function captureAccessibilitySnapshot(page: Page): Promise<string> {
  // è·å–å¿«ç…§
  const snapshot = await page.accessibility.snapshot();

  // æ ¼å¼åŒ–è¾“å‡º
  return formatSnapshot(snapshot);
}

/**
 * æ ¼å¼åŒ– Accessibility Tree
 */
function formatSnapshot(node: any, indent = 0, index = 0): string {
  if (!node) return '';

  const spaces = '  '.repeat(indent);
  const prefix = index > 0 ? `[${index}] ` : '';

  let output = `${spaces}${prefix}`;

  // èŠ‚ç‚¹è§’è‰²
  output += `<${node.role}>`;

  // èŠ‚ç‚¹åç§°
  if (node.name) {
    output += ` "${node.name}"`;
  }

  // èŠ‚ç‚¹å€¼
  if (node.value) {
    output += ` = "${node.value}"`;
  }

  // èŠ‚ç‚¹çŠ¶æ€
  if (node.checked !== undefined) {
    output += ` [${node.checked ? 'checked' : 'unchecked'}]`;
  }

  if (node.disabled) {
    output += ' [disabled]';
  }

  if (node.focused) {
    output += ' [focused]';
  }

  output += '\n';

  // é€’å½’å¤„ç†å­èŠ‚ç‚¹
  if (node.children && node.children.length > 0) {
    node.children.forEach((child: any, idx: number) => {
      output += formatSnapshot(child, indent + 1, idx + 1);
    });
  }

  return output;
}
```

**è¾“å‡ºç¤ºä¾‹**ï¼š

```
<WebArea> "Login Page"
  [1] <main>
    [1] <heading> "Welcome Back"
    [2] <form>
      [1] <group> "Username"
        [1] <textbox> "Username" = ""
      [2] <group> "Password"
        [1] <textbox> "Password" = "" [password]
      [3] <checkbox> "Remember me" [unchecked]
      [4] <button> "Log In"
    [3] <link> "Forgot password?"
```

### 3.3 å…ƒç´ å®šä½ç­–ç•¥

åŸºäº Accessibility Treeï¼ŒClaude Code ä½¿ç”¨ä»¥ä¸‹ç­–ç•¥å®šä½å…ƒç´ ï¼š

```mermaid
graph TB
    A[å…ƒç´ å®šä½ç­–ç•¥] --> B[1. Role + Name]
    A --> C[2. Text Content]
    A --> D[3. ARIA Attributes]
    A --> E[4. CSS Selector]

    B --> B1["button[name='Submit']"]
    C --> C1["text='Click here'"]
    D --> D1["[aria-label='Close']"]
    E --> E1["#login-button"]

    style A fill:#e1f5ff
```

**å®šä½å‡½æ•°å®ç°**ï¼š

```typescript
/**
 * æ™ºèƒ½å…ƒç´ å®šä½
 * æ ¹æ®å…ƒç´ æè¿°å’Œ Accessibility Tree å®šä½å…ƒç´ 
 */
class SmartLocator {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * æ ¹æ®è§’è‰²å’Œåç§°å®šä½
   */
  async locateByRoleAndName(role: string, name: string) {
    return this.page.getByRole(role as any, { name });
  }

  /**
   * æ ¹æ®æ–‡æœ¬å†…å®¹å®šä½
   */
  async locateByText(text: string, exact = false) {
    return this.page.getByText(text, { exact });
  }

  /**
   * æ ¹æ®æ ‡ç­¾å®šä½
   */
  async locateByLabel(label: string) {
    return this.page.getByLabel(label);
  }

  /**
   * æ ¹æ®å ä½ç¬¦å®šä½
   */
  async locateByPlaceholder(placeholder: string) {
    return this.page.getByPlaceholder(placeholder);
  }

  /**
   * æ ¹æ® CSS é€‰æ‹©å™¨å®šä½
   */
  async locateBySelector(selector: string) {
    return this.page.locator(selector);
  }

  /**
   * æ™ºèƒ½å®šä½ï¼ˆå°è¯•å¤šç§ç­–ç•¥ï¼‰
   */
  async smartLocate(description: string): Promise<Locator> {
    // ç­–ç•¥ 1ï¼šå°è¯•æŒ‰é’®è§’è‰²
    if (description.toLowerCase().includes('button')) {
      try {
        return await this.locateByRoleAndName('button', description);
      } catch {}
    }

    // ç­–ç•¥ 2ï¼šå°è¯•æ–‡æœ¬åŒ¹é…
    try {
      return await this.locateByText(description);
    } catch {}

    // ç­–ç•¥ 3ï¼šå°è¯•æ ‡ç­¾åŒ¹é…
    try {
      return await this.locateByLabel(description);
    } catch {}

    // ç­–ç•¥ 4ï¼šä½œä¸º CSS é€‰æ‹©å™¨
    return await this.locateBySelector(description);
  }
}
```

---

## å››ã€å…ƒç´ äº¤äº’æ“ä½œ

### 4.1 ç‚¹å‡»æ“ä½œ

```typescript
/**
 * ç‚¹å‡»æ“ä½œçš„å®Œæ•´å®ç°
 */
class ClickHandler {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * æ™®é€šç‚¹å‡»
   */
  async click(selector: string): Promise<void> {
    await this.page.click(selector, {
      timeout: 5000,
      force: false  // ä¸å¼ºåˆ¶ç‚¹å‡»ï¼ˆç¡®ä¿å…ƒç´ å¯ç‚¹å‡»ï¼‰
    });
  }

  /**
   * åŒå‡»
   */
  async doubleClick(selector: string): Promise<void> {
    await this.page.dblclick(selector);
  }

  /**
   * å³é”®ç‚¹å‡»
   */
  async rightClick(selector: string): Promise<void> {
    await this.page.click(selector, { button: 'right' });
  }

  /**
   * å¸¦ä¿®é¥°é”®çš„ç‚¹å‡»
   */
  async clickWithModifier(
    selector: string,
    modifiers: ('Alt' | 'Control' | 'Meta' | 'Shift')[]
  ): Promise<void> {
    await this.page.click(selector, { modifiers });
  }

  /**
   * ç‚¹å‡»å¹¶ç­‰å¾…å¯¼èˆª
   */
  async clickAndWaitForNavigation(selector: string): Promise<void> {
    await Promise.all([
      this.page.waitForNavigation(),
      this.page.click(selector)
    ]);
  }

  /**
   * ç‚¹å‡»å¹¶ç­‰å¾…è¯·æ±‚
   */
  async clickAndWaitForRequest(
    selector: string,
    urlPattern: string | RegExp
  ): Promise<Request> {
    const [request] = await Promise.all([
      this.page.waitForRequest(urlPattern),
      this.page.click(selector)
    ]);
    return request;
  }

  /**
   * ç‚¹å‡»å¹¶ç­‰å¾…å“åº”
   */
  async clickAndWaitForResponse(
    selector: string,
    urlPattern: string | RegExp
  ): Promise<Response> {
    const [response] = await Promise.all([
      this.page.waitForResponse(urlPattern),
      this.page.click(selector)
    ]);
    return response;
  }
}
```

### 4.2 è¾“å…¥æ“ä½œ

```typescript
/**
 * è¾“å…¥æ“ä½œçš„å®Œæ•´å®ç°
 */
class InputHandler {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * å¿«é€Ÿå¡«å……ï¼ˆæ¨èï¼‰
   */
  async fill(selector: string, value: string): Promise<void> {
    // æ¸…ç©ºå¹¶å¡«å……
    await this.page.fill(selector, value);
  }

  /**
   * é€å­—ç¬¦è¾“å…¥ï¼ˆæ¨¡æ‹ŸçœŸå®è¾“å…¥ï¼‰
   */
  async type(selector: string, text: string, delay = 100): Promise<void> {
    // å…ˆæ¸…ç©º
    await this.page.fill(selector, '');

    // é€å­—ç¬¦è¾“å…¥
    await this.page.type(selector, text, { delay });
  }

  /**
   * æŒ‰é”®æ“ä½œ
   */
  async press(selector: string, key: string): Promise<void> {
    await this.page.press(selector, key);
  }

  /**
   * ç»„åˆé”®
   */
  async pressSequence(selector: string, keys: string[]): Promise<void> {
    for (const key of keys) {
      await this.page.press(selector, key);
    }
  }

  /**
   * æ¸…ç©ºè¾“å…¥æ¡†
   */
  async clear(selector: string): Promise<void> {
    await this.page.fill(selector, '');
  }

  /**
   * è¾“å…¥å¹¶æäº¤ï¼ˆæŒ‰ Enterï¼‰
   */
  async typeAndSubmit(selector: string, text: string): Promise<void> {
    await this.fill(selector, text);
    await this.press(selector, 'Enter');
  }

  /**
   * æ–‡ä»¶ä¸Šä¼ 
   */
  async uploadFile(selector: string, filePaths: string | string[]): Promise<void> {
    const paths = Array.isArray(filePaths) ? filePaths : [filePaths];
    await this.page.setInputFiles(selector, paths);
  }

  /**
   * æ¸…é™¤æ–‡ä»¶ä¸Šä¼ 
   */
  async clearFiles(selector: string): Promise<void> {
    await this.page.setInputFiles(selector, []);
  }
}
```

### 4.3 è¡¨å•æ“ä½œ

```typescript
/**
 * è¡¨å•æ“ä½œçš„å®Œæ•´å®ç°
 */
class FormHandler {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * å‹¾é€‰å¤é€‰æ¡†
   */
  async check(selector: string): Promise<void> {
    await this.page.check(selector);
  }

  /**
   * å–æ¶ˆå‹¾é€‰å¤é€‰æ¡†
   */
  async uncheck(selector: string): Promise<void> {
    await this.page.uncheck(selector);
  }

  /**
   * è®¾ç½®å¤é€‰æ¡†çŠ¶æ€
   */
  async setChecked(selector: string, checked: boolean): Promise<void> {
    if (checked) {
      await this.check(selector);
    } else {
      await this.uncheck(selector);
    }
  }

  /**
   * é€‰æ‹©å•é€‰æŒ‰é’®
   */
  async selectRadio(name: string, value: string): Promise<void> {
    await this.page.check(`input[type="radio"][name="${name}"][value="${value}"]`);
  }

  /**
   * é€‰æ‹©ä¸‹æ‹‰é€‰é¡¹ï¼ˆå•é€‰ï¼‰
   */
  async selectOption(selector: string, value: string): Promise<void> {
    await this.page.selectOption(selector, value);
  }

  /**
   * é€‰æ‹©ä¸‹æ‹‰é€‰é¡¹ï¼ˆå¤šé€‰ï¼‰
   */
  async selectMultipleOptions(selector: string, values: string[]): Promise<void> {
    await this.page.selectOption(selector, values);
  }

  /**
   * å¡«å……æ•´ä¸ªè¡¨å•
   */
  async fillForm(formData: Record<string, any>): Promise<void> {
    for (const [key, value] of Object.entries(formData)) {
      if (typeof value === 'boolean') {
        // å¤é€‰æ¡†
        await this.setChecked(`[name="${key}"]`, value);
      } else if (Array.isArray(value)) {
        // å¤šé€‰ä¸‹æ‹‰
        await this.selectMultipleOptions(`[name="${key}"]`, value);
      } else {
        // æ™®é€šè¾“å…¥
        await this.page.fill(`[name="${key}"]`, String(value));
      }
    }
  }

  /**
   * æäº¤è¡¨å•
   */
  async submit(formSelector: string): Promise<void> {
    await this.page.evaluate((selector) => {
      const form = document.querySelector(selector) as HTMLFormElement;
      if (form) {
        form.submit();
      }
    }, formSelector);
  }

  /**
   * è·å–è¡¨å•æ•°æ®
   */
  async getFormData(formSelector: string): Promise<Record<string, any>> {
    return await this.page.evaluate((selector) => {
      const form = document.querySelector(selector) as HTMLFormElement;
      if (!form) return {};

      const formData = new FormData(form);
      const data: Record<string, any> = {};

      for (const [key, value] of formData.entries()) {
        data[key] = value;
      }

      return data;
    }, formSelector);
  }
}
```

---

## äº”ã€ç½‘ç»œè¯·æ±‚ç›‘æ§å’Œæ‹¦æˆª

### 5.1 è¯·æ±‚ç›‘æ§

```typescript
/**
 * ç½‘ç»œè¯·æ±‚ç›‘æ§å™¨
 */
class NetworkMonitor {
  private page: Page;
  private requests: Request[] = [];
  private responses: Response[] = [];
  private failedRequests: Request[] = [];

  constructor(page: Page) {
    this.page = page;
    this.setupListeners();
  }

  /**
   * è®¾ç½®ç›‘å¬å™¨
   */
  private setupListeners(): void {
    // ç›‘å¬è¯·æ±‚
    this.page.on('request', (request) => {
      this.requests.push(request);
      console.error(`[Request] ${request.method()} ${request.url()}`);
    });

    // ç›‘å¬å“åº”
    this.page.on('response', (response) => {
      this.responses.push(response);
      const status = response.status();
      const statusText = status >= 400 ? 'âŒ' : 'âœ…';
      console.error(`[Response] ${statusText} ${status} ${response.url()}`);
    });

    // ç›‘å¬å¤±è´¥çš„è¯·æ±‚
    this.page.on('requestfailed', (request) => {
      this.failedRequests.push(request);
      console.error(`[RequestFailed] ${request.url()}: ${request.failure()?.errorText}`);
    });
  }

  /**
   * è·å–æ‰€æœ‰è¯·æ±‚
   */
  getAllRequests(): Request[] {
    return this.requests;
  }

  /**
   * æŒ‰ URL æ¨¡å¼è¿‡æ»¤è¯·æ±‚
   */
  filterRequestsByUrl(pattern: string | RegExp): Request[] {
    const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;
    return this.requests.filter(req => regex.test(req.url()));
  }

  /**
   * æŒ‰æ–¹æ³•è¿‡æ»¤è¯·æ±‚
   */
  filterRequestsByMethod(method: string): Request[] {
    return this.requests.filter(req => req.method() === method.toUpperCase());
  }

  /**
   * è·å– API è¯·æ±‚
   */
  getApiRequests(): Request[] {
    return this.requests.filter(req => {
      const url = req.url();
      return url.includes('/api/') ||
             req.resourceType() === 'xhr' ||
             req.resourceType() === 'fetch';
    });
  }

  /**
   * è·å–å¤±è´¥çš„è¯·æ±‚
   */
  getFailedRequests(): Request[] {
    return this.failedRequests;
  }

  /**
   * ç”Ÿæˆè¯·æ±‚æŠ¥å‘Š
   */
  generateReport(): string {
    let report = '=== Network Request Report ===\n\n';

    report += `Total Requests: ${this.requests.length}\n`;
    report += `Total Responses: ${this.responses.length}\n`;
    report += `Failed Requests: ${this.failedRequests.length}\n\n`;

    // æŒ‰ç±»å‹ç»Ÿè®¡
    const byType = new Map<string, number>();
    this.requests.forEach(req => {
      const type = req.resourceType();
      byType.set(type, (byType.get(type) || 0) + 1);
    });

    report += '--- Requests by Type ---\n';
    for (const [type, count] of byType.entries()) {
      report += `${type}: ${count}\n`;
    }

    report += '\n--- Failed Requests ---\n';
    this.failedRequests.forEach(req => {
      report += `${req.method()} ${req.url()}\n`;
      report += `  Error: ${req.failure()?.errorText}\n`;
    });

    return report;
  }

  /**
   * æ¸…ç©ºè®°å½•
   */
  clear(): void {
    this.requests = [];
    this.responses = [];
    this.failedRequests = [];
  }
}
```

### 5.2 è¯·æ±‚æ‹¦æˆª

```typescript
/**
 * è¯·æ±‚æ‹¦æˆªå™¨
 */
class RequestInterceptor {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * å¯ç”¨è·¯ç”±
   */
  async enableRouting(): Promise<void> {
    await this.page.route('**/*', (route) => {
      // é»˜è®¤ç»§ç»­è¯·æ±‚
      route.continue();
    });
  }

  /**
   * é˜»æ­¢ç‰¹å®šèµ„æºåŠ è½½
   */
  async blockResourceTypes(types: string[]): Promise<void> {
    await this.page.route('**/*', (route) => {
      if (types.includes(route.request().resourceType())) {
        route.abort();
      } else {
        route.continue();
      }
    });
  }

  /**
   * é˜»æ­¢å›¾ç‰‡å’Œæ ·å¼ï¼ˆåŠ é€Ÿé¡µé¢åŠ è½½ï¼‰
   */
  async blockAssetsForSpeed(): Promise<void> {
    await this.blockResourceTypes(['image', 'stylesheet', 'font']);
  }

  /**
   * é˜»æ­¢ç¬¬ä¸‰æ–¹è„šæœ¬
   */
  async blockThirdPartyScripts(): Promise<void> {
    await this.page.route('**/*', (route) => {
      const url = route.request().url();
      const isThirdParty = !url.includes(this.page.url());
      const isScript = route.request().resourceType() === 'script';

      if (isThirdParty && isScript) {
        route.abort();
      } else {
        route.continue();
      }
    });
  }

  /**
   * ä¿®æ”¹è¯·æ±‚å¤´
   */
  async modifyHeaders(headers: Record<string, string>): Promise<void> {
    await this.page.route('**/*', (route) => {
      route.continue({
        headers: {
          ...route.request().headers(),
          ...headers
        }
      });
    });
  }

  /**
   * Mock API å“åº”
   */
  async mockApiResponse(
    urlPattern: string | RegExp,
    responseData: any
  ): Promise<void> {
    await this.page.route(urlPattern, (route) => {
      route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(responseData)
      });
    });
  }

  /**
   * é‡å®šå‘è¯·æ±‚
   */
  async redirectRequest(
    fromPattern: string | RegExp,
    toUrl: string
  ): Promise<void> {
    await this.page.route(fromPattern, (route) => {
      route.continue({ url: toUrl });
    });
  }

  /**
   * è®°å½•å¹¶ç»§ç»­
   */
  async logAndContinue(): Promise<void> {
    await this.page.route('**/*', (route) => {
      const request = route.request();
      console.error(`[Intercept] ${request.method()} ${request.url()}`);
      route.continue();
    });
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
// åˆ›å»ºæ‹¦æˆªå™¨
const interceptor = new RequestInterceptor(page);

// é˜»æ­¢å›¾ç‰‡åŠ è½½ä»¥åŠ é€Ÿ
await interceptor.blockResourceTypes(['image']);

// Mock API å“åº”
await interceptor.mockApiResponse(/\/api\/users/, {
  users: [
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' }
  ]
});

// æ·»åŠ è‡ªå®šä¹‰è¯·æ±‚å¤´
await interceptor.modifyHeaders({
  'X-Custom-Header': 'test-value',
  'Authorization': 'Bearer test-token'
});
```

---

## å…­ã€æˆªå›¾å’Œ PDF ç”Ÿæˆ

### 6.1 æˆªå›¾åŠŸèƒ½

```typescript
/**
 * æˆªå›¾å·¥å…·
 */
class ScreenshotTool {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * åŸºç¡€æˆªå›¾
   */
  async takeScreenshot(path: string): Promise<void> {
    await this.page.screenshot({ path });
  }

  /**
   * å…¨é¡µæˆªå›¾
   */
  async takeFullPageScreenshot(path: string): Promise<void> {
    await this.page.screenshot({
      path,
      fullPage: true
    });
  }

  /**
   * å…ƒç´ æˆªå›¾
   */
  async takeElementScreenshot(selector: string, path: string): Promise<void> {
    const element = await this.page.locator(selector);
    await element.screenshot({ path });
  }

  /**
   * æŒ‡å®šåŒºåŸŸæˆªå›¾
   */
  async takeClipScreenshot(
    path: string,
    clip: { x: number; y: number; width: number; height: number }
  ): Promise<void> {
    await this.page.screenshot({
      path,
      clip
    });
  }

  /**
   * æˆªå›¾ä¸º Bufferï¼ˆç”¨äºè¿›ä¸€æ­¥å¤„ç†ï¼‰
   */
  async screenshotToBuffer(): Promise<Buffer> {
    return await this.page.screenshot({ type: 'png' });
  }

  /**
   * æˆªå›¾ä¸º Base64
   */
  async screenshotToBase64(): Promise<string> {
    const buffer = await this.screenshotToBuffer();
    return buffer.toString('base64');
  }

  /**
   * éšè—å…ƒç´ åæˆªå›¾
   */
  async screenshotWithHiddenElements(
    path: string,
    hideSelectors: string[]
  ): Promise<void> {
    // éšè—å…ƒç´ 
    await this.page.evaluate((selectors) => {
      selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          (el as HTMLElement).style.visibility = 'hidden';
        });
      });
    }, hideSelectors);

    // æˆªå›¾
    await this.page.screenshot({ path });

    // æ¢å¤å…ƒç´ 
    await this.page.evaluate((selectors) => {
      selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          (el as HTMLElement).style.visibility = 'visible';
        });
      });
    }, hideSelectors);
  }

  /**
   * è‡ªåŠ¨ç­‰å¾…å¹¶æˆªå›¾
   */
  async screenshotWhenStable(path: string, maxWait = 5000): Promise<void> {
    // ç­‰å¾…ç½‘ç»œç©ºé—²
    await this.page.waitForLoadState('networkidle', { timeout: maxWait });

    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿åŠ¨ç”»å®Œæˆ
    await this.page.waitForTimeout(500);

    // æˆªå›¾
    await this.page.screenshot({ path });
  }
}
```

### 6.2 PDF ç”Ÿæˆ

```typescript
/**
 * PDF ç”Ÿæˆå·¥å…·
 */
class PdfGenerator {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * åŸºç¡€ PDF ç”Ÿæˆ
   */
  async generatePdf(path: string): Promise<void> {
    await this.page.pdf({ path });
  }

  /**
   * è‡ªå®šä¹‰æ ¼å¼ PDF
   */
  async generateCustomPdf(
    path: string,
    options: {
      format?: 'A4' | 'Letter' | 'Legal';
      landscape?: boolean;
      printBackground?: boolean;
      margin?: {
        top?: string;
        right?: string;
        bottom?: string;
        left?: string;
      };
    } = {}
  ): Promise<void> {
    await this.page.pdf({
      path,
      format: options.format || 'A4',
      landscape: options.landscape || false,
      printBackground: options.printBackground !== false,
      margin: options.margin || {
        top: '1cm',
        right: '1cm',
        bottom: '1cm',
        left: '1cm'
      }
    });
  }

  /**
   * å¤šé¡µ PDF
   */
  async generateMultiPagePdf(
    urls: string[],
    outputPath: string
  ): Promise<void> {
    const PDFDocument = require('pdf-lib').PDFDocument;
    const mergedPdf = await PDFDocument.create();

    for (const url of urls) {
      // å¯¼èˆªåˆ°é¡µé¢
      await this.page.goto(url);

      // ç”Ÿæˆä¸´æ—¶ PDF
      const pdfBuffer = await this.page.pdf();

      // åŠ è½½ PDF
      const pdf = await PDFDocument.load(pdfBuffer);
      const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());

      // æ·»åŠ é¡µé¢
      copiedPages.forEach((page) => {
        mergedPdf.addPage(page);
      });
    }

    // ä¿å­˜åˆå¹¶åçš„ PDF
    const mergedPdfBytes = await mergedPdf.save();
    require('fs').writeFileSync(outputPath, mergedPdfBytes);
  }

  /**
   * å¸¦é¡µçœ‰é¡µè„šçš„ PDF
   */
  async generatePdfWithHeaderFooter(
    path: string,
    options: {
      headerTemplate?: string;
      footerTemplate?: string;
      displayHeaderFooter?: boolean;
    } = {}
  ): Promise<void> {
    await this.page.pdf({
      path,
      format: 'A4',
      displayHeaderFooter: options.displayHeaderFooter !== false,
      headerTemplate: options.headerTemplate || '<div></div>',
      footerTemplate: options.footerTemplate || `
        <div style="font-size: 10px; text-align: center; width: 100%;">
          Page <span class="pageNumber"></span> of <span class="totalPages"></span>
        </div>
      `,
      margin: {
        top: '2cm',
        bottom: '2cm'
      }
    });
  }
}
```

---

## ä¸ƒã€è‡ªåŠ¨åŒ–æµ‹è¯•åœºæ™¯

### 7.1 ç«¯åˆ°ç«¯æµ‹è¯•æ¡†æ¶

```typescript
/**
 * ç«¯åˆ°ç«¯æµ‹è¯•æ¡†æ¶
 */
class E2ETestFramework {
  private page: Page;
  private testResults: TestResult[] = [];

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * è¿è¡Œæµ‹è¯•å¥—ä»¶
   */
  async runTestSuite(tests: Test[]): Promise<TestSuiteResult> {
    console.log(`Running ${tests.length} tests...`);

    const results: TestResult[] = [];
    let passed = 0;
    let failed = 0;

    for (const test of tests) {
      const result = await this.runTest(test);
      results.push(result);

      if (result.passed) {
        passed++;
      } else {
        failed++;
      }
    }

    return {
      total: tests.length,
      passed,
      failed,
      results
    };
  }

  /**
   * è¿è¡Œå•ä¸ªæµ‹è¯•
   */
  private async runTest(test: Test): Promise<TestResult> {
    const startTime = Date.now();

    try {
      console.log(`  Running: ${test.name}`);

      // æ‰§è¡Œæµ‹è¯•
      await test.fn(this.page);

      const duration = Date.now() - startTime;
      console.log(`  âœ… PASSED (${duration}ms)`);

      return {
        name: test.name,
        passed: true,
        duration,
        error: null
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      console.log(`  âŒ FAILED (${duration}ms)`);
      console.log(`     ${error.message}`);

      return {
        name: test.name,
        passed: false,
        duration,
        error: error.message
      };
    }
  }

  /**
   * æ–­è¨€ï¼šå…ƒç´ å¯è§
   */
  async assertVisible(selector: string, message?: string): Promise<void> {
    const element = await this.page.locator(selector);
    const isVisible = await element.isVisible();

    if (!isVisible) {
      throw new Error(message || `Element not visible: ${selector}`);
    }
  }

  /**
   * æ–­è¨€ï¼šå…ƒç´ ä¸å¯è§
   */
  async assertHidden(selector: string, message?: string): Promise<void> {
    const element = await this.page.locator(selector);
    const isHidden = await element.isHidden();

    if (!isHidden) {
      throw new Error(message || `Element should be hidden: ${selector}`);
    }
  }

  /**
   * æ–­è¨€ï¼šæ–‡æœ¬å†…å®¹
   */
  async assertText(selector: string, expectedText: string): Promise<void> {
    const element = await this.page.locator(selector);
    const actualText = await element.textContent();

    if (actualText?.trim() !== expectedText.trim()) {
      throw new Error(`Text mismatch: expected "${expectedText}", got "${actualText}"`);
    }
  }

  /**
   * æ–­è¨€ï¼šURL
   */
  async assertUrl(expectedUrl: string): Promise<void> {
    const actualUrl = this.page.url();

    if (!actualUrl.includes(expectedUrl)) {
      throw new Error(`URL mismatch: expected "${expectedUrl}", got "${actualUrl}"`);
    }
  }

  /**
   * æ–­è¨€ï¼šå…ƒç´ æ•°é‡
   */
  async assertCount(selector: string, expectedCount: number): Promise<void> {
    const elements = await this.page.locator(selector);
    const actualCount = await elements.count();

    if (actualCount !== expectedCount) {
      throw new Error(`Count mismatch: expected ${expectedCount}, got ${actualCount}`);
    }
  }
}

// ç±»å‹å®šä¹‰
interface Test {
  name: string;
  fn: (page: Page) => Promise<void>;
}

interface TestResult {
  name: string;
  passed: boolean;
  duration: number;
  error: string | null;
}

interface TestSuiteResult {
  total: number;
  passed: number;
  failed: number;
  results: TestResult[];
}
```

### 7.2 æµ‹è¯•ç¤ºä¾‹

```typescript
/**
 * ç™»å½•åŠŸèƒ½æµ‹è¯•
 */
async function testLogin(page: Page) {
  // å¯¼èˆªåˆ°ç™»å½•é¡µ
  await page.goto('https://example.com/login');

  // è¾“å…¥ç”¨æˆ·å
  await page.fill('input[name="username"]', 'testuser');

  // è¾“å…¥å¯†ç 
  await page.fill('input[name="password"]', 'testpass123');

  // ç‚¹å‡»ç™»å½•æŒ‰é’®
  await page.click('button[type="submit"]');

  // ç­‰å¾…å¯¼èˆª
  await page.waitForURL('**/dashboard');

  // éªŒè¯ç™»å½•æˆåŠŸ
  await page.waitForSelector('.user-profile');
}

/**
 * æœç´¢åŠŸèƒ½æµ‹è¯•
 */
async function testSearch(page: Page) {
  const framework = new E2ETestFramework(page);

  // å¯¼èˆªåˆ°é¦–é¡µ
  await page.goto('https://example.com');

  // è¾“å…¥æœç´¢å…³é”®è¯
  await page.fill('input[name="search"]', 'playwright');

  // æäº¤æœç´¢
  await page.press('input[name="search"]', 'Enter');

  // ç­‰å¾…ç»“æœåŠ è½½
  await page.waitForSelector('.search-results');

  // éªŒè¯è‡³å°‘æœ‰ä¸€ä¸ªç»“æœ
  await framework.assertVisible('.search-result-item');
}

/**
 * è´­ç‰©è½¦åŠŸèƒ½æµ‹è¯•
 */
async function testShoppingCart(page: Page) {
  const framework = new E2ETestFramework(page);

  // è®¿é—®äº§å“é¡µ
  await page.goto('https://example.com/products/1');

  // æ·»åŠ åˆ°è´­ç‰©è½¦
  await page.click('button.add-to-cart');

  // ç­‰å¾…æˆåŠŸæ¶ˆæ¯
  await page.waitForSelector('.success-message');

  // è®¿é—®è´­ç‰©è½¦
  await page.goto('https://example.com/cart');

  // éªŒè¯äº§å“åœ¨è´­ç‰©è½¦ä¸­
  await framework.assertCount('.cart-item', 1);
}

/**
 * è¿è¡Œæ‰€æœ‰æµ‹è¯•
 */
async function runAllTests() {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  const framework = new E2ETestFramework(page);

  const tests: Test[] = [
    { name: 'Login Test', fn: testLogin },
    { name: 'Search Test', fn: testSearch },
    { name: 'Shopping Cart Test', fn: testShoppingCart }
  ];

  const results = await framework.runTestSuite(tests);

  console.log('\n=== Test Results ===');
  console.log(`Total: ${results.total}`);
  console.log(`Passed: ${results.passed}`);
  console.log(`Failed: ${results.failed}`);

  await browser.close();
}
```

---

## å…«ã€æœ€ä½³å®è·µå’Œ FAQ

### 8.1 æœ€ä½³å®è·µ

#### **1. ä½¿ç”¨ç­‰å¾…è€Œéå»¶æ—¶**

```typescript
// âŒ ä¸å¥½ï¼šä½¿ç”¨å›ºå®šå»¶æ—¶
await page.waitForTimeout(3000);
await page.click('.button');

// âœ… å¥½ï¼šç­‰å¾…å…ƒç´ å¯äº¤äº’
await page.waitForSelector('.button', { state: 'visible' });
await page.click('.button');

// âœ… æ›´å¥½ï¼šPlaywright è‡ªåŠ¨ç­‰å¾…
await page.click('.button');  // Playwright ä¼šè‡ªåŠ¨ç­‰å¾…å…ƒç´ å¯ç‚¹å‡»
```

#### **2. ä½¿ç”¨æœ‰æ„ä¹‰çš„é€‰æ‹©å™¨**

```typescript
// âŒ ä¸å¥½ï¼šä½¿ç”¨è„†å¼±çš„é€‰æ‹©å™¨
await page.click('body > div:nth-child(3) > button:nth-child(2)');

// âœ… å¥½ï¼šä½¿ç”¨è¯­ä¹‰åŒ–é€‰æ‹©å™¨
await page.click('button[data-testid="submit-button"]');

// âœ… æ›´å¥½ï¼šä½¿ç”¨ Role å’Œ Text
await page.click('role=button[name="Submit"]');
```

#### **3. é¡µé¢å¯¹è±¡æ¨¡å¼**

```typescript
/**
 * é¡µé¢å¯¹è±¡æ¨¡å¼
 * å°è£…é¡µé¢çš„ç»“æ„å’Œè¡Œä¸º
 */
class LoginPage {
  private page: Page;

  // é€‰æ‹©å™¨å®šä¹‰
  private selectors = {
    usernameInput: 'input[name="username"]',
    passwordInput: 'input[name="password"]',
    submitButton: 'button[type="submit"]',
    errorMessage: '.error-message'
  };

  constructor(page: Page) {
    this.page = page;
  }

  async navigate() {
    await this.page.goto('/login');
  }

  async login(username: string, password: string) {
    await this.page.fill(this.selectors.usernameInput, username);
    await this.page.fill(this.selectors.passwordInput, password);
    await this.page.click(this.selectors.submitButton);
  }

  async getErrorMessage(): Promise<string> {
    const element = await this.page.locator(this.selectors.errorMessage);
    return await element.textContent() || '';
  }
}

// ä½¿ç”¨
const loginPage = new LoginPage(page);
await loginPage.navigate();
await loginPage.login('testuser', 'testpass');
```

#### **4. é”™è¯¯å¤„ç†å’Œé‡è¯•**

```typescript
/**
 * å¸¦é‡è¯•çš„æ“ä½œ
 */
async function clickWithRetry(
  page: Page,
  selector: string,
  maxRetries = 3
): Promise<void> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await page.click(selector, { timeout: 5000 });
      return;
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      console.error(`Click failed, retrying (${i + 1}/${maxRetries})...`);
      await page.waitForTimeout(1000);
    }
  }
}
```

#### **5. æ¸…ç†èµ„æº**

```typescript
/**
 * ç¡®ä¿æµè§ˆå™¨å…³é—­
 */
class BrowserSession {
  private browser: Browser | null = null;

  async start() {
    this.browser = await chromium.launch();
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  async execute<T>(fn: (page: Page) => Promise<T>): Promise<T> {
    await this.start();

    try {
      const page = await this.browser!.newPage();
      return await fn(page);
    } finally {
      await this.close();
    }
  }
}

// ä½¿ç”¨
const session = new BrowserSession();
await session.execute(async (page) => {
  await page.goto('https://example.com');
  // æ‰§è¡Œæ“ä½œ...
});
// è‡ªåŠ¨æ¸…ç†
```

### 8.2 å¸¸è§é—®é¢˜ FAQ

#### **Q1: å…ƒç´ æ‰¾ä¸åˆ°æ€ä¹ˆåŠï¼Ÿ**

**æ’æŸ¥æ­¥éª¤**ï¼š
1. æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨ iframe ä¸­
2. æ£€æŸ¥å…ƒç´ æ˜¯å¦éœ€è¦ç­‰å¾…åŠ è½½
3. ä½¿ç”¨ Playwright Inspector è°ƒè¯•
4. æ£€æŸ¥é€‰æ‹©å™¨æ˜¯å¦æ­£ç¡®

```typescript
// è°ƒè¯•æŠ€å·§
await page.pause();  // æš‚åœå¹¶æ‰“å¼€ Playwright Inspector

// æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
const exists = await page.locator(selector).count() > 0;
console.log(`Element exists: ${exists}`);

// ç­‰å¾…æ›´é•¿æ—¶é—´
await page.waitForSelector(selector, { timeout: 30000 });
```

#### **Q2: å¦‚ä½•å¤„ç† iframeï¼Ÿ**

```typescript
// è·å– iframe
const frame = page.frameLocator('iframe[name="myframe"]');

// åœ¨ iframe ä¸­æ“ä½œ
await frame.locator('button').click();

// æˆ–è€…ä½¿ç”¨ frame å¯¹è±¡
const frameElement = await page.frame({ name: 'myframe' });
await frameElement?.click('button');
```

#### **Q3: å¦‚ä½•å¤„ç†å¼¹çª—ï¼Ÿ**

```typescript
// ç›‘å¬å¹¶è‡ªåŠ¨å¤„ç†
page.on('dialog', async (dialog) => {
  console.log(`Dialog message: ${dialog.message()}`);
  await dialog.accept();  // æˆ– dialog.dismiss()
});

// æ‰‹åŠ¨å¤„ç†
const [dialog] = await Promise.all([
  page.waitForEvent('dialog'),
  page.click('.trigger-dialog')
]);

await dialog.accept('input text');
```

#### **Q4: å¦‚ä½•æ¨¡æ‹Ÿç§»åŠ¨è®¾å¤‡ï¼Ÿ**

```typescript
const { devices } = require('playwright');

// ä½¿ç”¨é¢„å®šä¹‰è®¾å¤‡
const iPhone = devices['iPhone 12'];
const context = await browser.newContext({
  ...iPhone,
  locale: 'en-US',
  geolocation: { latitude: 37.7749, longitude: -122.4194 },
  permissions: ['geolocation']
});

const page = await context.newPage();
```

#### **Q5: å¦‚ä½•å¤„ç†æ–‡ä»¶ä¸‹è½½ï¼Ÿ**

```typescript
// ç­‰å¾…ä¸‹è½½
const [download] = await Promise.all([
  page.waitForEvent('download'),
  page.click('a[download]')
]);

// ä¿å­˜æ–‡ä»¶
const path = await download.path();
console.log(`Downloaded to: ${path}`);

// æˆ–è€…ä¿å­˜åˆ°æŒ‡å®šä½ç½®
await download.saveAs('/path/to/save/file.pdf');
```

---

## ä¹ã€å®æˆ˜ï¼šå®Œæ•´çš„ Web è‡ªåŠ¨åŒ–æ¡ˆä¾‹

### 9.1 æ¡ˆä¾‹ï¼šGitHub ä»“åº“è‡ªåŠ¨åŒ–

```typescript
/**
 * GitHub è‡ªåŠ¨åŒ–å·¥å…·
 * è‡ªåŠ¨åˆ›å»ºä»“åº“ã€æäº¤ä»£ç ã€åˆ›å»º PR
 */
class GitHubAutomation {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * ç™»å½• GitHub
   */
  async login(username: string, password: string): Promise<void> {
    console.log('Logging in to GitHub...');

    await this.page.goto('https://github.com/login');

    // è¾“å…¥ç”¨æˆ·å
    await this.page.fill('input[name="login"]', username);

    // è¾“å…¥å¯†ç 
    await this.page.fill('input[name="password"]', password);

    // æäº¤ç™»å½•
    await this.page.click('input[type="submit"]');

    // ç­‰å¾…ç™»å½•æˆåŠŸ
    await this.page.waitForURL('https://github.com/**', { timeout: 10000 });

    console.log('Login successful');
  }

  /**
   * åˆ›å»ºæ–°ä»“åº“
   */
  async createRepository(name: string, description: string, isPrivate = false): Promise<void> {
    console.log(`Creating repository: ${name}...`);

    // è®¿é—®åˆ›å»ºä»“åº“é¡µé¢
    await this.page.goto('https://github.com/new');

    // è¾“å…¥ä»“åº“å
    await this.page.fill('input[name="repository[name]"]', name);

    // è¾“å…¥æè¿°
    await this.page.fill('input[name="repository[description]"]', description);

    // é€‰æ‹©å¯è§æ€§
    if (isPrivate) {
      await this.page.check('input[value="private"]');
    } else {
      await this.page.check('input[value="public"]');
    }

    // åˆå§‹åŒ– README
    await this.page.check('input[name="repository[auto_init]"]');

    // æäº¤åˆ›å»º
    await this.page.click('button[type="submit"]');

    // ç­‰å¾…ä»“åº“é¡µé¢åŠ è½½
    await this.page.waitForURL(`**/${name}`, { timeout: 10000 });

    console.log(`Repository created: ${name}`);
  }

  /**
   * åˆ›å»ºæ–‡ä»¶
   */
  async createFile(repoName: string, fileName: string, content: string): Promise<void> {
    console.log(`Creating file: ${fileName}...`);

    // è®¿é—®ä»“åº“é¡µé¢
    await this.page.goto(`https://github.com/${repoName}`);

    // ç‚¹å‡» "Add file" æŒ‰é’®
    await this.page.click('button:has-text("Add file")');

    // é€‰æ‹© "Create new file"
    await this.page.click('a:has-text("Create new file")');

    // è¾“å…¥æ–‡ä»¶å
    await this.page.fill('input[name="filename"]', fileName);

    // è¾“å…¥å†…å®¹
    await this.page.fill('.CodeMirror textarea', content);

    // æäº¤
    await this.page.click('button:has-text("Commit new file")');

    console.log(`File created: ${fileName}`);
  }

  /**
   * åˆ›å»º Issue
   */
  async createIssue(repoName: string, title: string, body: string): Promise<void> {
    console.log(`Creating issue: ${title}...`);

    // è®¿é—® Issues é¡µé¢
    await this.page.goto(`https://github.com/${repoName}/issues/new`);

    // è¾“å…¥æ ‡é¢˜
    await this.page.fill('input[name="issue[title]"]', title);

    // è¾“å…¥å†…å®¹
    await this.page.fill('textarea[name="issue[body]"]', body);

    // æäº¤
    await this.page.click('button:has-text("Submit new issue")');

    console.log(`Issue created: ${title}`);
  }

  /**
   * æœç´¢ä»£ç 
   */
  async searchCode(query: string): Promise<string[]> {
    console.log(`Searching for: ${query}...`);

    // è®¿é—®æœç´¢é¡µé¢
    await this.page.goto(`https://github.com/search?q=${encodeURIComponent(query)}&type=code`);

    // ç­‰å¾…ç»“æœåŠ è½½
    await this.page.waitForSelector('.code-list-item');

    // æå–ç»“æœ
    const results = await this.page.evaluate(() => {
      const items = document.querySelectorAll('.code-list-item');
      return Array.from(items).map(item => {
        const title = item.querySelector('.f4 a')?.textContent?.trim();
        const repo = item.querySelector('.f6 a')?.textContent?.trim();
        return `${repo}: ${title}`;
      });
    });

    console.log(`Found ${results.length} results`);
    return results;
  }
}
```

### 9.2 æ¡ˆä¾‹ï¼šç”µå•†ç½‘ç«™æµ‹è¯•

```typescript
/**
 * ç”µå•†ç½‘ç«™è‡ªåŠ¨åŒ–æµ‹è¯•
 */
class EcommerceTestSuite {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * æµ‹è¯•å®Œæ•´è´­ç‰©æµç¨‹
   */
  async testCompletePurchaseFlow(): Promise<void> {
    console.log('Starting complete purchase flow test...');

    // 1. è®¿é—®é¦–é¡µ
    await this.page.goto('https://example-shop.com');
    await this.page.waitForLoadState('networkidle');

    // 2. æœç´¢äº§å“
    await this.page.fill('input[name="search"]', 'laptop');
    await this.page.press('input[name="search"]', 'Enter');
    await this.page.waitForSelector('.product-list');

    // 3. é€‰æ‹©äº§å“
    await this.page.click('.product-item:first-child .product-link');
    await this.page.waitForSelector('.product-detail');

    // 4. æ·»åŠ åˆ°è´­ç‰©è½¦
    await this.page.click('button.add-to-cart');
    await this.page.waitForSelector('.cart-notification');

    // 5. è®¿é—®è´­ç‰©è½¦
    await this.page.click('a[href="/cart"]');
    await this.page.waitForSelector('.cart-items');

    // éªŒè¯äº§å“åœ¨è´­ç‰©è½¦ä¸­
    const cartItemCount = await this.page.locator('.cart-item').count();
    console.assert(cartItemCount === 1, 'Expected 1 item in cart');

    // 6. è¿›å…¥ç»“è´¦
    await this.page.click('button.checkout');
    await this.page.waitForSelector('.checkout-form');

    // 7. å¡«å†™é…é€ä¿¡æ¯
    await this.fillShippingInfo({
      fullName: 'John Doe',
      email: 'john@example.com',
      address: '123 Main St',
      city: 'New York',
      zipCode: '10001',
      phone: '555-1234'
    });

    // 8. å¡«å†™æ”¯ä»˜ä¿¡æ¯
    await this.page.click('button.continue-to-payment');
    await this.fillPaymentInfo({
      cardNumber: '4111111111111111',
      cardHolder: 'John Doe',
      expiryDate: '12/25',
      cvv: '123'
    });

    // 9. ç¡®è®¤è®¢å•
    await this.page.click('button.place-order');

    // 10. éªŒè¯è®¢å•æˆåŠŸ
    await this.page.waitForSelector('.order-confirmation');
    const orderNumber = await this.page.textContent('.order-number');
    console.log(`Order placed successfully: ${orderNumber}`);

    // 11. æˆªå›¾ç•™å­˜
    await this.page.screenshot({ path: `order-${orderNumber}.png` });
  }

  /**
   * å¡«å†™é…é€ä¿¡æ¯
   */
  private async fillShippingInfo(info: any): Promise<void> {
    await this.page.fill('input[name="fullName"]', info.fullName);
    await this.page.fill('input[name="email"]', info.email);
    await this.page.fill('input[name="address"]', info.address);
    await this.page.fill('input[name="city"]', info.city);
    await this.page.fill('input[name="zipCode"]', info.zipCode);
    await this.page.fill('input[name="phone"]', info.phone);
  }

  /**
   * å¡«å†™æ”¯ä»˜ä¿¡æ¯
   */
  private async fillPaymentInfo(info: any): Promise<void> {
    await this.page.fill('input[name="cardNumber"]', info.cardNumber);
    await this.page.fill('input[name="cardHolder"]', info.cardHolder);
    await this.page.fill('input[name="expiryDate"]', info.expiryDate);
    await this.page.fill('input[name="cvv"]', info.cvv);
  }

  /**
   * æµ‹è¯•æ€§èƒ½
   */
  async testPagePerformance(): Promise<void> {
    console.log('Testing page performance...');

    // å¯åŠ¨æ€§èƒ½è¿½è¸ª
    await this.page.goto('https://example-shop.com');

    // è·å–æ€§èƒ½æŒ‡æ ‡
    const metrics = await this.page.evaluate(() => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      return {
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
        firstPaint: performance.getEntriesByType('paint')[0]?.startTime || 0
      };
    });

    console.log('Performance Metrics:');
    console.log(`  DOM Content Loaded: ${metrics.domContentLoaded}ms`);
    console.log(`  Load Complete: ${metrics.loadComplete}ms`);
    console.log(`  First Paint: ${metrics.firstPaint}ms`);

    // éªŒè¯æ€§èƒ½æŒ‡æ ‡
    console.assert(metrics.domContentLoaded < 2000, 'DOM load too slow');
    console.assert(metrics.firstPaint < 1000, 'First paint too slow');
  }
}
```

### 9.3 ä½¿ç”¨æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·/CI
    participant Claude as Claude AI
    participant MCP as Playwright MCP
    participant Browser as æµè§ˆå™¨
    participant Web as Webåº”ç”¨

    User->>Claude: è¯·æµ‹è¯•ç™»å½•åŠŸèƒ½
    Claude->>MCP: browser_navigate(login_url)
    MCP->>Browser: page.goto()
    Browser->>Web: HTTP GET
    Web-->>Browser: HTML
    Browser-->>MCP: é¡µé¢åŠ è½½å®Œæˆ
    MCP-->>Claude: å¯¼èˆªæˆåŠŸ

    Claude->>MCP: browser_snapshot()
    MCP->>Browser: page.accessibility.snapshot()
    Browser-->>MCP: Accessibility Tree
    MCP-->>Claude: é¡µé¢ç»“æ„

    Note over Claude: åˆ†æé¡µé¢ï¼Œè¯†åˆ«è¾“å…¥æ¡†å’ŒæŒ‰é’®

    Claude->>MCP: browser_type(username_field, "testuser")
    MCP->>Browser: page.fill()
    Browser->>Web: è¾“å…¥ç”¨æˆ·å
    MCP-->>Claude: è¾“å…¥å®Œæˆ

    Claude->>MCP: browser_type(password_field, "pass123")
    MCP->>Browser: page.fill()
    Browser->>Web: è¾“å…¥å¯†ç 
    MCP-->>Claude: è¾“å…¥å®Œæˆ

    Claude->>MCP: browser_click(submit_button)
    MCP->>Browser: page.click()
    Browser->>Web: æäº¤è¡¨å•
    Web-->>Browser: ç™»å½•ç»“æœ
    MCP-->>Claude: ç‚¹å‡»å®Œæˆ

    Claude->>MCP: browser_snapshot()
    MCP->>Browser: page.accessibility.snapshot()
    Browser-->>MCP: æ–°é¡µé¢ç»“æ„
    MCP-->>Claude: ç™»å½•åé¡µé¢

    Note over Claude: éªŒè¯ç™»å½•æˆåŠŸ

    Claude-->>User: æµ‹è¯•å®ŒæˆæŠ¥å‘Š
```

---

## åã€æ€»ç»“

æµè§ˆå™¨è‡ªåŠ¨åŒ–æ˜¯ Claude Code çš„å¼ºå¤§èƒ½åŠ›ä¹‹ä¸€ï¼Œé€šè¿‡ Playwright MCP Serverï¼ŒAI èƒ½å¤Ÿåƒäººç±»ä¸€æ ·æ“ä½œæµè§ˆå™¨ï¼Œæ‰§è¡Œå¤æ‚çš„ Web è‡ªåŠ¨åŒ–ä»»åŠ¡ã€‚

### å…³é”®è¦ç‚¹

âœ… **Playwright å¼ºå¤§è€Œçµæ´»**ï¼šæ”¯æŒå¤šæµè§ˆå™¨ã€è‡ªåŠ¨ç­‰å¾…ã€ç½‘ç»œæ‹¦æˆªç­‰é«˜çº§åŠŸèƒ½
âœ… **Accessibility Tree æ˜¯æ ¸å¿ƒ**ï¼šæä¾›ç®€æ´çš„é¡µé¢ç»“æ„ï¼Œä¾¿äº AI ç†è§£å’Œæ“ä½œ
âœ… **MCP åè®®æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€çš„æ¥å£ï¼Œæ˜“äºæ‰©å±•å’Œç»´æŠ¤
âœ… **å®æˆ˜åº”ç”¨å¹¿æ³›**ï¼šæµ‹è¯•ã€çˆ¬è™«ã€ç›‘æ§ã€è‡ªåŠ¨åŒ–è¿ç»´ç­‰

### æ ¸å¿ƒæµç¨‹

```mermaid
graph LR
    A[å¯åŠ¨æµè§ˆå™¨] --> B[å¯¼èˆªåˆ°é¡µé¢]
    B --> C[è·å–é¡µé¢å¿«ç…§]
    C --> D[AIåˆ†æé¡µé¢]
    D --> E[å®šä½å…ƒç´ ]
    E --> F[æ‰§è¡Œæ“ä½œ]
    F --> G[éªŒè¯ç»“æœ]
    G --> H[ç”ŸæˆæŠ¥å‘Š]

    style A fill:#e1f5ff
    style D fill:#ffe1f5
    style H fill:#e1ffe1
```

### ä¸‹ä¸€æ­¥å­¦ä¹ 

1. é˜…è¯»ä¸‹ä¸€ç¯‡æ–‡ç« ï¼Œæ·±å…¥äº†è§£å…¶ä»– MCP å·¥å…·
2. å°è¯•ç¼–å†™è‡ªå·±çš„è‡ªåŠ¨åŒ–è„šæœ¬
3. å°†æµè§ˆå™¨è‡ªåŠ¨åŒ–é›†æˆåˆ° CI/CD æµç¨‹

---

**æµè§ˆå™¨è‡ªåŠ¨åŒ–è®© AI èƒ½å¤ŸçœŸæ­£ä¸ Web ä¸–ç•Œäº¤äº’ï¼Œå¼€å¯æ— é™å¯èƒ½ï¼** ğŸš€
