---
title: Claude Codeæ¶æ„è¯¦è§£ï¼ˆäº”ï¼‰ï¼šå·¥å…·ç³»ç»Ÿæ¶æ„
date: 2025-01-14
permalink: /ai/claude-code/architecture/05-tool-system-architecture.html
tags:
  - Claude Code
  - å·¥å…·ç³»ç»Ÿ
  - æ¶æ„è®¾è®¡
  - Tool Calling
categories:
  - AI
  - Claude Code
---

# ç¬¬5ç¯‡ï¼šå·¥å…·ç³»ç»Ÿæ¶æ„

## å¼•è¨€

å·¥å…·ç³»ç»Ÿæ˜¯ Claude Code çš„"æ‰‹å’Œçœ¼"ï¼Œèµ‹äºˆäº† AI ä¸çœŸå®ä¸–ç•Œäº¤äº’çš„èƒ½åŠ›ã€‚å¦‚æœè¯´ AI å¼•æ“æ˜¯"å¤§è„‘"ï¼Œé‚£ä¹ˆå·¥å…·ç³»ç»Ÿå°±æ˜¯"å››è‚¢"ï¼Œè´Ÿè´£æ‰§è¡Œå®é™…çš„æ–‡ä»¶æ“ä½œã€ä»£ç æœç´¢ã€å‘½ä»¤æ‰§è¡Œç­‰ä»»åŠ¡ã€‚æœ¬æ–‡å°†æ·±å…¥è§£æ Claude Code å·¥å…·ç³»ç»Ÿçš„å®Œæ•´æ¶æ„ã€‚

### ä¸ºä»€ä¹ˆå·¥å…·ç³»ç»Ÿå¦‚æ­¤é‡è¦ï¼Ÿ

1. **èµ‹èƒ½ AI**ï¼šè®© AI ä»"åªèƒ½è¯´"å˜æˆ"æ—¢èƒ½è¯´åˆèƒ½åš"
2. **æ ‡å‡†åŒ–äº¤äº’**ï¼šç»Ÿä¸€çš„å·¥å…·æ¥å£ï¼Œé™ä½é›†æˆå¤æ‚åº¦
3. **å®‰å…¨å¯æ§**ï¼šé€šè¿‡æƒé™ç®¡ç†å’Œå‚æ•°éªŒè¯ç¡®ä¿å®‰å…¨
4. **å¯æ‰©å±•æ€§**ï¼šæ’ä»¶åŒ–è®¾è®¡ï¼Œæ”¯æŒæ— é™æ‰©å±•
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ™ºèƒ½è°ƒåº¦å’Œå¹¶è¡Œæ‰§è¡Œæå‡æ•ˆç‡

### æœ¬æ–‡ç›®æ ‡

- ç†è§£å·¥å…·ç³»ç»Ÿçš„æ•´ä½“æ¶æ„
- æŒæ¡ Tool Schema è®¾è®¡è§„èŒƒ
- å­¦ä¹ å·¥å…·æ³¨å†Œå’Œè°ƒç”¨æµç¨‹
- äº†è§£æƒé™ç®¡ç†å’Œå®‰å…¨æœºåˆ¶
- å®æˆ˜å¼€å‘ä¸€ä¸ªè‡ªå®šä¹‰å·¥å…·

---

## ä¸€ã€å·¥å…·ç³»ç»Ÿæ•´ä½“æ¶æ„

### 1.1 æ ¸å¿ƒç»„ä»¶

```mermaid
graph TB
    subgraph "AIå±‚"
        A[Claude AI]
    end

    subgraph "å·¥å…·ç³»ç»Ÿæ ¸å¿ƒ"
        B[å·¥å…·è°ƒåº¦å™¨<br/>Tool Dispatcher]
        C[å·¥å…·æ³¨å†Œè¡¨<br/>Tool Registry]
        D[å‚æ•°éªŒè¯å™¨<br/>Parameter Validator]
        E[æƒé™ç®¡ç†å™¨<br/>Permission Manager]
        F[æ‰§è¡Œå¼•æ“<br/>Execution Engine]
    end

    subgraph "å†…ç½®å·¥å…·å±‚"
        G1[Read]
        G2[Write]
        G3[Edit]
        G4[Bash]
        G5[Glob]
        G6[Grep]
    end

    subgraph "æ‰©å±•å·¥å…·å±‚"
        H1[MCPå·¥å…·]
        H2[Browserå·¥å…·]
        H3[è‡ªå®šä¹‰å·¥å…·]
    end

    subgraph "ç³»ç»Ÿèµ„æºå±‚"
        I1[æ–‡ä»¶ç³»ç»Ÿ]
        I2[è¿›ç¨‹ç®¡ç†]
        I3[ç½‘ç»œé€šä¿¡]
        I4[å¤–éƒ¨æœåŠ¡]
    end

    A -->|Tool Call| B
    B --> C
    B --> D
    B --> E
    B --> F

    C --> G1
    C --> G2
    C --> G3
    C --> G4
    C --> G5
    C --> G6

    C --> H1
    C --> H2
    C --> H3

    F --> G1 --> I1
    F --> G2 --> I1
    F --> G3 --> I1
    F --> G4 --> I2
    F --> G5 --> I1
    F --> G6 --> I1

    F --> H1 --> I3
    F --> H2 --> I4
    F --> H3 --> I3

    style B fill:#e1f5ff,stroke:#333,stroke-width:3px
    style C fill:#ffe1f5,stroke:#333,stroke-width:2px
    style A fill:#fff4e1,stroke:#333,stroke-width:2px
```

### 1.2 å·¥å…·ç³»ç»Ÿåˆ†å±‚

| å±‚çº§ | èŒè´£ | æ ¸å¿ƒç»„ä»¶ |
|-----|------|---------|
| **æ¥å£å±‚** | æ¥æ”¶AIçš„å·¥å…·è°ƒç”¨è¯·æ±‚ | Tool Dispatcher |
| **ç®¡ç†å±‚** | å·¥å…·æ³¨å†Œã€éªŒè¯ã€æƒé™æ§åˆ¶ | Registryã€Validatorã€Permission Manager |
| **æ‰§è¡Œå±‚** | å®é™…æ‰§è¡Œå·¥å…·é€»è¾‘ | Execution Engineã€Tool Executors |
| **èµ„æºå±‚** | è®¿é—®ç³»ç»Ÿèµ„æº | File Systemã€Processã€Network |

### 1.3 å·¥å…·åˆ†ç±»

```mermaid
graph LR
    A[å·¥å…·ç³»ç»Ÿ] --> B[æŒ‰åŠŸèƒ½åˆ†ç±»]
    A --> C[æŒ‰æ¥æºåˆ†ç±»]

    B --> B1[æ–‡ä»¶æ“ä½œç±»<br/>Read/Write/Edit]
    B --> B2[ä»£ç æœç´¢ç±»<br/>Glob/Grep]
    B --> B3[ç³»ç»Ÿæ‰§è¡Œç±»<br/>Bash/BashOutput]
    B --> B4[æ‰©å±•åŠŸèƒ½ç±»<br/>Browser/MCP]

    C --> C1[å†…ç½®å·¥å…·<br/>Built-in Tools]
    C --> C2[MCPå·¥å…·<br/>MCP Tools]
    C --> C3[è‡ªå®šä¹‰å·¥å…·<br/>Custom Tools]

    style A fill:#e1f5ff,stroke:#333,stroke-width:3px
```

---

## äºŒã€Tool Schema è®¾è®¡è§„èŒƒ

### 2.1 JSON Schema æ ‡å‡†

Claude Code é‡‡ç”¨ JSON Schema å®šä¹‰å·¥å…·æ¥å£ï¼Œè¿™æ˜¯ Anthropic API çš„æ ‡å‡†æ ¼å¼ã€‚

```typescript
// å·¥å…·å®šä¹‰çš„å®Œæ•´ç±»å‹
interface ToolDefinition {
  // å·¥å…·åç§°ï¼ˆå”¯ä¸€æ ‡è¯†ç¬¦ï¼‰
  name: string;

  // å·¥å…·æè¿°ï¼ˆAIç”¨äºç†è§£å·¥å…·ç”¨é€”ï¼‰
  description: string;

  // è¾“å…¥å‚æ•°çš„JSON Schema
  input_schema: {
    type: 'object';
    properties: Record<string, PropertySchema>;
    required?: string[];
    additionalProperties?: boolean;
  };
}

// å±æ€§å®šä¹‰
interface PropertySchema {
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
  description: string;
  enum?: any[];
  items?: PropertySchema;
  default?: any;
}
```

### 2.2 å†…ç½®å·¥å…·ç¤ºä¾‹

#### Read å·¥å…·å®šä¹‰

```typescript
const ReadToolDefinition: ToolDefinition = {
  name: 'Read',
  description: `Reads a file from the local filesystem. You can access any file directly by using this tool.

Usage:
- The file_path parameter must be an absolute path, not a relative path
- By default, it reads up to 2000 lines starting from the beginning
- You can optionally specify a line offset and limit (especially handy for long files)
- Any lines longer than 2000 characters will be truncated
- Results are returned using cat -n format, with line numbers starting at 1`,

  input_schema: {
    type: 'object',
    properties: {
      file_path: {
        type: 'string',
        description: 'The absolute path to the file to read'
      },
      offset: {
        type: 'number',
        description: 'The line number to start reading from. Only provide if the file is too large to read at once'
      },
      limit: {
        type: 'number',
        description: 'The number of lines to read. Only provide if the file is too large to read at once'
      }
    },
    required: ['file_path']
  }
};
```

#### Bash å·¥å…·å®šä¹‰

```typescript
const BashToolDefinition: ToolDefinition = {
  name: 'Bash',
  description: `Executes a given bash command in a persistent shell session.

Usage notes:
- Always quote file paths that contain spaces with double quotes
- The command argument is required
- You can specify an optional timeout in milliseconds (up to 600000ms / 10 minutes)
- You can use run_in_background parameter to run commands in background
- Avoid using Bash with find, grep, cat commands - use dedicated tools instead`,

  input_schema: {
    type: 'object',
    properties: {
      command: {
        type: 'string',
        description: 'The command to execute'
      },
      description: {
        type: 'string',
        description: 'Clear, concise description of what this command does in 5-10 words'
      },
      timeout: {
        type: 'number',
        description: 'Optional timeout in milliseconds (max 600000)',
        default: 120000
      },
      run_in_background: {
        type: 'boolean',
        description: 'Set to true to run this command in the background',
        default: false
      }
    },
    required: ['command']
  }
};
```

#### Edit å·¥å…·å®šä¹‰

```typescript
const EditToolDefinition: ToolDefinition = {
  name: 'Edit',
  description: `Performs exact string replacements in files.

Usage:
- You must use Read tool at least once before editing
- Preserve exact indentation as it appears in the file
- The edit will FAIL if old_string is not unique in the file
- Use replace_all for replacing and renaming strings across the file`,

  input_schema: {
    type: 'object',
    properties: {
      file_path: {
        type: 'string',
        description: 'The absolute path to the file to modify'
      },
      old_string: {
        type: 'string',
        description: 'The text to replace'
      },
      new_string: {
        type: 'string',
        description: 'The text to replace it with (must be different from old_string)'
      },
      replace_all: {
        type: 'boolean',
        description: 'Replace all occurences of old_string (default false)',
        default: false
      }
    },
    required: ['file_path', 'old_string', 'new_string']
  }
};
```

### 2.3 Schema è®¾è®¡æœ€ä½³å®è·µ

**1. æè¿°æ¸…æ™°**

```typescript
// âŒ ä¸å¥½çš„æè¿°
{
  name: 'search',
  description: 'Search files',
  // ...
}

// âœ… å¥½çš„æè¿°
{
  name: 'Grep',
  description: `A powerful search tool built on ripgrep.

Usage:
- ALWAYS use Grep for search tasks. NEVER invoke grep as a Bash command
- Supports full regex syntax (e.g., "log.*Error", "function\\s+\\w+")
- Filter files with glob parameter (e.g., "*.js", "**/*.tsx")
- Output modes: "content" shows matching lines, "files_with_matches" shows only file paths`,
  // ...
}
```

**2. å‚æ•°ç±»å‹æ˜ç¡®**

```typescript
// å®Œæ•´çš„å‚æ•°å®šä¹‰
properties: {
  file_path: {
    type: 'string',
    description: 'The absolute path to the file to read'
  },
  line_number: {
    type: 'number',
    description: 'The line number to start from (1-indexed)'
  },
  case_sensitive: {
    type: 'boolean',
    description: 'Whether the search is case sensitive',
    default: false
  },
  file_types: {
    type: 'array',
    description: 'File extensions to search (e.g., ["ts", "js"])',
    items: {
      type: 'string'
    }
  }
}
```

**3. å¿…éœ€å‚æ•°æ ‡æ³¨**

```typescript
{
  input_schema: {
    type: 'object',
    properties: {
      file_path: { type: 'string', description: '...' },
      content: { type: 'string', description: '...' },
      encoding: { type: 'string', description: '...', default: 'utf-8' }
    },
    // æ˜ç¡®æ ‡æ³¨å¿…éœ€å‚æ•°
    required: ['file_path', 'content']
  }
}
```

---

## ä¸‰ã€å·¥å…·æ³¨å†Œå’Œå‘ç°æœºåˆ¶

### 3.1 å·¥å…·æ³¨å†Œè¡¨è®¾è®¡

```typescript
/**
 * å·¥å…·æ‰§è¡Œå™¨æ¥å£
 */
interface ToolExecutor {
  /**
   * æ‰§è¡Œå·¥å…·
   * @param input å·¥å…·è¾“å…¥å‚æ•°
   * @returns å·¥å…·æ‰§è¡Œç»“æœ
   */
  execute(input: Record<string, any>): Promise<ToolResult>;
}

/**
 * å·¥å…·æ‰§è¡Œç»“æœ
 */
interface ToolResult {
  success: boolean;
  content?: string;
  error?: string;
  metadata?: Record<string, any>;
}

/**
 * å·¥å…·æ³¨å†Œè¡¨
 * è´Ÿè´£ç®¡ç†æ‰€æœ‰å¯ç”¨å·¥å…·
 */
class ToolRegistry {
  // å·¥å…·å®šä¹‰æ˜ å°„è¡¨
  private definitions: Map<string, ToolDefinition> = new Map();

  // å·¥å…·æ‰§è¡Œå™¨æ˜ å°„è¡¨
  private executors: Map<string, ToolExecutor> = new Map();

  /**
   * æ³¨å†Œå·¥å…·
   * @param definition å·¥å…·å®šä¹‰
   * @param executor å·¥å…·æ‰§è¡Œå™¨
   */
  register(definition: ToolDefinition, executor: ToolExecutor): void {
    // éªŒè¯å·¥å…·å®šä¹‰
    this.validateDefinition(definition);

    // æ£€æŸ¥åç§°å†²çª
    if (this.definitions.has(definition.name)) {
      throw new Error(`Tool ${definition.name} already registered`);
    }

    // æ³¨å†Œå·¥å…·
    this.definitions.set(definition.name, definition);
    this.executors.set(definition.name, executor);

    console.log(`âœ… Registered tool: ${definition.name}`);
  }

  /**
   * è·å–æ‰€æœ‰å·¥å…·å®šä¹‰ï¼ˆç”¨äºå‘é€ç»™AIï¼‰
   */
  getAllDefinitions(): ToolDefinition[] {
    return Array.from(this.definitions.values());
  }

  /**
   * è·å–å·¥å…·æ‰§è¡Œå™¨
   */
  getExecutor(name: string): ToolExecutor | undefined {
    return this.executors.get(name);
  }

  /**
   * æ£€æŸ¥å·¥å…·æ˜¯å¦å­˜åœ¨
   */
  has(name: string): boolean {
    return this.definitions.has(name);
  }

  /**
   * éªŒè¯å·¥å…·å®šä¹‰
   */
  private validateDefinition(definition: ToolDefinition): void {
    if (!definition.name) {
      throw new Error('Tool name is required');
    }

    if (!definition.description) {
      throw new Error(`Tool ${definition.name}: description is required`);
    }

    if (!definition.input_schema) {
      throw new Error(`Tool ${definition.name}: input_schema is required`);
    }

    // éªŒè¯ JSON Schema æ ¼å¼
    if (definition.input_schema.type !== 'object') {
      throw new Error(`Tool ${definition.name}: input_schema.type must be "object"`);
    }
  }
}
```

### 3.2 å†…ç½®å·¥å…·æ³¨å†Œ

```typescript
/**
 * åˆå§‹åŒ–å†…ç½®å·¥å…·
 */
function registerBuiltInTools(registry: ToolRegistry): void {
  // æ–‡ä»¶æ“ä½œå·¥å…·
  registry.register(ReadToolDefinition, new ReadToolExecutor());
  registry.register(WriteToolDefinition, new WriteToolExecutor());
  registry.register(EditToolDefinition, new EditToolExecutor());

  // æœç´¢å·¥å…·
  registry.register(GlobToolDefinition, new GlobToolExecutor());
  registry.register(GrepToolDefinition, new GrepToolExecutor());

  // ç³»ç»Ÿå·¥å…·
  registry.register(BashToolDefinition, new BashToolExecutor());
  registry.register(BashOutputToolDefinition, new BashOutputToolExecutor());
  registry.register(KillShellToolDefinition, new KillShellToolExecutor());

  console.log('âœ… All built-in tools registered');
}
```

### 3.3 MCP å·¥å…·åŠ¨æ€æ³¨å†Œ

```typescript
/**
 * MCP å·¥å…·åŠ è½½å™¨
 */
class MCPToolLoader {
  private registry: ToolRegistry;

  constructor(registry: ToolRegistry) {
    this.registry = registry;
  }

  /**
   * ä» MCP Server åŠ è½½å·¥å…·
   */
  async loadFromMCP(mcpServerConfig: MCPServerConfig): Promise<void> {
    console.log(`Loading MCP Server: ${mcpServerConfig.name}...`);

    try {
      // è¿æ¥åˆ° MCP Server
      const mcpServer = await this.connectToMCPServer(mcpServerConfig);

      // è·å– MCP Server æä¾›çš„å·¥å…·åˆ—è¡¨
      const tools = await mcpServer.listTools();

      // æ³¨å†Œæ¯ä¸ªå·¥å…·
      for (const tool of tools) {
        // è½¬æ¢ MCP å·¥å…·å®šä¹‰ä¸º Claude Code æ ¼å¼
        const definition = this.convertMCPToolDefinition(tool);

        // åˆ›å»ºæ‰§è¡Œå™¨ï¼ˆä»£ç†åˆ° MCP Serverï¼‰
        const executor = this.createMCPToolExecutor(mcpServer, tool.name);

        // æ³¨å†Œåˆ°å·¥å…·æ³¨å†Œè¡¨
        this.registry.register(definition, executor);
      }

      console.log(`âœ… Loaded ${tools.length} tools from ${mcpServerConfig.name}`);
    } catch (error) {
      console.error(`âŒ Failed to load MCP Server ${mcpServerConfig.name}:`, error);
    }
  }

  /**
   * åˆ›å»º MCP å·¥å…·æ‰§è¡Œå™¨
   */
  private createMCPToolExecutor(
    mcpServer: MCPServer,
    toolName: string
  ): ToolExecutor {
    return {
      async execute(input: Record<string, any>): Promise<ToolResult> {
        try {
          // è°ƒç”¨ MCP Server æ‰§è¡Œå·¥å…·
          const result = await mcpServer.callTool(toolName, input);

          return {
            success: true,
            content: result.content
          };
        } catch (error) {
          return {
            success: false,
            error: error.message
          };
        }
      }
    };
  }

  /**
   * è½¬æ¢ MCP å·¥å…·å®šä¹‰ä¸º Claude Code æ ¼å¼
   */
  private convertMCPToolDefinition(mcpTool: MCPToolInfo): ToolDefinition {
    return {
      name: `mcp__${mcpTool.serverName}__${mcpTool.name}`,
      description: mcpTool.description,
      input_schema: mcpTool.inputSchema
    };
  }

  /**
   * è¿æ¥åˆ° MCP Server
   */
  private async connectToMCPServer(config: MCPServerConfig): Promise<MCPServer> {
    // å®ç° MCP åè®®è¿æ¥é€»è¾‘
    // ...
    throw new Error('Not implemented');
  }
}
```

### 3.4 å·¥å…·å‘ç°æµç¨‹

```mermaid
sequenceDiagram
    participant Main as ä¸»ç¨‹åº
    participant Registry as å·¥å…·æ³¨å†Œè¡¨
    participant BuiltIn as å†…ç½®å·¥å…·
    participant MCPLoader as MCPåŠ è½½å™¨
    participant MCPServer as MCP Server

    Main->>Registry: åˆ›å»ºæ³¨å†Œè¡¨
    Main->>BuiltIn: æ³¨å†Œå†…ç½®å·¥å…·
    BuiltIn->>Registry: register(Read)
    BuiltIn->>Registry: register(Write)
    BuiltIn->>Registry: register(Edit)
    BuiltIn->>Registry: register(Bash)
    BuiltIn->>Registry: register(Glob)
    BuiltIn->>Registry: register(Grep)

    Main->>MCPLoader: åŠ è½½MCPå·¥å…·
    MCPLoader->>MCPServer: è¿æ¥MCP Server
    MCPServer-->>MCPLoader: è¿æ¥æˆåŠŸ
    MCPLoader->>MCPServer: listTools()
    MCPServer-->>MCPLoader: å·¥å…·åˆ—è¡¨

    loop æ¯ä¸ªMCPå·¥å…·
        MCPLoader->>Registry: register(mcp__tool)
    end

    Main->>Registry: getAllDefinitions()
    Registry-->>Main: è¿”å›æ‰€æœ‰å·¥å…·å®šä¹‰
```

---

## å››ã€å‚æ•°éªŒè¯å’Œç±»å‹æ£€æŸ¥

### 4.1 å‚æ•°éªŒè¯å™¨

```typescript
/**
 * å‚æ•°éªŒè¯å™¨
 * è´Ÿè´£éªŒè¯å·¥å…·è°ƒç”¨å‚æ•°æ˜¯å¦ç¬¦åˆ Schema å®šä¹‰
 */
class ParameterValidator {
  /**
   * éªŒè¯å‚æ•°
   * @param toolName å·¥å…·åç§°
   * @param params å‚æ•°å¯¹è±¡
   * @param schema å‚æ•°çš„ JSON Schema
   * @returns éªŒè¯ç»“æœ
   */
  validate(
    toolName: string,
    params: Record<string, any>,
    schema: ToolDefinition['input_schema']
  ): ValidationResult {
    const errors: string[] = [];

    // 1. æ£€æŸ¥å¿…éœ€å‚æ•°
    if (schema.required) {
      for (const requiredField of schema.required) {
        if (!(requiredField in params)) {
          errors.push(`Missing required parameter: ${requiredField}`);
        }
      }
    }

    // 2. æ£€æŸ¥å‚æ•°ç±»å‹
    for (const [fieldName, value] of Object.entries(params)) {
      const fieldSchema = schema.properties[fieldName];

      if (!fieldSchema) {
        // æ£€æŸ¥æ˜¯å¦å…è®¸é¢å¤–å‚æ•°
        if (schema.additionalProperties === false) {
          errors.push(`Unknown parameter: ${fieldName}`);
        }
        continue;
      }

      // ç±»å‹æ£€æŸ¥
      const typeError = this.validateType(fieldName, value, fieldSchema);
      if (typeError) {
        errors.push(typeError);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * éªŒè¯å‚æ•°ç±»å‹
   */
  private validateType(
    fieldName: string,
    value: any,
    schema: PropertySchema
  ): string | null {
    const actualType = this.getType(value);

    if (schema.type === 'string' && actualType !== 'string') {
      return `Parameter ${fieldName} must be a string, got ${actualType}`;
    }

    if (schema.type === 'number' && actualType !== 'number') {
      return `Parameter ${fieldName} must be a number, got ${actualType}`;
    }

    if (schema.type === 'boolean' && actualType !== 'boolean') {
      return `Parameter ${fieldName} must be a boolean, got ${actualType}`;
    }

    if (schema.type === 'array') {
      if (!Array.isArray(value)) {
        return `Parameter ${fieldName} must be an array, got ${actualType}`;
      }

      // éªŒè¯æ•°ç»„å…ƒç´ 
      if (schema.items) {
        for (let i = 0; i < value.length; i++) {
          const itemError = this.validateType(
            `${fieldName}[${i}]`,
            value[i],
            schema.items
          );
          if (itemError) {
            return itemError;
          }
        }
      }
    }

    if (schema.type === 'object') {
      if (actualType !== 'object') {
        return `Parameter ${fieldName} must be an object, got ${actualType}`;
      }
    }

    // æ£€æŸ¥æšä¸¾å€¼
    if (schema.enum && !schema.enum.includes(value)) {
      return `Parameter ${fieldName} must be one of: ${schema.enum.join(', ')}`;
    }

    return null;
  }

  /**
   * è·å–å€¼çš„ç±»å‹
   */
  private getType(value: any): string {
    if (value === null) return 'null';
    if (value === undefined) return 'undefined';
    if (Array.isArray(value)) return 'array';
    return typeof value;
  }
}

/**
 * éªŒè¯ç»“æœ
 */
interface ValidationResult {
  valid: boolean;
  errors: string[];
}
```

### 4.2 å‚æ•°éªŒè¯ç¤ºä¾‹

```typescript
// ä½¿ç”¨ç¤ºä¾‹
const validator = new ParameterValidator();

// éªŒè¯ Read å·¥å…·å‚æ•°
const readParams = {
  file_path: '/path/to/file.ts',
  offset: 10,
  limit: 100
};

const result = validator.validate('Read', readParams, ReadToolDefinition.input_schema);

if (!result.valid) {
  console.error('Parameter validation failed:');
  result.errors.forEach(error => console.error(`  - ${error}`));
}

// é”™è¯¯ç¤ºä¾‹ï¼šç¼ºå°‘å¿…éœ€å‚æ•°
const invalidParams = {
  offset: 10
  // ç¼ºå°‘ file_path
};

const invalidResult = validator.validate('Read', invalidParams, ReadToolDefinition.input_schema);
// invalidResult.valid === false
// invalidResult.errors === ['Missing required parameter: file_path']
```

---

## äº”ã€å·¥å…·æƒé™ç®¡ç†

### 5.1 æƒé™ç®¡ç†æ¶æ„

```mermaid
graph TB
    A[å·¥å…·è°ƒç”¨è¯·æ±‚] --> B{æƒé™æ£€æŸ¥}
    B -->|é€šè¿‡| C{å‚æ•°éªŒè¯}
    B -->|æ‹’ç»| X1[è¿”å›é”™è¯¯]

    C -->|é€šè¿‡| D{éœ€è¦ç”¨æˆ·ç¡®è®¤?}
    C -->|å¤±è´¥| X2[å‚æ•°é”™è¯¯]

    D -->|æ˜¯| E{ç ´åæ€§æ“ä½œ?}
    D -->|å¦| F[ç›´æ¥æ‰§è¡Œ]

    E -->|æ˜¯| G[å¼ºåˆ¶ç”¨æˆ·ç¡®è®¤]
    E -->|å¦| H[å¯é€‰ç¡®è®¤]

    G --> I[ç­‰å¾…ç”¨æˆ·è¾“å…¥]
    H --> I

    I -->|åŒæ„| F
    I -->|æ‹’ç»| X3[å–æ¶ˆæ‰§è¡Œ]

    F --> J[æ‰§è¡Œå·¥å…·]
    J --> K[è¿”å›ç»“æœ]

    style B fill:#ffe1e1,stroke:#333,stroke-width:2px
    style E fill:#fff4e1,stroke:#333,stroke-width:2px
    style J fill:#e1f5ff,stroke:#333,stroke-width:2px
```

### 5.2 æƒé™ç®¡ç†å™¨å®ç°

```typescript
/**
 * å·¥å…·æƒé™çº§åˆ«
 */
enum PermissionLevel {
  // å®‰å…¨æ“ä½œï¼ˆåªè¯»ï¼‰
  SAFE = 'safe',

  // éœ€è¦ç¡®è®¤çš„æ“ä½œï¼ˆå†™å…¥æ–‡ä»¶ç­‰ï¼‰
  REQUIRES_CONFIRMATION = 'requires_confirmation',

  // å±é™©æ“ä½œï¼ˆåˆ é™¤ã€æ‰§è¡Œå‘½ä»¤ç­‰ï¼‰
  DANGEROUS = 'dangerous',

  // ç¦æ­¢çš„æ“ä½œ
  FORBIDDEN = 'forbidden'
}

/**
 * å·¥å…·æƒé™é…ç½®
 */
interface ToolPermission {
  toolName: string;
  level: PermissionLevel;
  // ç™½åå•ï¼šå…è®¸çš„å‚æ•°æ¨¡å¼
  whitelist?: string[];
  // é»‘åå•ï¼šç¦æ­¢çš„å‚æ•°æ¨¡å¼
  blacklist?: string[];
  // æ˜¯å¦éœ€è¦ç”¨æˆ·ç¡®è®¤
  requiresConfirmation?: boolean;
}

/**
 * æƒé™ç®¡ç†å™¨
 */
class PermissionManager {
  private permissions: Map<string, ToolPermission> = new Map();

  constructor() {
    this.initializeDefaultPermissions();
  }

  /**
   * åˆå§‹åŒ–é»˜è®¤æƒé™
   */
  private initializeDefaultPermissions(): void {
    // åªè¯»å·¥å…· - å®‰å…¨
    this.setPermission({
      toolName: 'Read',
      level: PermissionLevel.SAFE
    });

    this.setPermission({
      toolName: 'Glob',
      level: PermissionLevel.SAFE
    });

    this.setPermission({
      toolName: 'Grep',
      level: PermissionLevel.SAFE
    });

    // å†™å…¥å·¥å…· - éœ€è¦ç¡®è®¤
    this.setPermission({
      toolName: 'Write',
      level: PermissionLevel.REQUIRES_CONFIRMATION,
      requiresConfirmation: true
    });

    this.setPermission({
      toolName: 'Edit',
      level: PermissionLevel.REQUIRES_CONFIRMATION,
      requiresConfirmation: true
    });

    // å‘½ä»¤æ‰§è¡Œ - å±é™©æ“ä½œ
    this.setPermission({
      toolName: 'Bash',
      level: PermissionLevel.DANGEROUS,
      requiresConfirmation: true,
      blacklist: [
        'rm -rf /',
        'mkfs',
        'dd if=/dev/zero',
        'fork bomb',
        ':(){:|:&};:',  // fork bomb
        'chmod -R 777 /',
        'sudo rm',
      ]
    });
  }

  /**
   * è®¾ç½®å·¥å…·æƒé™
   */
  setPermission(permission: ToolPermission): void {
    this.permissions.set(permission.toolName, permission);
  }

  /**
   * æ£€æŸ¥å·¥å…·è°ƒç”¨æ˜¯å¦è¢«å…è®¸
   */
  async checkPermission(
    toolName: string,
    params: Record<string, any>
  ): Promise<PermissionCheckResult> {
    const permission = this.permissions.get(toolName);

    if (!permission) {
      // é»˜è®¤ï¼šæœªçŸ¥å·¥å…·éœ€è¦ç¡®è®¤
      return {
        allowed: false,
        reason: 'Unknown tool, permission denied',
        requiresConfirmation: true
      };
    }

    // æ£€æŸ¥æ˜¯å¦è¢«ç¦æ­¢
    if (permission.level === PermissionLevel.FORBIDDEN) {
      return {
        allowed: false,
        reason: `Tool ${toolName} is forbidden`,
        requiresConfirmation: false
      };
    }

    // æ£€æŸ¥é»‘åå•
    if (permission.blacklist) {
      const blacklistViolation = this.checkBlacklist(params, permission.blacklist);
      if (blacklistViolation) {
        return {
          allowed: false,
          reason: `Blacklist violation: ${blacklistViolation}`,
          requiresConfirmation: false
        };
      }
    }

    // æ£€æŸ¥ç™½åå•
    if (permission.whitelist && permission.whitelist.length > 0) {
      const whitelistPassed = this.checkWhitelist(params, permission.whitelist);
      if (!whitelistPassed) {
        return {
          allowed: false,
          reason: 'Not in whitelist',
          requiresConfirmation: true
        };
      }
    }

    // å®‰å…¨æ“ä½œç›´æ¥å…è®¸
    if (permission.level === PermissionLevel.SAFE) {
      return {
        allowed: true,
        requiresConfirmation: false
      };
    }

    // éœ€è¦ç¡®è®¤çš„æ“ä½œ
    if (permission.requiresConfirmation) {
      // è¯·æ±‚ç”¨æˆ·ç¡®è®¤
      const userConfirmed = await this.requestUserConfirmation(toolName, params);

      return {
        allowed: userConfirmed,
        reason: userConfirmed ? undefined : 'User denied',
        requiresConfirmation: true
      };
    }

    // é»˜è®¤å…è®¸
    return {
      allowed: true,
      requiresConfirmation: false
    };
  }

  /**
   * æ£€æŸ¥é»‘åå•
   */
  private checkBlacklist(
    params: Record<string, any>,
    blacklist: string[]
  ): string | null {
    const paramsStr = JSON.stringify(params);

    for (const pattern of blacklist) {
      if (paramsStr.includes(pattern)) {
        return pattern;
      }
    }

    return null;
  }

  /**
   * æ£€æŸ¥ç™½åå•
   */
  private checkWhitelist(
    params: Record<string, any>,
    whitelist: string[]
  ): boolean {
    const paramsStr = JSON.stringify(params);

    for (const pattern of whitelist) {
      if (paramsStr.includes(pattern)) {
        return true;
      }
    }

    return false;
  }

  /**
   * è¯·æ±‚ç”¨æˆ·ç¡®è®¤
   */
  private async requestUserConfirmation(
    toolName: string,
    params: Record<string, any>
  ): Promise<boolean> {
    console.log(`\nâš ï¸  Tool ${toolName} requires confirmation`);
    console.log(`Parameters:`, JSON.stringify(params, null, 2));
    console.log(`\nDo you want to proceed? (yes/no)`);

    // è¯»å–ç”¨æˆ·è¾“å…¥
    const answer = await this.readUserInput();

    return answer.toLowerCase() === 'yes' || answer.toLowerCase() === 'y';
  }

  /**
   * è¯»å–ç”¨æˆ·è¾“å…¥
   */
  private async readUserInput(): Promise<string> {
    return new Promise((resolve) => {
      const readline = require('readline');
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      rl.question('> ', (answer: string) => {
        rl.close();
        resolve(answer.trim());
      });
    });
  }
}

/**
 * æƒé™æ£€æŸ¥ç»“æœ
 */
interface PermissionCheckResult {
  allowed: boolean;
  reason?: string;
  requiresConfirmation: boolean;
}
```

---

## å…­ã€å·¥å…·è°ƒç”¨æµç¨‹

### 6.1 å®Œæ•´è°ƒç”¨æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant AI as Claude AI
    participant Dispatcher as å·¥å…·è°ƒåº¦å™¨
    participant Registry as å·¥å…·æ³¨å†Œè¡¨
    participant Validator as å‚æ•°éªŒè¯å™¨
    participant Permission as æƒé™ç®¡ç†å™¨
    participant Executor as å·¥å…·æ‰§è¡Œå™¨
    participant User as ç”¨æˆ·

    AI->>Dispatcher: Tool Call Request
    Note over AI,Dispatcher: tool_name: "Read"<br/>input: {file_path: "..."}

    Dispatcher->>Registry: æŸ¥æ‰¾å·¥å…·
    Registry-->>Dispatcher: è¿”å›å·¥å…·å®šä¹‰å’Œæ‰§è¡Œå™¨

    alt å·¥å…·ä¸å­˜åœ¨
        Dispatcher-->>AI: é”™è¯¯ï¼šå·¥å…·æœªæ‰¾åˆ°
    end

    Dispatcher->>Validator: éªŒè¯å‚æ•°
    Validator->>Validator: æ£€æŸ¥å¿…éœ€å‚æ•°
    Validator->>Validator: æ£€æŸ¥ç±»å‹
    Validator-->>Dispatcher: éªŒè¯ç»“æœ

    alt éªŒè¯å¤±è´¥
        Dispatcher-->>AI: é”™è¯¯ï¼šå‚æ•°æ— æ•ˆ
    end

    Dispatcher->>Permission: æ£€æŸ¥æƒé™
    Permission->>Permission: æ£€æŸ¥é»‘åå•
    Permission->>Permission: æ£€æŸ¥ç™½åå•

    alt éœ€è¦ç”¨æˆ·ç¡®è®¤
        Permission->>User: è¯·æ±‚ç¡®è®¤
        User-->>Permission: ç¡®è®¤/æ‹’ç»
    end

    Permission-->>Dispatcher: æƒé™æ£€æŸ¥ç»“æœ

    alt æƒé™è¢«æ‹’ç»
        Dispatcher-->>AI: é”™è¯¯ï¼šæƒé™è¢«æ‹’ç»
    end

    Dispatcher->>Executor: æ‰§è¡Œå·¥å…·
    Executor->>Executor: å®é™…æ“ä½œ<br/>ï¼ˆè¯»æ–‡ä»¶/æ‰§è¡Œå‘½ä»¤ç­‰ï¼‰

    alt æ‰§è¡ŒæˆåŠŸ
        Executor-->>Dispatcher: æˆåŠŸç»“æœ
        Dispatcher-->>AI: è¿”å›ç»“æœ
    else æ‰§è¡Œå¤±è´¥
        Executor-->>Dispatcher: é”™è¯¯ä¿¡æ¯
        Dispatcher-->>AI: è¿”å›é”™è¯¯
    end
```

### 6.2 å·¥å…·è°ƒåº¦å™¨å®ç°

```typescript
/**
 * å·¥å…·è°ƒåº¦å™¨
 * è´Ÿè´£åè°ƒå·¥å…·è°ƒç”¨çš„æ•´ä¸ªæµç¨‹
 */
class ToolDispatcher {
  private registry: ToolRegistry;
  private validator: ParameterValidator;
  private permissionManager: PermissionManager;

  constructor(
    registry: ToolRegistry,
    validator: ParameterValidator,
    permissionManager: PermissionManager
  ) {
    this.registry = registry;
    this.validator = validator;
    this.permissionManager = permissionManager;
  }

  /**
   * æ‰§è¡Œå·¥å…·è°ƒç”¨
   * @param toolCall AI çš„å·¥å…·è°ƒç”¨è¯·æ±‚
   * @returns å·¥å…·æ‰§è¡Œç»“æœ
   */
  async execute(toolCall: ToolCall): Promise<ToolResult> {
    const { name, input } = toolCall;

    try {
      // 1. æŸ¥æ‰¾å·¥å…·
      const executor = this.registry.getExecutor(name);
      if (!executor) {
        return {
          success: false,
          error: `Tool not found: ${name}`
        };
      }

      const definition = this.registry.getAllDefinitions().find(d => d.name === name);
      if (!definition) {
        return {
          success: false,
          error: `Tool definition not found: ${name}`
        };
      }

      // 2. éªŒè¯å‚æ•°
      const validationResult = this.validator.validate(
        name,
        input,
        definition.input_schema
      );

      if (!validationResult.valid) {
        return {
          success: false,
          error: `Parameter validation failed:\n${validationResult.errors.join('\n')}`
        };
      }

      // 3. æ£€æŸ¥æƒé™
      const permissionResult = await this.permissionManager.checkPermission(name, input);

      if (!permissionResult.allowed) {
        return {
          success: false,
          error: `Permission denied: ${permissionResult.reason || 'Unknown reason'}`
        };
      }

      // 4. æ‰§è¡Œå·¥å…·
      console.log(`ğŸ”§ Executing tool: ${name}`);
      const startTime = Date.now();

      const result = await executor.execute(input);

      const duration = Date.now() - startTime;
      console.log(`âœ… Tool ${name} completed in ${duration}ms`);

      return result;

    } catch (error) {
      console.error(`âŒ Tool ${name} failed:`, error);

      return {
        success: false,
        error: `Tool execution failed: ${error.message}`
      };
    }
  }

  /**
   * æ‰¹é‡æ‰§è¡Œå·¥å…·è°ƒç”¨
   * @param toolCalls å¤šä¸ªå·¥å…·è°ƒç”¨
   * @returns æ‰€æœ‰å·¥å…·çš„æ‰§è¡Œç»“æœ
   */
  async executeBatch(toolCalls: ToolCall[]): Promise<ToolResult[]> {
    // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å·¥å…·è°ƒç”¨
    return Promise.all(
      toolCalls.map(toolCall => this.execute(toolCall))
    );
  }
}

/**
 * å·¥å…·è°ƒç”¨è¯·æ±‚ï¼ˆæ¥è‡ªAIï¼‰
 */
interface ToolCall {
  id: string;
  type: 'tool_use';
  name: string;
  input: Record<string, any>;
}
```

### 6.3 ç«¯åˆ°ç«¯ç¤ºä¾‹

```typescript
// å®Œæ•´çš„å·¥å…·è°ƒç”¨ç¤ºä¾‹
async function exampleToolCallFlow() {
  // 1. åˆå§‹åŒ–ç³»ç»Ÿ
  const registry = new ToolRegistry();
  const validator = new ParameterValidator();
  const permissionManager = new PermissionManager();
  const dispatcher = new ToolDispatcher(registry, validator, permissionManager);

  // 2. æ³¨å†Œå·¥å…·
  registerBuiltInTools(registry);

  // 3. AI å‘èµ·å·¥å…·è°ƒç”¨
  const toolCall: ToolCall = {
    id: 'tool_call_123',
    type: 'tool_use',
    name: 'Read',
    input: {
      file_path: '/Users/user/project/src/index.ts',
      offset: 0,
      limit: 50
    }
  };

  // 4. æ‰§è¡Œå·¥å…·
  const result = await dispatcher.execute(toolCall);

  // 5. å¤„ç†ç»“æœ
  if (result.success) {
    console.log('æ–‡ä»¶å†…å®¹ï¼š');
    console.log(result.content);
  } else {
    console.error('æ‰§è¡Œå¤±è´¥ï¼š', result.error);
  }
}
```

---

## ä¸ƒã€å†…ç½®å·¥å…·è¯¦è§£

### 7.1 Read å·¥å…·å®ç°

```typescript
/**
 * Read å·¥å…·æ‰§è¡Œå™¨
 * è¯»å–æ–‡ä»¶å†…å®¹ï¼Œæ”¯æŒåç§»å’Œé™åˆ¶
 */
class ReadToolExecutor implements ToolExecutor {
  async execute(input: Record<string, any>): Promise<ToolResult> {
    const { file_path, offset = 0, limit } = input;

    try {
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(file_path)) {
        return {
          success: false,
          error: `File not found: ${file_path}`
        };
      }

      // æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶ï¼ˆä¸æ˜¯ç›®å½•ï¼‰
      const stat = fs.statSync(file_path);
      if (stat.isDirectory()) {
        return {
          success: false,
          error: `Path is a directory, not a file: ${file_path}`
        };
      }

      // è¯»å–æ–‡ä»¶å†…å®¹
      const content = fs.readFileSync(file_path, 'utf-8');
      const lines = content.split('\n');

      // åº”ç”¨åç§»å’Œé™åˆ¶
      const selectedLines = limit
        ? lines.slice(offset, offset + limit)
        : lines.slice(offset);

      // æ·»åŠ è¡Œå·ï¼ˆcat -n æ ¼å¼ï¼‰
      const numberedLines = selectedLines.map((line, idx) => {
        const lineNumber = offset + idx + 1;
        // æˆªæ–­è¿‡é•¿çš„è¡Œ
        const truncatedLine = line.length > 2000
          ? line.substring(0, 2000) + '... [truncated]'
          : line;
        return `${lineNumber}\t${truncatedLine}`;
      });

      return {
        success: true,
        content: numberedLines.join('\n'),
        metadata: {
          totalLines: lines.length,
          returnedLines: selectedLines.length,
          file_path
        }
      };

    } catch (error) {
      return {
        success: false,
        error: `Failed to read file: ${error.message}`
      };
    }
  }
}
```

### 7.2 Write å·¥å…·å®ç°

```typescript
/**
 * Write å·¥å…·æ‰§è¡Œå™¨
 * å†™å…¥æ–‡ä»¶ï¼Œä¼šè¦†ç›–ç°æœ‰å†…å®¹
 */
class WriteToolExecutor implements ToolExecutor {
  async execute(input: Record<string, any>): Promise<ToolResult> {
    const { file_path, content } = input;

    try {
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆå¦‚æœå­˜åœ¨éœ€è¦å…ˆè¯»å–ï¼‰
      if (fs.existsSync(file_path)) {
        // éªŒè¯æ˜¯å¦åœ¨ä¹‹å‰è¯»å–è¿‡è¯¥æ–‡ä»¶
        // è¿™æ˜¯ä¸€ä¸ªå®‰å…¨æªæ–½ï¼Œé˜²æ­¢æ„å¤–è¦†ç›–
        const shouldProceed = await this.verifyFileWasRead(file_path);
        if (!shouldProceed) {
          return {
            success: false,
            error: `File exists but was not read first. Use Read tool before Write.`
          };
        }

        // åˆ›å»ºå¤‡ä»½
        await this.createBackup(file_path);
      }

      // ç¡®ä¿ç›®å½•å­˜åœ¨
      const dir = path.dirname(file_path);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // å†™å…¥æ–‡ä»¶
      fs.writeFileSync(file_path, content, 'utf-8');

      return {
        success: true,
        content: `File written successfully: ${file_path}`,
        metadata: {
          file_path,
          bytes: Buffer.byteLength(content, 'utf-8')
        }
      };

    } catch (error) {
      return {
        success: false,
        error: `Failed to write file: ${error.message}`
      };
    }
  }

  /**
   * éªŒè¯æ–‡ä»¶æ˜¯å¦è¢«è¯»å–è¿‡
   */
  private async verifyFileWasRead(filePath: string): Promise<boolean> {
    // åœ¨å®é™…å®ç°ä¸­ï¼Œéœ€è¦æ£€æŸ¥ä¼šè¯å†å²
    // è¿™é‡Œç®€åŒ–ä¸ºæ€»æ˜¯è¿”å› true
    return true;
  }

  /**
   * åˆ›å»ºæ–‡ä»¶å¤‡ä»½
   */
  private async createBackup(filePath: string): Promise<void> {
    const backupPath = `${filePath}.backup`;
    fs.copyFileSync(filePath, backupPath);
    console.log(`ğŸ“¦ Created backup: ${backupPath}`);
  }
}
```

### 7.3 Edit å·¥å…·å®ç°

```typescript
/**
 * Edit å·¥å…·æ‰§è¡Œå™¨
 * ç²¾ç¡®å­—ç¬¦ä¸²æ›¿æ¢
 */
class EditToolExecutor implements ToolExecutor {
  async execute(input: Record<string, any>): Promise<ToolResult> {
    const { file_path, old_string, new_string, replace_all = false } = input;

    try {
      // è¯»å–æ–‡ä»¶å†…å®¹
      if (!fs.existsSync(file_path)) {
        return {
          success: false,
          error: `File not found: ${file_path}`
        };
      }

      const content = fs.readFileSync(file_path, 'utf-8');

      // æ£€æŸ¥ old_string æ˜¯å¦å­˜åœ¨
      if (!content.includes(old_string)) {
        return {
          success: false,
          error: `String not found in file: "${old_string}"`
        };
      }

      // æ£€æŸ¥å”¯ä¸€æ€§ï¼ˆå¦‚æœä¸æ˜¯ replace_allï¼‰
      if (!replace_all) {
        const occurrences = (content.match(new RegExp(this.escapeRegex(old_string), 'g')) || []).length;
        if (occurrences > 1) {
          return {
            success: false,
            error: `String appears ${occurrences} times in file. Use replace_all=true or provide more context to make it unique.`
          };
        }
      }

      // æ‰§è¡Œæ›¿æ¢
      let newContent: string;
      if (replace_all) {
        newContent = content.split(old_string).join(new_string);
      } else {
        newContent = content.replace(old_string, new_string);
      }

      // å†™å…¥æ–‡ä»¶
      fs.writeFileSync(file_path, newContent, 'utf-8');

      return {
        success: true,
        content: `Successfully replaced string in ${file_path}`,
        metadata: {
          file_path,
          replacements: replace_all ? 'all' : 1
        }
      };

    } catch (error) {
      return {
        success: false,
        error: `Failed to edit file: ${error.message}`
      };
    }
  }

  /**
   * è½¬ä¹‰æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦
   */
  private escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}
```

### 7.4 Bash å·¥å…·å®ç°

```typescript
/**
 * Bash å·¥å…·æ‰§è¡Œå™¨
 * æ‰§è¡Œ shell å‘½ä»¤
 */
class BashToolExecutor implements ToolExecutor {
  private sessions: Map<string, ChildProcess> = new Map();

  async execute(input: Record<string, any>): Promise<ToolResult> {
    const {
      command,
      description,
      timeout = 120000,
      run_in_background = false
    } = input;

    try {
      console.log(`ğŸ’» Executing: ${description || command}`);

      if (run_in_background) {
        return await this.executeInBackground(command, timeout);
      } else {
        return await this.executeSync(command, timeout);
      }

    } catch (error) {
      return {
        success: false,
        error: `Command execution failed: ${error.message}`
      };
    }
  }

  /**
   * åŒæ­¥æ‰§è¡Œå‘½ä»¤
   */
  private async executeSync(command: string, timeout: number): Promise<ToolResult> {
    return new Promise((resolve) => {
      const child = spawn('/bin/bash', ['-c', command], {
        timeout,
        maxBuffer: 10 * 1024 * 1024 // 10MB
      });

      let stdout = '';
      let stderr = '';

      child.stdout?.on('data', (data) => {
        const chunk = data.toString();
        stdout += chunk;
        // å®æ—¶è¾“å‡º
        process.stdout.write(chunk);
      });

      child.stderr?.on('data', (data) => {
        const chunk = data.toString();
        stderr += chunk;
        process.stderr.write(chunk);
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve({
            success: true,
            content: stdout,
            metadata: {
              exitCode: code,
              stderr: stderr || undefined
            }
          });
        } else {
          resolve({
            success: false,
            error: `Command exited with code ${code}\n${stderr}`,
            metadata: {
              exitCode: code,
              stdout: stdout || undefined
            }
          });
        }
      });

      child.on('error', (error) => {
        resolve({
          success: false,
          error: `Failed to execute command: ${error.message}`
        });
      });
    });
  }

  /**
   * åå°æ‰§è¡Œå‘½ä»¤
   */
  private async executeInBackground(command: string, timeout: number): Promise<ToolResult> {
    const sessionId = `bash_${Date.now()}`;

    const child = spawn('/bin/bash', ['-c', command], {
      timeout,
      detached: true,
      stdio: ['ignore', 'pipe', 'pipe']
    });

    // ä¿å­˜ä¼šè¯
    this.sessions.set(sessionId, child);

    // åå°è¿è¡Œï¼Œä¸ç­‰å¾…ç»“æœ
    child.unref();

    return {
      success: true,
      content: `Command started in background (session: ${sessionId})`,
      metadata: {
        sessionId,
        pid: child.pid
      }
    };
  }
}
```

### 7.5 Glob å·¥å…·å®ç°

```typescript
/**
 * Glob å·¥å…·æ‰§è¡Œå™¨
 * æ–‡ä»¶æ¨¡å¼åŒ¹é…
 */
class GlobToolExecutor implements ToolExecutor {
  async execute(input: Record<string, any>): Promise<ToolResult> {
    const { pattern, path: searchPath = process.cwd() } = input;

    try {
      // ä½¿ç”¨ fast-glob åº“
      const fg = require('fast-glob');

      const files = await fg(pattern, {
        cwd: searchPath,
        absolute: true,
        dot: false,
        ignore: ['node_modules/**', '.git/**', 'dist/**', 'build/**']
      });

      // æŒ‰ä¿®æ”¹æ—¶é—´æ’åº
      const filesWithStats = await Promise.all(
        files.map(async (file: string) => {
          const stat = fs.statSync(file);
          return {
            path: file,
            mtime: stat.mtimeMs
          };
        })
      );

      filesWithStats.sort((a, b) => b.mtime - a.mtime);

      const sortedFiles = filesWithStats.map(f => f.path);

      return {
        success: true,
        content: sortedFiles.join('\n'),
        metadata: {
          count: sortedFiles.length,
          pattern
        }
      };

    } catch (error) {
      return {
        success: false,
        error: `Glob search failed: ${error.message}`
      };
    }
  }
}
```

### 7.6 Grep å·¥å…·å®ç°

```typescript
/**
 * Grep å·¥å…·æ‰§è¡Œå™¨
 * å†…å®¹æœç´¢ï¼ˆåŸºäº ripgrepï¼‰
 */
class GrepToolExecutor implements ToolExecutor {
  async execute(input: Record<string, any>): Promise<ToolResult> {
    const {
      pattern,
      path: searchPath = process.cwd(),
      glob,
      type,
      output_mode = 'files_with_matches',
      '-i': caseInsensitive = false,
      '-n': lineNumbers = false,
      '-A': after = 0,
      '-B': before = 0,
      '-C': context = 0,
      head_limit,
      multiline = false
    } = input;

    try {
      // æ„é€  ripgrep å‘½ä»¤
      const args: string[] = [pattern];

      // æœç´¢è·¯å¾„
      args.push(searchPath);

      // è¾“å‡ºæ¨¡å¼
      if (output_mode === 'files_with_matches') {
        args.push('--files-with-matches');
      } else if (output_mode === 'count') {
        args.push('--count');
      }

      // å…¶ä»–é€‰é¡¹
      if (caseInsensitive) args.push('-i');
      if (lineNumbers && output_mode === 'content') args.push('-n');
      if (after && output_mode === 'content') args.push(`-A${after}`);
      if (before && output_mode === 'content') args.push(`-B${before}`);
      if (context && output_mode === 'content') args.push(`-C${context}`);
      if (multiline) args.push('-U', '--multiline-dotall');

      // æ–‡ä»¶è¿‡æ»¤
      if (glob) args.push('--glob', glob);
      if (type) args.push('--type', type);

      // é™åˆ¶ç»“æœæ•°é‡
      if (head_limit) args.push('--max-count', String(head_limit));

      // æ‰§è¡Œ ripgrep
      const child = spawn('rg', args);

      let stdout = '';
      let stderr = '';

      child.stdout?.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      const result = await new Promise<ToolResult>((resolve) => {
        child.on('close', (code) => {
          if (code === 0 || code === 1) {
            // code 1 è¡¨ç¤ºæ²¡æœ‰åŒ¹é…ï¼Œè¿™ä¸æ˜¯é”™è¯¯
            resolve({
              success: true,
              content: stdout || 'No matches found',
              metadata: {
                pattern,
                matches: stdout.split('\n').filter(l => l).length
              }
            });
          } else {
            resolve({
              success: false,
              error: `ripgrep failed with code ${code}\n${stderr}`
            });
          }
        });
      });

      return result;

    } catch (error) {
      return {
        success: false,
        error: `Grep search failed: ${error.message}`
      };
    }
  }
}
```

---

## å…«ã€æœ€ä½³å®è·µ

### 8.1 å·¥å…·è®¾è®¡åŸåˆ™

**1. å•ä¸€èŒè´£**
```typescript
// âŒ ä¸å¥½ï¼šä¸€ä¸ªå·¥å…·åšå¤ªå¤šäº‹æƒ…
{
  name: 'FileManager',
  description: 'Manage files: read, write, delete, move, etc.'
}

// âœ… å¥½ï¼šæ¯ä¸ªå·¥å…·èŒè´£å•ä¸€
{
  name: 'Read',
  description: 'Reads a file from the filesystem'
}
```

**2. æ¸…æ™°çš„æ¥å£**
```typescript
// âœ… å¥½çš„å·¥å…·å®šä¹‰
{
  name: 'SearchCode',
  description: 'Search for patterns in code using regular expressions',
  input_schema: {
    type: 'object',
    properties: {
      pattern: {
        type: 'string',
        description: 'Regular expression pattern to search for'
      },
      path: {
        type: 'string',
        description: 'Directory to search in (default: current directory)'
      },
      file_type: {
        type: 'string',
        description: 'File type filter (e.g., "ts", "js", "py")',
        enum: ['ts', 'js', 'py', 'java', 'go']
      }
    },
    required: ['pattern']
  }
}
```

**3. è¯¦ç»†çš„é”™è¯¯å¤„ç†**
```typescript
async execute(input: Record<string, any>): Promise<ToolResult> {
  try {
    // æ‰§è¡Œé€»è¾‘
  } catch (error) {
    // æä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
    return {
      success: false,
      error: `Failed to execute tool: ${error.message}\n\nSuggestion: Check if the file exists and you have read permissions.`
    };
  }
}
```

### 8.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

**1. å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹å·¥å…·**
```typescript
// å½“å¤šä¸ªå·¥å…·è°ƒç”¨ç›¸äº’ç‹¬ç«‹æ—¶ï¼Œå¹¶è¡Œæ‰§è¡Œ
async function optimizedExecution(toolCalls: ToolCall[]) {
  // åˆ†æä¾èµ–å…³ç³»
  const independent = toolCalls.filter(call => !hasDependencies(call));
  const dependent = toolCalls.filter(call => hasDependencies(call));

  // å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹å·¥å…·
  const independentResults = await Promise.all(
    independent.map(call => dispatcher.execute(call))
  );

  // é¡ºåºæ‰§è¡Œæœ‰ä¾èµ–çš„å·¥å…·
  const dependentResults = [];
  for (const call of dependent) {
    const result = await dispatcher.execute(call);
    dependentResults.push(result);
  }

  return [...independentResults, ...dependentResults];
}
```

**2. ç»“æœç¼“å­˜**
```typescript
class CachedToolExecutor implements ToolExecutor {
  private cache: Map<string, { result: ToolResult; timestamp: number }> = new Map();
  private ttl = 5 * 60 * 1000; // 5åˆ†é’Ÿ

  async execute(input: Record<string, any>): Promise<ToolResult> {
    const cacheKey = this.getCacheKey(input);

    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      console.log('âœ… Returning cached result');
      return cached.result;
    }

    // æ‰§è¡Œå·¥å…·
    const result = await this.actualExecute(input);

    // ç¼“å­˜ç»“æœ
    this.cache.set(cacheKey, {
      result,
      timestamp: Date.now()
    });

    return result;
  }

  private getCacheKey(input: Record<string, any>): string {
    return JSON.stringify(input);
  }
}
```

### 8.3 å®‰å…¨å»ºè®®

**1. è¾“å…¥éªŒè¯**
```typescript
// å§‹ç»ˆéªŒè¯å’Œæ¸…ç†è¾“å…¥
function sanitizeInput(input: string): string {
  // ç§»é™¤å±é™©å­—ç¬¦
  return input.replace(/[;&|`$]/g, '');
}
```

**2. è·¯å¾„éªŒè¯**
```typescript
function validatePath(filePath: string, workspaceRoot: string): boolean {
  const resolved = path.resolve(filePath);

  // ç¡®ä¿åœ¨å·¥ä½œåŒºå†…
  if (!resolved.startsWith(workspaceRoot)) {
    throw new Error('Access denied: path outside workspace');
  }

  // æ£€æŸ¥è·¯å¾„éå†æ”»å‡»
  if (filePath.includes('..')) {
    throw new Error('Invalid path: contains ".."');
  }

  return true;
}
```

---

## ä¹ã€å¸¸è§é—®é¢˜ FAQ

### Q1: å¦‚ä½•æ·»åŠ è‡ªå®šä¹‰å·¥å…·ï¼Ÿ

A: æœ‰ä¸¤ç§æ–¹å¼ï¼š

**æ–¹å¼1ï¼šç›´æ¥æ³¨å†Œåˆ°å·¥å…·ç³»ç»Ÿ**
```typescript
// å®šä¹‰å·¥å…·
const myTool: ToolDefinition = {
  name: 'MyCustomTool',
  description: 'My custom tool description',
  input_schema: { /* ... */ }
};

// å®ç°æ‰§è¡Œå™¨
class MyToolExecutor implements ToolExecutor {
  async execute(input: any): Promise<ToolResult> {
    // å®ç°é€»è¾‘
  }
}

// æ³¨å†Œ
toolRegistry.register(myTool, new MyToolExecutor());
```

**æ–¹å¼2ï¼šå¼€å‘ MCP Serverï¼ˆæ¨èï¼‰**

å‚è€ƒç¬¬9ç¯‡ã€ŠMCPåè®®æ·±å…¥è§£æã€‹å’Œç¬¬18ç¯‡ã€ŠMCP Serverå¼€å‘å®æˆ˜ã€‹ã€‚

### Q2: å·¥å…·è°ƒç”¨å¤±è´¥å¦‚ä½•å¤„ç†ï¼Ÿ

A: Claude Code ä¼šå°†é”™è¯¯è¿”å›ç»™ AIï¼ŒAI ä¼šå°è¯•ï¼š
1. ç†è§£é”™è¯¯åŸå› 
2. ä¿®æ­£å‚æ•°é‡è¯•
3. é€‰æ‹©å…¶ä»–å·¥å…·
4. å‘ç”¨æˆ·è¯·æ±‚å¸®åŠ©

### Q3: å¯ä»¥é™åˆ¶å·¥å…·çš„æ‰§è¡Œé¢‘ç‡å—ï¼Ÿ

A: å¯ä»¥å®ç°ä¸€ä¸ªé€Ÿç‡é™åˆ¶å™¨ï¼š

```typescript
class RateLimitedExecutor implements ToolExecutor {
  private lastExecutionTime = 0;
  private minInterval = 1000; // æœ€å°é—´éš” 1 ç§’

  async execute(input: any): Promise<ToolResult> {
    const now = Date.now();
    const elapsed = now - this.lastExecutionTime;

    if (elapsed < this.minInterval) {
      await new Promise(resolve =>
        setTimeout(resolve, this.minInterval - elapsed)
      );
    }

    this.lastExecutionTime = Date.now();
    return this.actualExecute(input);
  }
}
```

### Q4: å·¥å…·æ‰§è¡Œè¶…æ—¶æ€ä¹ˆåŠï¼Ÿ

A: è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´ï¼Œå¹¶å®ç°è¶…æ—¶å¤„ç†ï¼š

```typescript
async function executeWithTimeout(
  executor: ToolExecutor,
  input: any,
  timeout: number
): Promise<ToolResult> {
  return Promise.race([
    executor.execute(input),
    new Promise<ToolResult>((_, reject) =>
      setTimeout(() => reject(new Error('Tool execution timeout')), timeout)
    )
  ]);
}
```

### Q5: å¦‚ä½•è°ƒè¯•å·¥å…·è°ƒç”¨ï¼Ÿ

A: æ·»åŠ è¯¦ç»†çš„æ—¥å¿—ï¼š

```typescript
class LoggingExecutor implements ToolExecutor {
  constructor(private inner: ToolExecutor, private toolName: string) {}

  async execute(input: any): Promise<ToolResult> {
    console.log(`[${this.toolName}] Input:`, JSON.stringify(input, null, 2));

    const startTime = Date.now();
    const result = await this.inner.execute(input);
    const duration = Date.now() - startTime;

    console.log(`[${this.toolName}] Result:`, {
      success: result.success,
      duration: `${duration}ms`
    });

    if (!result.success) {
      console.error(`[${this.toolName}] Error:`, result.error);
    }

    return result;
  }
}
```

---

## åã€å®æˆ˜ç»ƒä¹ ï¼šåˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰å·¥å…·

### ç»ƒä¹ ç›®æ ‡

åˆ›å»ºä¸€ä¸ª `FileSearch` å·¥å…·ï¼Œå®ç°æ–‡ä»¶å†…å®¹æœç´¢å’Œæ›¿æ¢åŠŸèƒ½ã€‚

### ç»ƒä¹ æ­¥éª¤

**1. å®šä¹‰å·¥å…· Schema**

```typescript
const FileSearchToolDefinition: ToolDefinition = {
  name: 'FileSearch',
  description: `Search and optionally replace text in files.

Usage:
- Searches for a pattern across multiple files
- Supports regular expressions
- Can preview changes before replacing
- Returns list of matches with line numbers`,

  input_schema: {
    type: 'object',
    properties: {
      pattern: {
        type: 'string',
        description: 'Pattern to search for (supports regex)'
      },
      path: {
        type: 'string',
        description: 'Directory to search in'
      },
      file_glob: {
        type: 'string',
        description: 'File pattern (e.g., "*.ts")',
        default: '*'
      },
      replace_with: {
        type: 'string',
        description: 'Replacement text (optional, for search and replace)'
      },
      preview_only: {
        type: 'boolean',
        description: 'Only preview changes without applying them',
        default: true
      }
    },
    required: ['pattern', 'path']
  }
};
```

**2. å®ç°æ‰§è¡Œå™¨**

```typescript
class FileSearchExecutor implements ToolExecutor {
  async execute(input: Record<string, any>): Promise<ToolResult> {
    const {
      pattern,
      path: searchPath,
      file_glob = '*',
      replace_with,
      preview_only = true
    } = input;

    try {
      // 1. æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶
      const fg = require('fast-glob');
      const files = await fg(file_glob, {
        cwd: searchPath,
        absolute: true
      });

      // 2. æœç´¢æ¯ä¸ªæ–‡ä»¶
      const matches: SearchMatch[] = [];
      const regex = new RegExp(pattern, 'g');

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf-8');
        const lines = content.split('\n');

        lines.forEach((line, idx) => {
          if (regex.test(line)) {
            matches.push({
              file,
              lineNumber: idx + 1,
              line,
              match: pattern
            });
          }
          regex.lastIndex = 0; // é‡ç½®æ­£åˆ™
        });
      }

      // 3. å¦‚æœæ˜¯æ›¿æ¢æ“ä½œ
      if (replace_with && !preview_only) {
        for (const match of matches) {
          const content = fs.readFileSync(match.file, 'utf-8');
          const newContent = content.replace(new RegExp(pattern, 'g'), replace_with);
          fs.writeFileSync(match.file, newContent, 'utf-8');
        }
      }

      // 4. æ ¼å¼åŒ–è¾“å‡º
      const output = this.formatMatches(matches, replace_with, preview_only);

      return {
        success: true,
        content: output,
        metadata: {
          totalMatches: matches.length,
          filesSearched: files.length,
          replaced: !preview_only && !!replace_with
        }
      };

    } catch (error) {
      return {
        success: false,
        error: `File search failed: ${error.message}`
      };
    }
  }

  private formatMatches(
    matches: SearchMatch[],
    replaceWith?: string,
    previewOnly?: boolean
  ): string {
    if (matches.length === 0) {
      return 'No matches found';
    }

    let output = `Found ${matches.length} matches:\n\n`;

    for (const match of matches) {
      output += `${match.file}:${match.lineNumber}\n`;
      output += `  ${match.line}\n`;

      if (replaceWith) {
        const preview = match.line.replace(
          new RegExp(match.match, 'g'),
          replaceWith
        );
        output += `  â†’ ${preview}\n`;
      }

      output += '\n';
    }

    if (replaceWith && previewOnly) {
      output += '\nâš ï¸  Preview only. Set preview_only=false to apply changes.';
    }

    return output;
  }
}

interface SearchMatch {
  file: string;
  lineNumber: number;
  line: string;
  match: string;
}
```

**3. æ³¨å†Œå’Œæµ‹è¯•**

```typescript
// æ³¨å†Œå·¥å…·
toolRegistry.register(FileSearchToolDefinition, new FileSearchExecutor());

// æµ‹è¯•å·¥å…·
const testCall: ToolCall = {
  id: 'test_1',
  type: 'tool_use',
  name: 'FileSearch',
  input: {
    pattern: 'TODO',
    path: '/Users/user/project/src',
    file_glob: '**/*.ts',
    preview_only: true
  }
};

const result = await dispatcher.execute(testCall);
console.log(result.content);
```

### ç»ƒä¹ æ‰©å±•

1. æ·»åŠ æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•éªŒè¯
2. æ”¯æŒå¤šè¡ŒåŒ¹é…
3. æ·»åŠ æ’é™¤æ¨¡å¼ï¼ˆå¿½ç•¥æŸäº›æ–‡ä»¶ï¼‰
4. å®ç°æ‰¹é‡æ›¿æ¢çš„æ’¤é”€åŠŸèƒ½
5. æ·»åŠ è¿›åº¦æ˜¾ç¤ºï¼ˆå¤§å‹æœç´¢ï¼‰

---

## åä¸€ã€æ€»ç»“

å·¥å…·ç³»ç»Ÿæ˜¯ Claude Code çš„æ ¸å¿ƒèƒ½åŠ›ä¹‹ä¸€ï¼Œæœ¬æ–‡æ·±å…¥æ¢è®¨äº†ï¼š

âœ… **æ•´ä½“æ¶æ„**ï¼šå››å±‚æ¶æ„ï¼ŒèŒè´£æ¸…æ™°
âœ… **Tool Schema**ï¼šæ ‡å‡†åŒ–çš„å·¥å…·å®šä¹‰è§„èŒƒ
âœ… **æ³¨å†Œæœºåˆ¶**ï¼šçµæ´»çš„å·¥å…·å‘ç°å’Œç®¡ç†
âœ… **å‚æ•°éªŒè¯**ï¼šå®Œå–„çš„ç±»å‹æ£€æŸ¥å’ŒéªŒè¯
âœ… **æƒé™ç®¡ç†**ï¼šå¤šå±‚æ¬¡çš„å®‰å…¨æœºåˆ¶
âœ… **è°ƒç”¨æµç¨‹**ï¼šå®Œæ•´çš„å·¥å…·æ‰§è¡Œæµç¨‹
âœ… **å†…ç½®å·¥å…·**ï¼šå…­å¤§æ ¸å¿ƒå·¥å…·çš„å®ç°ç»†èŠ‚
âœ… **æœ€ä½³å®è·µ**ï¼šè®¾è®¡åŸåˆ™å’Œä¼˜åŒ–å»ºè®®
âœ… **å®æˆ˜ç»ƒä¹ **ï¼šè‡ªå®šä¹‰å·¥å…·å¼€å‘

### å…³é”®è¦ç‚¹

1. **æ ‡å‡†åŒ–æ¥å£**ï¼šJSON Schema ç¡®ä¿å·¥å…·å®šä¹‰æ¸…æ™°ä¸€è‡´
2. **åˆ†å±‚è®¾è®¡**ï¼šè°ƒåº¦ã€éªŒè¯ã€æƒé™ã€æ‰§è¡Œå„å±‚èŒè´£æ˜ç¡®
3. **å®‰å…¨ä¼˜å…ˆ**ï¼šå¤šé‡å®‰å…¨æœºåˆ¶é˜²æ­¢å±é™©æ“ä½œ
4. **å¯æ‰©å±•æ€§**ï¼šæ’ä»¶åŒ–è®¾è®¡æ”¯æŒæ— é™æ‰©å±•
5. **ç”¨æˆ·ä½“éªŒ**ï¼šæ¸…æ™°çš„é”™è¯¯æç¤ºå’Œç¡®è®¤æœºåˆ¶

---

## åäºŒã€ä¸‹ä¸€ç¯‡é¢„å‘Š

åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ **[æ–‡ä»¶æ“ä½œå·¥å…·å®ç°](./06-æ–‡ä»¶æ“ä½œå·¥å…·å®ç°.md)**ï¼ŒåŒ…æ‹¬ï¼š
- Read å·¥å…·çš„é«˜çº§ç‰¹æ€§ï¼ˆåˆ†é¡µã€ç¼“å­˜ã€å¢é‡è¯»å–ï¼‰
- Write å·¥å…·çš„å¤‡ä»½å’Œå›æ»šæœºåˆ¶
- Edit å·¥å…·çš„å†²çªæ£€æµ‹å’Œæ™ºèƒ½åˆå¹¶
- æ–‡ä»¶ç›‘å¬å’Œå˜æ›´æ£€æµ‹
- å®‰å…¨æ²™ç®±æœºåˆ¶è®¾è®¡

æ•¬è¯·æœŸå¾…ï¼ ğŸš€

---

**å¦‚æœè§‰å¾—è¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼Œæ¬¢è¿åˆ†äº«ç»™æ›´å¤šçš„æœ‹å‹ï¼**
