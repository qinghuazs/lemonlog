---
title: Claude Codeæ¶æ„è¯¦è§£ï¼ˆå››ï¼‰ï¼šä¼šè¯ä¸çŠ¶æ€ç®¡ç†
date: 2025-01-15
permalink: /ai/claude-code/architecture/04-session-management.html
tags:
  - Claude Code
  - ä¼šè¯ç®¡ç†
  - çŠ¶æ€ç®¡ç†
  - SQLite
categories:
  - AI
  - Claude Code
---

# ç¬¬4ç¯‡ï¼šä¼šè¯ä¸çŠ¶æ€ç®¡ç†

## å¼•è¨€

ä¼šè¯ç®¡ç†æ˜¯ Claude Code çš„"è®°å¿†ç³»ç»Ÿ"ï¼Œè´Ÿè´£ä¿å­˜å¯¹è¯å†å²ã€ä¸Šä¸‹æ–‡çŠ¶æ€ã€ç”¨æˆ·åå¥½ç­‰å…³é”®ä¿¡æ¯ã€‚è‰¯å¥½çš„ä¼šè¯ç®¡ç†èƒ½å¤Ÿå®ç°å¯¹è¯çš„è¿ç»­æ€§ã€å´©æºƒåçš„æ¢å¤ã€ä»¥åŠè·¨è®¾å¤‡çš„åŒæ­¥ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨ Claude Code çš„ä¼šè¯ä¸çŠ¶æ€ç®¡ç†å®ç°ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦ä¼šè¯ç®¡ç†ï¼Ÿ

1. **å¯¹è¯è¿ç»­æ€§**ï¼šä¿æŒå¤šè½®å¯¹è¯çš„ä¸Šä¸‹æ–‡å’ŒçŠ¶æ€
2. **å´©æºƒæ¢å¤**ï¼šæ„å¤–ä¸­æ–­åèƒ½å¤Ÿæ¢å¤å·¥ä½œçŠ¶æ€
3. **å†å²å›æº¯**ï¼šæŸ¥çœ‹å’Œæ¢å¤å†å²å¯¹è¯
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡ç¼“å­˜é¿å…é‡å¤è®¡ç®—
5. **ç”¨æˆ·ä½“éªŒ**ï¼šæ— ç¼çš„è·¨ä¼šè¯ä½“éªŒ

### çŠ¶æ€ç®¡ç†çš„æŒ‘æˆ˜

- âš ï¸ æ•°æ®ä¸€è‡´æ€§é—®é¢˜ï¼ˆå¹¶å‘å†™å…¥ï¼‰
- âš ï¸ å­˜å‚¨ç©ºé—´ç®¡ç†ï¼ˆå†å²ç§¯ç´¯ï¼‰
- âš ï¸ éšç§å’Œå®‰å…¨ï¼ˆæ•æ„Ÿä¿¡æ¯ï¼‰
- âš ï¸ æ€§èƒ½ä¼˜åŒ–ï¼ˆå¤§é‡æ•°æ®è¯»å†™ï¼‰
- âš ï¸ è·¨å¹³å°å…¼å®¹æ€§

---

## ä¸€ã€ä¼šè¯ç”Ÿå‘½å‘¨æœŸ

### 1.1 å®Œæ•´çŠ¶æ€æœº

```mermaid
stateDiagram-v2
    [*] --> Created: ç”¨æˆ·å¯åŠ¨CLI

    Created --> Initializing: åŠ è½½é…ç½®
    Initializing --> Active: åˆå§‹åŒ–å®Œæˆ
    Initializing --> Error: åˆå§‹åŒ–å¤±è´¥

    Active --> Processing: æ¥æ”¶ç”¨æˆ·æ¶ˆæ¯
    Processing --> Active: å¤„ç†å®Œæˆ
    Processing --> ToolCalling: éœ€è¦è°ƒç”¨å·¥å…·

    ToolCalling --> Processing: å·¥å…·æ‰§è¡Œå®Œæˆ
    ToolCalling --> Error: å·¥å…·æ‰§è¡Œå¤±è´¥

    Active --> Paused: ç”¨æˆ·æš‚åœ(Ctrl+Z)
    Paused --> Active: ç”¨æˆ·æ¢å¤(fg)

    Active --> Suspended: é•¿æ—¶é—´æ— æ´»åŠ¨
    Suspended --> Active: ç”¨æˆ·è¿”å›

    Active --> Saving: ç”¨æˆ·ä¿å­˜ä¼šè¯
    Saving --> Active: ä¿å­˜å®Œæˆ
    Saving --> Error: ä¿å­˜å¤±è´¥

    Active --> Closing: ç”¨æˆ·é€€å‡º
    Paused --> Closing: å¼ºåˆ¶é€€å‡º
    Suspended --> Closing: æ¸…ç†è¶…æ—¶ä¼šè¯

    Closing --> Archiving: å½’æ¡£ä¼šè¯
    Archiving --> Closed: å½’æ¡£å®Œæˆ
    Archiving --> Error: å½’æ¡£å¤±è´¥

    Error --> Active: é”™è¯¯æ¢å¤
    Error --> Closed: æ— æ³•æ¢å¤

    Closed --> [*]

    note right of Active
        æ ¸å¿ƒçŠ¶æ€
        - æ¥æ”¶ç”¨æˆ·è¾“å…¥
        - å¤„ç†AIå“åº”
        - æ‰§è¡Œå·¥å…·
        - å®æ—¶ä¿å­˜
    end note

    note right of Suspended
        ä¼‘çœ çŠ¶æ€
        - å†…å­˜çŠ¶æ€æŒä¹…åŒ–
        - é‡Šæ”¾èµ„æº
        - å®šæ—¶æ£€æŸ¥æ´»åŠ¨
    end note
```

### 1.2 çŠ¶æ€è½¬æ¢è§„åˆ™

```typescript
/**
 * ä¼šè¯çŠ¶æ€æšä¸¾
 */
enum SessionStatus {
  CREATED = 'created',           // å·²åˆ›å»º
  INITIALIZING = 'initializing', // åˆå§‹åŒ–ä¸­
  ACTIVE = 'active',             // æ´»è·ƒ
  PROCESSING = 'processing',     // å¤„ç†ä¸­
  TOOL_CALLING = 'tool_calling', // å·¥å…·è°ƒç”¨ä¸­
  PAUSED = 'paused',             // æš‚åœ
  SUSPENDED = 'suspended',       // ä¼‘çœ 
  SAVING = 'saving',             // ä¿å­˜ä¸­
  CLOSING = 'closing',           // å…³é—­ä¸­
  ARCHIVING = 'archiving',       // å½’æ¡£ä¸­
  CLOSED = 'closed',             // å·²å…³é—­
  ERROR = 'error'                // é”™è¯¯
}

/**
 * çŠ¶æ€è½¬æ¢ç®¡ç†å™¨
 */
class SessionStateManager {
  private currentState: SessionStatus;
  private stateHistory: Array<{ from: SessionStatus; to: SessionStatus; timestamp: number }> = [];

  // å…è®¸çš„çŠ¶æ€è½¬æ¢è§„åˆ™
  private readonly VALID_TRANSITIONS: Map<SessionStatus, SessionStatus[]> = new Map([
    [SessionStatus.CREATED, [SessionStatus.INITIALIZING, SessionStatus.ERROR]],
    [SessionStatus.INITIALIZING, [SessionStatus.ACTIVE, SessionStatus.ERROR]],
    [SessionStatus.ACTIVE, [
      SessionStatus.PROCESSING,
      SessionStatus.PAUSED,
      SessionStatus.SUSPENDED,
      SessionStatus.SAVING,
      SessionStatus.CLOSING,
      SessionStatus.ERROR
    ]],
    [SessionStatus.PROCESSING, [
      SessionStatus.ACTIVE,
      SessionStatus.TOOL_CALLING,
      SessionStatus.ERROR
    ]],
    [SessionStatus.TOOL_CALLING, [
      SessionStatus.PROCESSING,
      SessionStatus.ERROR
    ]],
    [SessionStatus.PAUSED, [SessionStatus.ACTIVE, SessionStatus.CLOSING]],
    [SessionStatus.SUSPENDED, [SessionStatus.ACTIVE, SessionStatus.CLOSING]],
    [SessionStatus.SAVING, [SessionStatus.ACTIVE, SessionStatus.ERROR]],
    [SessionStatus.CLOSING, [SessionStatus.ARCHIVING, SessionStatus.ERROR]],
    [SessionStatus.ARCHIVING, [SessionStatus.CLOSED, SessionStatus.ERROR]],
    [SessionStatus.ERROR, [SessionStatus.ACTIVE, SessionStatus.CLOSED]],
    [SessionStatus.CLOSED, []]
  ]);

  constructor(initialState: SessionStatus = SessionStatus.CREATED) {
    this.currentState = initialState;
  }

  /**
   * è½¬æ¢çŠ¶æ€
   */
  transition(newState: SessionStatus): void {
    const allowedStates = this.VALID_TRANSITIONS.get(this.currentState);

    if (!allowedStates || !allowedStates.includes(newState)) {
      throw new Error(
        `Invalid state transition: ${this.currentState} -> ${newState}`
      );
    }

    const oldState = this.currentState;
    this.currentState = newState;

    // è®°å½•çŠ¶æ€å†å²
    this.stateHistory.push({
      from: oldState,
      to: newState,
      timestamp: Date.now()
    });

    console.log(`çŠ¶æ€è½¬æ¢: ${oldState} -> ${newState}`);
  }

  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  getCurrentState(): SessionStatus {
    return this.currentState;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥è½¬æ¢åˆ°æŒ‡å®šçŠ¶æ€
   */
  canTransitionTo(newState: SessionStatus): boolean {
    const allowedStates = this.VALID_TRANSITIONS.get(this.currentState);
    return allowedStates ? allowedStates.includes(newState) : false;
  }

  /**
   * è·å–çŠ¶æ€å†å²
   */
  getStateHistory(): Array<{ from: SessionStatus; to: SessionStatus; timestamp: number }> {
    return [...this.stateHistory];
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºç»ˆæ€
   */
  isFinalState(): boolean {
    return this.currentState === SessionStatus.CLOSED;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºé”™è¯¯çŠ¶æ€
   */
  isErrorState(): boolean {
    return this.currentState === SessionStatus.ERROR;
  }
}

export { SessionStatus, SessionStateManager };
```

---

## äºŒã€ä¼šè¯æ•°æ®ç»“æ„

### 2.1 TypeScript æ¥å£å®šä¹‰

```typescript
/**
 * æ¶ˆæ¯å†…å®¹ç±»å‹
 */
type MessageContent = string | Array<{
  type: 'text' | 'tool_use' | 'tool_result';
  text?: string;
  id?: string;
  name?: string;
  input?: Record<string, any>;
  content?: string;
  is_error?: boolean;
}>;

/**
 * å•æ¡æ¶ˆæ¯
 */
interface Message {
  id: string;                    // æ¶ˆæ¯å”¯ä¸€ID
  role: 'user' | 'assistant' | 'system'; // è§’è‰²
  content: MessageContent;       // æ¶ˆæ¯å†…å®¹
  timestamp: number;             // æ—¶é—´æˆ³
  tokens?: number;               // Tokenæ•°é‡
  metadata?: {
    model?: string;              // ä½¿ç”¨çš„æ¨¡å‹
    stop_reason?: string;        // åœæ­¢åŸå› 
    usage?: {                    // Tokenä½¿ç”¨æƒ…å†µ
      input_tokens: number;
      output_tokens: number;
    };
  };
}

/**
 * ç¼–è¾‘å†å²è®°å½•
 */
interface EditHistory {
  id: string;                    // ç¼–è¾‘ID
  timestamp: number;             // ç¼–è¾‘æ—¶é—´
  type: 'create' | 'update' | 'delete'; // æ“ä½œç±»å‹
  filePath: string;              // æ–‡ä»¶è·¯å¾„
  oldContent?: string;           // æ—§å†…å®¹ï¼ˆç”¨äºå›æ»šï¼‰
  newContent?: string;           // æ–°å†…å®¹
  diff?: string;                 // Diffä¿¡æ¯
}

/**
 * å·¥å…·è°ƒç”¨è®°å½•
 */
interface ToolCallRecord {
  id: string;                    // è°ƒç”¨ID
  timestamp: number;             // è°ƒç”¨æ—¶é—´
  toolName: string;              // å·¥å…·åç§°
  input: Record<string, any>;    // è¾“å…¥å‚æ•°
  output?: any;                  // è¾“å‡ºç»“æœ
  error?: string;                // é”™è¯¯ä¿¡æ¯
  duration?: number;             // æ‰§è¡Œæ—¶é•¿(ms)
  status: 'pending' | 'success' | 'error'; // çŠ¶æ€
}

/**
 * ä¸Šä¸‹æ–‡å¿«ç…§
 */
interface ContextSnapshot {
  id: string;                    // å¿«ç…§ID
  timestamp: number;             // åˆ›å»ºæ—¶é—´
  files: Array<{                 // ç›¸å…³æ–‡ä»¶
    path: string;
    lastModified: number;
    size: number;
    hash?: string;               // æ–‡ä»¶å“ˆå¸Œå€¼
  }>;
  workingDirectory: string;      // å·¥ä½œç›®å½•
  gitStatus?: {                  // GitçŠ¶æ€
    branch: string;
    uncommittedChanges: number;
    untrackedFiles: number;
  };
  environmentVars?: Record<string, string>; // ç¯å¢ƒå˜é‡
}

/**
 * ä¼šè¯é…ç½®
 */
interface SessionConfig {
  model: string;                 // AIæ¨¡å‹
  maxTokens: number;             // æœ€å¤§Tokenæ•°
  temperature: number;           // æ¸©åº¦å‚æ•°
  enableStreaming: boolean;      // æ˜¯å¦å¯ç”¨æµå¼å“åº”
  enableToolCalling: boolean;    // æ˜¯å¦å¯ç”¨å·¥å…·è°ƒç”¨
  maxToolCallDepth: number;      // å·¥å…·è°ƒç”¨æœ€å¤§æ·±åº¦
  autoSave: boolean;             // æ˜¯å¦è‡ªåŠ¨ä¿å­˜
  autoSaveInterval: number;      // è‡ªåŠ¨ä¿å­˜é—´éš”(ms)
}

/**
 * ä¼šè¯ç»Ÿè®¡ä¿¡æ¯
 */
interface SessionStats {
  messageCount: number;          // æ¶ˆæ¯æ€»æ•°
  tokensUsed: number;            // Tokenæ€»æ¶ˆè€—
  toolCallsCount: number;        // å·¥å…·è°ƒç”¨æ¬¡æ•°
  filesModified: number;         // ä¿®æ”¹çš„æ–‡ä»¶æ•°
  startTime: number;             // å¼€å§‹æ—¶é—´
  lastActiveTime: number;        // æœ€åæ´»è·ƒæ—¶é—´
  totalDuration: number;         // æ€»æ—¶é•¿(ms)
}

/**
 * å®Œæ•´ä¼šè¯æ•°æ®ç»“æ„
 */
interface Session {
  // åŸºæœ¬ä¿¡æ¯
  id: string;                    // ä¼šè¯å”¯ä¸€ID
  createdAt: Date;               // åˆ›å»ºæ—¶é—´
  lastActiveAt: Date;            // æœ€åæ´»è·ƒæ—¶é—´
  status: SessionStatus;         // å½“å‰çŠ¶æ€

  // å…ƒæ•°æ®
  metadata: {
    workspaceRoot: string;       // å·¥ä½œåŒºæ ¹ç›®å½•
    projectName?: string;        // é¡¹ç›®åç§°
    gitBranch?: string;          // Gitåˆ†æ”¯
    userId?: string;             // ç”¨æˆ·ID
    deviceId?: string;           // è®¾å¤‡ID
    tags?: string[];             // æ ‡ç­¾
  };

  // å¯¹è¯æ•°æ®
  messages: Message[];           // æ¶ˆæ¯å†å²
  systemPrompt?: string;         // ç³»ç»Ÿæç¤ºè¯

  // ä¸Šä¸‹æ–‡æ•°æ®
  context: {
    files: string[];             // ç›¸å…³æ–‡ä»¶åˆ—è¡¨
    recentEdits: EditHistory[];  // æœ€è¿‘ç¼–è¾‘
    snapshots: ContextSnapshot[]; // ä¸Šä¸‹æ–‡å¿«ç…§
  };

  // å·¥å…·è°ƒç”¨è®°å½•
  toolCalls: ToolCallRecord[];

  // é…ç½®
  config: SessionConfig;

  // ç»Ÿè®¡ä¿¡æ¯
  stats: SessionStats;

  // å…¶ä»–çŠ¶æ€
  isPersisted: boolean;          // æ˜¯å¦å·²æŒä¹…åŒ–
  isDirty: boolean;              // æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
}

export {
  Message,
  MessageContent,
  EditHistory,
  ToolCallRecord,
  ContextSnapshot,
  SessionConfig,
  SessionStats,
  Session
};
```

### 2.2 æ•°æ®å…³ç³»å›¾

```mermaid
erDiagram
    Session ||--o{ Message : contains
    Session ||--o{ EditHistory : tracks
    Session ||--o{ ToolCallRecord : records
    Session ||--o{ ContextSnapshot : captures
    Session ||--|| SessionConfig : has
    Session ||--|| SessionStats : maintains

    Message {
        string id PK
        string role
        mixed content
        number timestamp
        number tokens
    }

    EditHistory {
        string id PK
        number timestamp
        string type
        string filePath
        string diff
    }

    ToolCallRecord {
        string id PK
        number timestamp
        string toolName
        object input
        any output
        string status
    }

    ContextSnapshot {
        string id PK
        number timestamp
        array files
        string workingDirectory
        object gitStatus
    }

    SessionConfig {
        string model
        number maxTokens
        boolean enableStreaming
    }

    SessionStats {
        number messageCount
        number tokensUsed
        number toolCallsCount
    }
```

---

## ä¸‰ã€æŒä¹…åŒ–æ–¹æ¡ˆè®¾è®¡

### 3.1 æŠ€æœ¯é€‰å‹å¯¹æ¯”

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **SQLite** | âœ… è½»é‡çº§<br>âœ… æ— éœ€æœåŠ¡<br>âœ… ACIDä¿è¯<br>âœ… æŸ¥è¯¢çµæ´» | âŒ å¹¶å‘æ€§èƒ½ä¸€èˆ¬<br>âŒ ä¸é€‚åˆåˆ†å¸ƒå¼ | å•ç”¨æˆ·CLIåº”ç”¨ |
| **JSONæ–‡ä»¶** | âœ… ç®€å•ç›´è§‚<br>âœ… æ˜“äºè°ƒè¯•<br>âœ… å¯è¯»æ€§å¥½ | âŒ å¤§æ•°æ®æ€§èƒ½å·®<br>âŒ æ— äº‹åŠ¡æ”¯æŒ<br>âŒ å¹¶å‘å†™å…¥é£é™© | é…ç½®æ–‡ä»¶ã€å°è§„æ¨¡æ•°æ® |
| **LevelDB** | âœ… é«˜æ€§èƒ½<br>âœ… é”®å€¼å­˜å‚¨å¿« | âŒ æŸ¥è¯¢èƒ½åŠ›å¼±<br>âŒ æ— SQLæ”¯æŒ | æ—¶åºæ•°æ®ã€ç¼“å­˜ |
| **PostgreSQL** | âœ… åŠŸèƒ½å¼ºå¤§<br>âœ… å¹¶å‘æ€§èƒ½å¥½<br>âœ… é€‚åˆåˆ†å¸ƒå¼ | âŒ éœ€è¦é¢å¤–æœåŠ¡<br>âŒ éƒ¨ç½²å¤æ‚ | ä¼ä¸šçº§åº”ç”¨ã€å¤šç”¨æˆ· |

**Claude Code é€‰æ‹©ï¼šSQLite**

åŸå› ï¼š
1. âœ… è½»é‡çº§ï¼Œæ— éœ€é¢å¤–æœåŠ¡
2. âœ… ç¬¦åˆå•ç”¨æˆ·CLIåº”ç”¨åœºæ™¯
3. âœ… æ”¯æŒå®Œæ•´çš„SQLæŸ¥è¯¢
4. âœ… ACIDäº‹åŠ¡ä¿è¯æ•°æ®ä¸€è‡´æ€§
5. âœ… è·¨å¹³å°å…¼å®¹æ€§å¥½

### 3.2 SQLite æ•°æ®åº“è®¾è®¡

#### Schema å®šä¹‰

```sql
-- ============================================
-- Claude Code ä¼šè¯æ•°æ®åº“ Schema
-- ============================================

-- 1. ä¼šè¯è¡¨
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  created_at INTEGER NOT NULL,
  last_active_at INTEGER NOT NULL,
  status TEXT NOT NULL DEFAULT 'active',

  -- å…ƒæ•°æ® (JSON)
  metadata TEXT NOT NULL,

  -- é…ç½® (JSON)
  config TEXT NOT NULL,

  -- ç»Ÿè®¡ä¿¡æ¯ (JSON)
  stats TEXT NOT NULL,

  -- ç³»ç»Ÿæç¤ºè¯
  system_prompt TEXT,

  -- æ ‡å¿—ä½
  is_persisted INTEGER DEFAULT 1,
  is_dirty INTEGER DEFAULT 0,

  -- ç´¢å¼•å­—æ®µï¼ˆä»metadataä¸­æå–ï¼Œç”¨äºå¿«é€ŸæŸ¥è¯¢ï¼‰
  workspace_root TEXT,
  project_name TEXT,
  git_branch TEXT
);

-- 2. æ¶ˆæ¯è¡¨
CREATE TABLE IF NOT EXISTS messages (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  role TEXT NOT NULL CHECK(role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,           -- JSONæˆ–çº¯æ–‡æœ¬
  timestamp INTEGER NOT NULL,
  tokens INTEGER,

  -- å…ƒæ•°æ® (JSON)
  metadata TEXT,

  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

-- 3. ç¼–è¾‘å†å²è¡¨
CREATE TABLE IF NOT EXISTS edit_history (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  type TEXT NOT NULL CHECK(type IN ('create', 'update', 'delete')),
  file_path TEXT NOT NULL,
  old_content TEXT,
  new_content TEXT,
  diff TEXT,

  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

-- 4. å·¥å…·è°ƒç”¨è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS tool_calls (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  tool_name TEXT NOT NULL,
  input TEXT NOT NULL,              -- JSON
  output TEXT,                      -- JSON
  error TEXT,
  duration INTEGER,
  status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'success', 'error')),

  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

-- 5. ä¸Šä¸‹æ–‡å¿«ç…§è¡¨
CREATE TABLE IF NOT EXISTS context_snapshots (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  context_data TEXT NOT NULL,       -- JSON: files, workingDirectory, gitStatusç­‰

  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

-- ============================================
-- ç´¢å¼•å®šä¹‰
-- ============================================

-- ä¼šè¯ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_sessions_status ON sessions(status);
CREATE INDEX IF NOT EXISTS idx_sessions_last_active ON sessions(last_active_at DESC);
CREATE INDEX IF NOT EXISTS idx_sessions_workspace ON sessions(workspace_root);

-- æ¶ˆæ¯ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);
CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_messages_role ON messages(role);

-- ç¼–è¾‘å†å²ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_edits_session ON edit_history(session_id);
CREATE INDEX IF NOT EXISTS idx_edits_timestamp ON edit_history(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_edits_file ON edit_history(file_path);

-- å·¥å…·è°ƒç”¨ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_tools_session ON tool_calls(session_id);
CREATE INDEX IF NOT EXISTS idx_tools_timestamp ON tool_calls(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_tools_name ON tool_calls(tool_name);
CREATE INDEX IF NOT EXISTS idx_tools_status ON tool_calls(status);

-- å¿«ç…§ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_snapshots_session ON context_snapshots(session_id);
CREATE INDEX IF NOT EXISTS idx_snapshots_timestamp ON context_snapshots(timestamp DESC);

-- ============================================
-- è§†å›¾å®šä¹‰
-- ============================================

-- ä¼šè¯æ‘˜è¦è§†å›¾ï¼ˆåŒ…å«ç»Ÿè®¡ä¿¡æ¯ï¼‰
CREATE VIEW IF NOT EXISTS session_summary AS
SELECT
  s.id,
  s.created_at,
  s.last_active_at,
  s.status,
  s.workspace_root,
  s.project_name,
  COUNT(DISTINCT m.id) as message_count,
  COUNT(DISTINCT t.id) as tool_call_count,
  COUNT(DISTINCT e.id) as edit_count,
  SUM(m.tokens) as total_tokens
FROM sessions s
LEFT JOIN messages m ON s.id = m.session_id
LEFT JOIN tool_calls t ON s.id = t.session_id
LEFT JOIN edit_history e ON s.id = e.session_id
GROUP BY s.id;

-- æœ€è¿‘æ´»è·ƒä¼šè¯è§†å›¾
CREATE VIEW IF NOT EXISTS recent_sessions AS
SELECT
  id,
  workspace_root,
  project_name,
  last_active_at,
  status
FROM sessions
WHERE status IN ('active', 'paused', 'suspended')
ORDER BY last_active_at DESC
LIMIT 10;
```

### 3.3 æŒä¹…åŒ–å®ç°

```typescript
import Database from 'better-sqlite3';
import * as fs from 'fs';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';

/**
 * ä¼šè¯æŒä¹…åŒ–ç®¡ç†å™¨
 */
class SessionPersistence {
  private db: Database.Database;
  private dbPath: string;

  constructor(dbPath?: string) {
    // é»˜è®¤æ•°æ®åº“è·¯å¾„: ~/.claude-code/sessions.db
    this.dbPath = dbPath || path.join(
      process.env.HOME || process.env.USERPROFILE || '',
      '.claude-code',
      'sessions.db'
    );

    this.ensureDbDirectory();
    this.db = new Database(this.dbPath);
    this.initialize();
  }

  /**
   * ç¡®ä¿æ•°æ®åº“ç›®å½•å­˜åœ¨
   */
  private ensureDbDirectory(): void {
    const dir = path.dirname(this.dbPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  /**
   * åˆå§‹åŒ–æ•°æ®åº“ï¼ˆåˆ›å»ºè¡¨å’Œç´¢å¼•ï¼‰
   */
  private initialize(): void {
    // å¯ç”¨å¤–é”®çº¦æŸ
    this.db.pragma('foreign_keys = ON');

    // æ€§èƒ½ä¼˜åŒ–è®¾ç½®
    this.db.pragma('journal_mode = WAL');      // Write-Ahead Logging
    this.db.pragma('synchronous = NORMAL');    // å¹³è¡¡æ€§èƒ½å’Œå®‰å…¨æ€§
    this.db.pragma('cache_size = -64000');     // 64MBç¼“å­˜

    // è¯»å–å¹¶æ‰§è¡ŒSchema
    const schemaPath = path.join(__dirname, 'schema.sql');
    if (fs.existsSync(schemaPath)) {
      const schema = fs.readFileSync(schemaPath, 'utf-8');
      this.db.exec(schema);
    } else {
      // å†…è”Schemaï¼ˆç®€åŒ–ç‰ˆï¼‰
      this.createTables();
    }

    console.log(`âœ… æ•°æ®åº“å·²åˆå§‹åŒ–: ${this.dbPath}`);
  }

  /**
   * åˆ›å»ºè¡¨ç»“æ„
   */
  private createTables(): void {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY,
        created_at INTEGER NOT NULL,
        last_active_at INTEGER NOT NULL,
        status TEXT NOT NULL DEFAULT 'active',
        metadata TEXT NOT NULL,
        config TEXT NOT NULL,
        stats TEXT NOT NULL,
        system_prompt TEXT,
        is_persisted INTEGER DEFAULT 1,
        is_dirty INTEGER DEFAULT 0,
        workspace_root TEXT,
        project_name TEXT,
        git_branch TEXT
      );

      CREATE TABLE IF NOT EXISTS messages (
        id TEXT PRIMARY KEY,
        session_id TEXT NOT NULL,
        role TEXT NOT NULL,
        content TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        tokens INTEGER,
        metadata TEXT,
        FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS edit_history (
        id TEXT PRIMARY KEY,
        session_id TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        type TEXT NOT NULL,
        file_path TEXT NOT NULL,
        old_content TEXT,
        new_content TEXT,
        diff TEXT,
        FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS tool_calls (
        id TEXT PRIMARY KEY,
        session_id TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        tool_name TEXT NOT NULL,
        input TEXT NOT NULL,
        output TEXT,
        error TEXT,
        duration INTEGER,
        status TEXT NOT NULL DEFAULT 'pending',
        FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS context_snapshots (
        id TEXT PRIMARY KEY,
        session_id TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        context_data TEXT NOT NULL,
        FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
      );

      -- åˆ›å»ºç´¢å¼•
      CREATE INDEX IF NOT EXISTS idx_sessions_status ON sessions(status);
      CREATE INDEX IF NOT EXISTS idx_sessions_last_active ON sessions(last_active_at DESC);
      CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);
      CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp DESC);
      CREATE INDEX IF NOT EXISTS idx_tools_session ON tool_calls(session_id);
      CREATE INDEX IF NOT EXISTS idx_edits_session ON edit_history(session_id);
      CREATE INDEX IF NOT EXISTS idx_snapshots_session ON context_snapshots(session_id);
    `);
  }

  /**
   * ä¿å­˜å®Œæ•´ä¼šè¯
   */
  async saveSession(session: Session): Promise<void> {
    const transaction = this.db.transaction(() => {
      // 1. ä¿å­˜ä¼šè¯åŸºæœ¬ä¿¡æ¯
      this.db.prepare(`
        INSERT OR REPLACE INTO sessions (
          id, created_at, last_active_at, status,
          metadata, config, stats, system_prompt,
          is_persisted, is_dirty, workspace_root, project_name, git_branch
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        session.id,
        session.createdAt.getTime(),
        session.lastActiveAt.getTime(),
        session.status,
        JSON.stringify(session.metadata),
        JSON.stringify(session.config),
        JSON.stringify(session.stats),
        session.systemPrompt || null,
        session.isPersisted ? 1 : 0,
        session.isDirty ? 1 : 0,
        session.metadata.workspaceRoot,
        session.metadata.projectName || null,
        session.metadata.gitBranch || null
      );

      // 2. ä¿å­˜æ¶ˆæ¯ï¼ˆæ‰¹é‡æ’å…¥ï¼‰
      const insertMessage = this.db.prepare(`
        INSERT OR REPLACE INTO messages (
          id, session_id, role, content, timestamp, tokens, metadata
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `);

      for (const msg of session.messages) {
        insertMessage.run(
          msg.id,
          session.id,
          msg.role,
          typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content),
          msg.timestamp,
          msg.tokens || null,
          msg.metadata ? JSON.stringify(msg.metadata) : null
        );
      }

      // 3. ä¿å­˜ç¼–è¾‘å†å²
      const insertEdit = this.db.prepare(`
        INSERT OR REPLACE INTO edit_history (
          id, session_id, timestamp, type, file_path, old_content, new_content, diff
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `);

      for (const edit of session.context.recentEdits) {
        insertEdit.run(
          edit.id,
          session.id,
          edit.timestamp,
          edit.type,
          edit.filePath,
          edit.oldContent || null,
          edit.newContent || null,
          edit.diff || null
        );
      }

      // 4. ä¿å­˜å·¥å…·è°ƒç”¨è®°å½•
      const insertTool = this.db.prepare(`
        INSERT OR REPLACE INTO tool_calls (
          id, session_id, timestamp, tool_name, input, output, error, duration, status
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      for (const tool of session.toolCalls) {
        insertTool.run(
          tool.id,
          session.id,
          tool.timestamp,
          tool.toolName,
          JSON.stringify(tool.input),
          tool.output ? JSON.stringify(tool.output) : null,
          tool.error || null,
          tool.duration || null,
          tool.status
        );
      }
    });

    // æ‰§è¡Œäº‹åŠ¡
    transaction();

    console.log(`âœ… ä¼šè¯å·²ä¿å­˜: ${session.id}`);
  }

  /**
   * åŠ è½½ä¼šè¯
   */
  async loadSession(sessionId: string): Promise<Session | null> {
    // 1. åŠ è½½ä¼šè¯åŸºæœ¬ä¿¡æ¯
    const sessionRow = this.db.prepare(`
      SELECT * FROM sessions WHERE id = ?
    `).get(sessionId) as any;

    if (!sessionRow) {
      return null;
    }

    // 2. åŠ è½½æ¶ˆæ¯
    const messageRows = this.db.prepare(`
      SELECT * FROM messages WHERE session_id = ? ORDER BY timestamp ASC
    `).all(sessionId) as any[];

    const messages: Message[] = messageRows.map(row => ({
      id: row.id,
      role: row.role,
      content: this.tryParseJSON(row.content),
      timestamp: row.timestamp,
      tokens: row.tokens,
      metadata: this.tryParseJSON(row.metadata)
    }));

    // 3. åŠ è½½ç¼–è¾‘å†å²
    const editRows = this.db.prepare(`
      SELECT * FROM edit_history WHERE session_id = ? ORDER BY timestamp DESC LIMIT 100
    `).all(sessionId) as any[];

    const recentEdits: EditHistory[] = editRows.map(row => ({
      id: row.id,
      timestamp: row.timestamp,
      type: row.type,
      filePath: row.file_path,
      oldContent: row.old_content,
      newContent: row.new_content,
      diff: row.diff
    }));

    // 4. åŠ è½½å·¥å…·è°ƒç”¨è®°å½•
    const toolRows = this.db.prepare(`
      SELECT * FROM tool_calls WHERE session_id = ? ORDER BY timestamp DESC LIMIT 100
    `).all(sessionId) as any[];

    const toolCalls: ToolCallRecord[] = toolRows.map(row => ({
      id: row.id,
      timestamp: row.timestamp,
      toolName: row.tool_name,
      input: JSON.parse(row.input),
      output: this.tryParseJSON(row.output),
      error: row.error,
      duration: row.duration,
      status: row.status
    }));

    // 5. åŠ è½½ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆæœ€æ–°ä¸€ä¸ªï¼‰
    const snapshotRow = this.db.prepare(`
      SELECT * FROM context_snapshots
      WHERE session_id = ?
      ORDER BY timestamp DESC
      LIMIT 1
    `).get(sessionId) as any;

    const snapshots: ContextSnapshot[] = snapshotRow ? [
      {
        ...JSON.parse(snapshotRow.context_data),
        id: snapshotRow.id,
        timestamp: snapshotRow.timestamp
      }
    ] : [];

    // 6. ç»„è£…å®Œæ•´ä¼šè¯å¯¹è±¡
    const session: Session = {
      id: sessionRow.id,
      createdAt: new Date(sessionRow.created_at),
      lastActiveAt: new Date(sessionRow.last_active_at),
      status: sessionRow.status,
      metadata: JSON.parse(sessionRow.metadata),
      messages,
      systemPrompt: sessionRow.system_prompt,
      context: {
        files: [],  // ä»æœ€æ–°å¿«ç…§ä¸­æå–
        recentEdits,
        snapshots
      },
      toolCalls,
      config: JSON.parse(sessionRow.config),
      stats: JSON.parse(sessionRow.stats),
      isPersisted: Boolean(sessionRow.is_persisted),
      isDirty: Boolean(sessionRow.is_dirty)
    };

    console.log(`âœ… ä¼šè¯å·²åŠ è½½: ${sessionId}`);
    return session;
  }

  /**
   * è¿½åŠ æ¶ˆæ¯ï¼ˆå¢é‡ä¿å­˜ï¼‰
   */
  async appendMessage(sessionId: string, message: Message): Promise<void> {
    this.db.prepare(`
      INSERT INTO messages (
        id, session_id, role, content, timestamp, tokens, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(
      message.id,
      sessionId,
      message.role,
      typeof message.content === 'string' ? message.content : JSON.stringify(message.content),
      message.timestamp,
      message.tokens || null,
      message.metadata ? JSON.stringify(message.metadata) : null
    );

    // æ›´æ–°ä¼šè¯çš„æœ€åæ´»è·ƒæ—¶é—´
    this.updateLastActive(sessionId);
  }

  /**
   * æ›´æ–°ä¼šè¯çŠ¶æ€
   */
  async updateSessionStatus(sessionId: string, status: SessionStatus): Promise<void> {
    this.db.prepare(`
      UPDATE sessions SET status = ?, last_active_at = ? WHERE id = ?
    `).run(status, Date.now(), sessionId);
  }

  /**
   * æ›´æ–°æœ€åæ´»è·ƒæ—¶é—´
   */
  private updateLastActive(sessionId: string): void {
    this.db.prepare(`
      UPDATE sessions SET last_active_at = ? WHERE id = ?
    `).run(Date.now(), sessionId);
  }

  /**
   * åˆ—å‡ºæ‰€æœ‰ä¼šè¯
   */
  async listSessions(options: {
    status?: SessionStatus;
    limit?: number;
    offset?: number;
  } = {}): Promise<Array<Partial<Session>>> {
    let query = 'SELECT * FROM session_summary WHERE 1=1';
    const params: any[] = [];

    if (options.status) {
      query += ' AND status = ?';
      params.push(options.status);
    }

    query += ' ORDER BY last_active_at DESC';

    if (options.limit) {
      query += ' LIMIT ?';
      params.push(options.limit);
    }

    if (options.offset) {
      query += ' OFFSET ?';
      params.push(options.offset);
    }

    const rows = this.db.prepare(query).all(...params) as any[];

    return rows.map(row => ({
      id: row.id,
      createdAt: new Date(row.created_at),
      lastActiveAt: new Date(row.last_active_at),
      status: row.status,
      metadata: {
        workspaceRoot: row.workspace_root,
        projectName: row.project_name
      },
      stats: {
        messageCount: row.message_count,
        toolCallsCount: row.tool_call_count,
        tokensUsed: row.total_tokens
      }
    } as Partial<Session>));
  }

  /**
   * åˆ é™¤ä¼šè¯
   */
  async deleteSession(sessionId: string): Promise<void> {
    this.db.prepare('DELETE FROM sessions WHERE id = ?').run(sessionId);
    console.log(`âœ… ä¼šè¯å·²åˆ é™¤: ${sessionId}`);
  }

  /**
   * æ¸…ç†æ—§ä¼šè¯
   */
  async cleanupOldSessions(olderThanDays: number = 30): Promise<number> {
    const cutoffTime = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);

    const result = this.db.prepare(`
      DELETE FROM sessions
      WHERE status = 'closed' AND last_active_at < ?
    `).run(cutoffTime);

    console.log(`âœ… å·²æ¸…ç† ${result.changes} ä¸ªæ—§ä¼šè¯`);
    return result.changes;
  }

  /**
   * è¾…åŠ©æ–¹æ³•ï¼šå°è¯•è§£æJSON
   */
  private tryParseJSON(str: string | null): any {
    if (!str) return null;
    try {
      return JSON.parse(str);
    } catch {
      return str;
    }
  }

  /**
   * å…³é—­æ•°æ®åº“è¿æ¥
   */
  close(): void {
    this.db.close();
    console.log('âœ… æ•°æ®åº“è¿æ¥å·²å…³é—­');
  }

  /**
   * è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): {
    totalSessions: number;
    activeSessions: number;
    totalMessages: number;
    dbSize: number;
  } {
    const stats = this.db.prepare(`
      SELECT
        COUNT(DISTINCT s.id) as total_sessions,
        SUM(CASE WHEN s.status = 'active' THEN 1 ELSE 0 END) as active_sessions,
        COUNT(DISTINCT m.id) as total_messages
      FROM sessions s
      LEFT JOIN messages m ON s.id = m.session_id
    `).get() as any;

    const dbSize = fs.statSync(this.dbPath).size;

    return {
      totalSessions: stats.total_sessions || 0,
      activeSessions: stats.active_sessions || 0,
      totalMessages: stats.total_messages || 0,
      dbSize
    };
  }
}

export { SessionPersistence };
```

---

## å››ã€ä¼šè¯æ¢å¤æœºåˆ¶

### 4.1 å´©æºƒæ¢å¤æµç¨‹

```mermaid
sequenceDiagram
    participant App as åº”ç”¨å¯åŠ¨
    participant Recovery as æ¢å¤ç®¡ç†å™¨
    participant DB as SQLiteæ•°æ®åº“
    participant State as çŠ¶æ€æ¢å¤å™¨
    participant User as ç”¨æˆ·

    App->>Recovery: å¯åŠ¨æ¢å¤æµç¨‹
    Recovery->>DB: æŸ¥è¯¢æœªå…³é—­ä¼šè¯
    DB-->>Recovery: è¿”å›ä¼šè¯åˆ—è¡¨

    alt æœ‰æœªå…³é—­ä¼šè¯
        Recovery->>User: è¯¢é—®æ˜¯å¦æ¢å¤
        User-->>Recovery: ç¡®è®¤æ¢å¤

        loop æ¯ä¸ªä¼šè¯
            Recovery->>DB: åŠ è½½ä¼šè¯æ•°æ®
            DB-->>Recovery: è¿”å›å®Œæ•´ä¼šè¯

            Recovery->>State: éªŒè¯æ•°æ®å®Œæ•´æ€§
            State->>State: æ£€æŸ¥æ¶ˆæ¯å®Œæ•´æ€§
            State->>State: éªŒè¯å·¥å…·è°ƒç”¨çŠ¶æ€
            State->>State: é‡å»ºä¸Šä¸‹æ–‡çŠ¶æ€

            alt æ•°æ®å®Œæ•´
                State-->>Recovery: æ¢å¤æˆåŠŸ
                Recovery->>DB: æ›´æ–°ä¼šè¯çŠ¶æ€ä¸ºactive
            else æ•°æ®æŸå
                State-->>Recovery: æ¢å¤å¤±è´¥
                Recovery->>User: æç¤ºæ•°æ®æŸå
                User-->>Recovery: é€‰æ‹©ä¿®å¤æˆ–æ”¾å¼ƒ
            end
        end

        Recovery-->>App: æ¢å¤å®Œæˆ
    else æ— æœªå…³é—­ä¼šè¯
        Recovery-->>App: æ­£å¸¸å¯åŠ¨
    end
```

### 4.2 æ¢å¤ç®¡ç†å™¨å®ç°

```typescript
/**
 * ä¼šè¯æ¢å¤ç®¡ç†å™¨
 */
class SessionRecoveryManager {
  private persistence: SessionPersistence;

  constructor(persistence: SessionPersistence) {
    this.persistence = persistence;
  }

  /**
   * å¯åŠ¨æ—¶è‡ªåŠ¨æ¢å¤
   */
  async autoRecover(): Promise<Session[]> {
    console.log('ğŸ” æ£€æŸ¥æœªå…³é—­çš„ä¼šè¯...');

    // æŸ¥æ‰¾æ‰€æœ‰æœªæ­£å¸¸å…³é—­çš„ä¼šè¯
    const uncleanSessions = await this.persistence.listSessions({
      status: SessionStatus.ACTIVE
    });

    if (uncleanSessions.length === 0) {
      console.log('âœ… æ²¡æœ‰éœ€è¦æ¢å¤çš„ä¼šè¯');
      return [];
    }

    console.log(`âš ï¸  å‘ç° ${uncleanSessions.length} ä¸ªæœªå…³é—­çš„ä¼šè¯`);

    // è¯¢é—®ç”¨æˆ·æ˜¯å¦æ¢å¤
    const shouldRecover = await this.promptUserForRecovery(uncleanSessions);

    if (!shouldRecover) {
      // ç”¨æˆ·é€‰æ‹©ä¸æ¢å¤ï¼Œå°†è¿™äº›ä¼šè¯æ ‡è®°ä¸ºå·²å…³é—­
      for (const session of uncleanSessions) {
        await this.persistence.updateSessionStatus(session.id!, SessionStatus.CLOSED);
      }
      return [];
    }

    // æ¢å¤ä¼šè¯
    const recovered: Session[] = [];

    for (const partialSession of uncleanSessions) {
      try {
        const session = await this.recoverSession(partialSession.id!);
        if (session) {
          recovered.push(session);
          console.log(`âœ… å·²æ¢å¤ä¼šè¯: ${session.id}`);
        }
      } catch (error) {
        console.error(`âŒ æ¢å¤ä¼šè¯å¤±è´¥ [${partialSession.id}]:`, error.message);
      }
    }

    return recovered;
  }

  /**
   * æ¢å¤å•ä¸ªä¼šè¯
   */
  async recoverSession(sessionId: string): Promise<Session | null> {
    console.log(`ğŸ”§ æ¢å¤ä¼šè¯: ${sessionId}`);

    // 1. åŠ è½½å®Œæ•´ä¼šè¯æ•°æ®
    const session = await this.persistence.loadSession(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    // 2. éªŒè¯æ•°æ®å®Œæ•´æ€§
    const validation = await this.validateSessionIntegrity(session);

    if (!validation.isValid) {
      console.warn(`âš ï¸  ä¼šè¯æ•°æ®å­˜åœ¨é—®é¢˜:`, validation.issues);

      // å°è¯•ä¿®å¤
      const fixed = await this.attemptFix(session, validation.issues);
      if (!fixed) {
        throw new Error('æ— æ³•ä¿®å¤ä¼šè¯æ•°æ®');
      }
    }

    // 3. é‡å»ºè¿è¡Œæ—¶çŠ¶æ€
    await this.restoreRuntimeState(session);

    // 4. æ›´æ–°ä¼šè¯çŠ¶æ€
    session.status = SessionStatus.ACTIVE;
    session.lastActiveAt = new Date();
    await this.persistence.saveSession(session);

    return session;
  }

  /**
   * éªŒè¯ä¼šè¯æ•°æ®å®Œæ•´æ€§
   */
  private async validateSessionIntegrity(session: Session): Promise<{
    isValid: boolean;
    issues: string[];
  }> {
    const issues: string[] = [];

    // 1. æ£€æŸ¥åŸºæœ¬ä¿¡æ¯
    if (!session.id || !session.createdAt) {
      issues.push('ç¼ºå°‘åŸºæœ¬ä¿¡æ¯');
    }

    // 2. æ£€æŸ¥æ¶ˆæ¯å®Œæ•´æ€§
    if (session.messages.length === 0) {
      issues.push('æ¶ˆæ¯å†å²ä¸ºç©º');
    } else {
      // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æŒ‰æ—¶é—´é¡ºåº
      for (let i = 1; i < session.messages.length; i++) {
        if (session.messages[i].timestamp < session.messages[i - 1].timestamp) {
          issues.push('æ¶ˆæ¯æ—¶é—´é¡ºåºé”™è¯¯');
          break;
        }
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰å­¤ç«‹çš„å·¥å…·è°ƒç”¨ï¼ˆæ²¡æœ‰å¯¹åº”ç»“æœï¼‰
      const pendingToolCalls = session.messages.filter(
        msg => Array.isArray(msg.content) &&
        msg.content.some((block: any) => block.type === 'tool_use')
      );

      if (pendingToolCalls.length > 0) {
        issues.push(`å­˜åœ¨ ${pendingToolCalls.length} ä¸ªæœªå®Œæˆçš„å·¥å…·è°ƒç”¨`);
      }
    }

    // 3. æ£€æŸ¥å·¥å…·è°ƒç”¨çŠ¶æ€
    const pendingTools = session.toolCalls.filter(t => t.status === 'pending');
    if (pendingTools.length > 0) {
      issues.push(`å­˜åœ¨ ${pendingTools.length} ä¸ªå¾…å¤„ç†çš„å·¥å…·è°ƒç”¨`);
    }

    // 4. æ£€æŸ¥é…ç½®æœ‰æ•ˆæ€§
    if (!session.config || !session.config.model) {
      issues.push('é…ç½®ä¿¡æ¯ä¸å®Œæ•´');
    }

    return {
      isValid: issues.length === 0,
      issues
    };
  }

  /**
   * å°è¯•ä¿®å¤æ•°æ®é—®é¢˜
   */
  private async attemptFix(session: Session, issues: string[]): Promise<boolean> {
    console.log('ğŸ”§ å°è¯•ä¿®å¤æ•°æ®é—®é¢˜...');

    let fixed = true;

    for (const issue of issues) {
      if (issue.includes('æœªå®Œæˆçš„å·¥å…·è°ƒç”¨')) {
        // å°†æœªå®Œæˆçš„å·¥å…·è°ƒç”¨æ ‡è®°ä¸ºé”™è¯¯
        session.toolCalls = session.toolCalls.map(tool => {
          if (tool.status === 'pending') {
            return {
              ...tool,
              status: 'error' as const,
              error: 'Session crashed during execution'
            };
          }
          return tool;
        });
      } else if (issue.includes('æ¶ˆæ¯æ—¶é—´é¡ºåºé”™è¯¯')) {
        // é‡æ–°æŒ‰æ—¶é—´æ’åº
        session.messages.sort((a, b) => a.timestamp - b.timestamp);
      } else if (issue.includes('é…ç½®ä¿¡æ¯ä¸å®Œæ•´')) {
        // ä½¿ç”¨é»˜è®¤é…ç½®
        session.config = {
          model: 'claude-3-5-sonnet-20250929',
          maxTokens: 8000,
          temperature: 0,
          enableStreaming: true,
          enableToolCalling: true,
          maxToolCallDepth: 5,
          autoSave: true,
          autoSaveInterval: 60000
        };
      } else {
        // æ— æ³•è‡ªåŠ¨ä¿®å¤
        fixed = false;
      }
    }

    if (fixed) {
      console.log('âœ… æ•°æ®é—®é¢˜å·²ä¿®å¤');
      // ä¿å­˜ä¿®å¤åçš„æ•°æ®
      await this.persistence.saveSession(session);
    } else {
      console.warn('âŒ éƒ¨åˆ†é—®é¢˜æ— æ³•è‡ªåŠ¨ä¿®å¤');
    }

    return fixed;
  }

  /**
   * é‡å»ºè¿è¡Œæ—¶çŠ¶æ€
   */
  private async restoreRuntimeState(session: Session): Promise<void> {
    // 1. æ¢å¤ä¸Šä¸‹æ–‡ç®¡ç†å™¨çŠ¶æ€
    // contextManager.restore(session.context);

    // 2. æ¢å¤æ–‡ä»¶ç›‘å¬
    // fileWatcher.watchFiles(session.context.files);

    // 3. é‡æ–°åŠ è½½å·¥å…·å®šä¹‰
    // toolRegistry.reloadTools();

    console.log('âœ… è¿è¡Œæ—¶çŠ¶æ€å·²æ¢å¤');
  }

  /**
   * æç¤ºç”¨æˆ·æ˜¯å¦æ¢å¤
   */
  private async promptUserForRecovery(sessions: Array<Partial<Session>>): Promise<boolean> {
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨inquirerç­‰åº“å®ç°äº¤äº’å¼æç¤º
    // ç®€åŒ–ç‰ˆæœ¬ï¼šç›´æ¥è¿”å›true

    console.log('\næœªå…³é—­çš„ä¼šè¯åˆ—è¡¨:');
    sessions.forEach((session, index) => {
      console.log(`${index + 1}. ${session.metadata?.projectName || session.id}`);
      console.log(`   å·¥ä½œåŒº: ${session.metadata?.workspaceRoot}`);
      console.log(`   æœ€åæ´»è·ƒ: ${session.lastActiveAt?.toLocaleString()}`);
    });

    // å®é™…åº”ç”¨ä¸­åº”è¯¥è¯¢é—®ç”¨æˆ·
    // const answer = await inquirer.prompt([...]);
    // return answer.shouldRecover;

    return true;  // é»˜è®¤æ¢å¤
  }

  /**
   * åˆ›å»ºæ£€æŸ¥ç‚¹ï¼ˆå®šæœŸä¿å­˜ï¼‰
   */
  async createCheckpoint(session: Session): Promise<void> {
    console.log(`ğŸ’¾ åˆ›å»ºæ£€æŸ¥ç‚¹: ${session.id}`);

    // åˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§
    const snapshot: ContextSnapshot = {
      id: uuidv4(),
      timestamp: Date.now(),
      files: session.context.files.map(f => ({
        path: f,
        lastModified: Date.now(),
        size: 0  // å®é™…å®ç°ä¸­åº”è¯¥è·å–çœŸå®æ–‡ä»¶ä¿¡æ¯
      })),
      workingDirectory: session.metadata.workspaceRoot
    };

    // ä¿å­˜å¿«ç…§åˆ°æ•°æ®åº“
    const db = (this.persistence as any).db;
    db.prepare(`
      INSERT INTO context_snapshots (id, session_id, timestamp, context_data)
      VALUES (?, ?, ?, ?)
    `).run(
      snapshot.id,
      session.id,
      snapshot.timestamp,
      JSON.stringify(snapshot)
    );

    // ä¿å­˜å®Œæ•´ä¼šè¯
    await this.persistence.saveSession(session);

    console.log('âœ… æ£€æŸ¥ç‚¹å·²åˆ›å»º');
  }

  /**
   * å›æ»šåˆ°æ£€æŸ¥ç‚¹
   */
  async rollbackToCheckpoint(sessionId: string, checkpointId: string): Promise<Session | null> {
    console.log(`â®ï¸  å›æ»šåˆ°æ£€æŸ¥ç‚¹: ${checkpointId}`);

    // åŠ è½½æ£€æŸ¥ç‚¹æ—¶çš„ä¼šè¯çŠ¶æ€
    // è¿™é‡Œéœ€è¦ä»å¿«ç…§ä¸­é‡å»ºä¼šè¯
    // å®é™…å®ç°ä¼šæ›´å¤æ‚

    const session = await this.persistence.loadSession(sessionId);
    if (!session) {
      return null;
    }

    // æ‰¾åˆ°å¯¹åº”çš„å¿«ç…§
    const snapshot = session.context.snapshots.find(s => s.id === checkpointId);
    if (!snapshot) {
      throw new Error('Checkpoint not found');
    }

    // æ¢å¤åˆ°è¯¥å¿«ç…§çš„çŠ¶æ€
    // ...

    console.log('âœ… å·²å›æ»šåˆ°æ£€æŸ¥ç‚¹');
    return session;
  }
}

export { SessionRecoveryManager };
```

### 4.3 æ–­ç‚¹ç»­ä¼ å®ç°

```typescript
/**
 * é•¿æ—¶é—´è¿è¡Œä»»åŠ¡çš„æ–­ç‚¹ç»­ä¼ 
 */
class ResumableTaskManager {
  private persistence: SessionPersistence;

  constructor(persistence: SessionPersistence) {
    this.persistence = persistence;
  }

  /**
   * ä¿å­˜ä»»åŠ¡è¿›åº¦
   */
  async saveProgress(
    sessionId: string,
    taskId: string,
    progress: {
      currentStep: number;
      totalSteps: number;
      completedWork: any;
      remainingWork: any;
      intermediateResults: any;
    }
  ): Promise<void> {
    // å°†è¿›åº¦ä¿å­˜ä¸ºå·¥å…·è°ƒç”¨è®°å½•
    const record: ToolCallRecord = {
      id: taskId,
      timestamp: Date.now(),
      toolName: '_task_progress',  // ç‰¹æ®Šå·¥å…·å
      input: {
        currentStep: progress.currentStep,
        totalSteps: progress.totalSteps,
        completedWork: progress.completedWork,
        remainingWork: progress.remainingWork
      },
      output: progress.intermediateResults,
      status: 'pending',
      duration: 0
    };

    const db = (this.persistence as any).db;
    db.prepare(`
      INSERT OR REPLACE INTO tool_calls (
        id, session_id, timestamp, tool_name, input, output, status, duration
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      record.id,
      sessionId,
      record.timestamp,
      record.toolName,
      JSON.stringify(record.input),
      JSON.stringify(record.output),
      record.status,
      record.duration
    );

    console.log(`ğŸ’¾ ä»»åŠ¡è¿›åº¦å·²ä¿å­˜: ${taskId} (${progress.currentStep}/${progress.totalSteps})`);
  }

  /**
   * æ¢å¤ä»»åŠ¡è¿›åº¦
   */
  async loadProgress(sessionId: string, taskId: string): Promise<any | null> {
    const db = (this.persistence as any).db;

    const record = db.prepare(`
      SELECT * FROM tool_calls
      WHERE id = ? AND session_id = ? AND tool_name = '_task_progress'
    `).get(taskId, sessionId) as any;

    if (!record) {
      return null;
    }

    return {
      currentStep: JSON.parse(record.input).currentStep,
      totalSteps: JSON.parse(record.input).totalSteps,
      completedWork: JSON.parse(record.input).completedWork,
      remainingWork: JSON.parse(record.input).remainingWork,
      intermediateResults: JSON.parse(record.output || '{}')
    };
  }

  /**
   * ç»­ä¼ æ‰§è¡Œä»»åŠ¡
   */
  async resumeTask(
    sessionId: string,
    taskId: string,
    executor: (progress: any) => Promise<any>
  ): Promise<any> {
    // 1. åŠ è½½è¿›åº¦
    const progress = await this.loadProgress(sessionId, taskId);

    if (!progress) {
      console.log('æœªæ‰¾åˆ°ä»»åŠ¡è¿›åº¦ï¼Œä»å¤´å¼€å§‹');
      return executor(null);
    }

    console.log(`â–¶ï¸  ä»ç¬¬ ${progress.currentStep}/${progress.totalSteps} æ­¥ç»§ç»­`);

    // 2. ä»ä¸­æ–­ç‚¹ç»§ç»­æ‰§è¡Œ
    return executor(progress);
  }

  /**
   * æ¸…é™¤ä»»åŠ¡è¿›åº¦
   */
  async clearProgress(sessionId: string, taskId: string): Promise<void> {
    const db = (this.persistence as any).db;

    db.prepare(`
      DELETE FROM tool_calls
      WHERE id = ? AND session_id = ? AND tool_name = '_task_progress'
    `).run(taskId, sessionId);

    console.log(`ğŸ—‘ï¸  ä»»åŠ¡è¿›åº¦å·²æ¸…é™¤: ${taskId}`);
  }
}

export { ResumableTaskManager };
```

---

## äº”ã€å¤šä¼šè¯å¹¶å‘å¤„ç†

### 5.1 ä¼šè¯éš”ç¦»ç­–ç•¥

```typescript
/**
 * ä¼šè¯éš”ç¦»ç®¡ç†å™¨
 */
class SessionIsolationManager {
  private activeSessions: Map<string, Session> = new Map();
  private sessionLocks: Map<string, boolean> = new Map();

  /**
   * åŠ è½½ä¼šè¯ï¼ˆå¸¦é”ï¼‰
   */
  async acquireSession(sessionId: string): Promise<Session> {
    // æ£€æŸ¥æ˜¯å¦å·²è¢«åŠ è½½
    if (this.activeSessions.has(sessionId)) {
      return this.activeSessions.get(sessionId)!;
    }

    // æ£€æŸ¥æ˜¯å¦è¢«é”å®š
    if (this.sessionLocks.get(sessionId)) {
      throw new Error(`Session ${sessionId} is locked by another process`);
    }

    // åŠ é”
    this.sessionLocks.set(sessionId, true);

    try {
      // ä»æ•°æ®åº“åŠ è½½
      const persistence = new SessionPersistence();
      const session = await persistence.loadSession(sessionId);

      if (!session) {
        throw new Error(`Session ${sessionId} not found`);
      }

      // åŠ å…¥æ´»è·ƒä¼šè¯æ± 
      this.activeSessions.set(sessionId, session);

      return session;
    } catch (error) {
      // é‡Šæ”¾é”
      this.sessionLocks.delete(sessionId);
      throw error;
    }
  }

  /**
   * é‡Šæ”¾ä¼šè¯
   */
  async releaseSession(sessionId: string, save: boolean = true): Promise<void> {
    const session = this.activeSessions.get(sessionId);

    if (!session) {
      return;
    }

    if (save) {
      // ä¿å­˜åˆ°æ•°æ®åº“
      const persistence = new SessionPersistence();
      await persistence.saveSession(session);
    }

    // ä»æ´»è·ƒæ± ä¸­ç§»é™¤
    this.activeSessions.delete(sessionId);

    // é‡Šæ”¾é”
    this.sessionLocks.delete(sessionId);

    console.log(`âœ… ä¼šè¯å·²é‡Šæ”¾: ${sessionId}`);
  }

  /**
   * è·å–æ‰€æœ‰æ´»è·ƒä¼šè¯
   */
  getActiveSessions(): Session[] {
    return Array.from(this.activeSessions.values());
  }

  /**
   * æ£€æŸ¥ä¼šè¯æ˜¯å¦è¢«é”å®š
   */
  isSessionLocked(sessionId: string): boolean {
    return this.sessionLocks.get(sessionId) || false;
  }
}

export { SessionIsolationManager };
```

### 5.2 èµ„æºç®¡ç†å’Œé…é¢

```typescript
/**
 * èµ„æºé…é¢ç®¡ç†å™¨
 */
class ResourceQuotaManager {
  private readonly MAX_ACTIVE_SESSIONS = 5;      // æœ€å¤§å¹¶å‘ä¼šè¯æ•°
  private readonly MAX_MESSAGES_PER_SESSION = 1000; // æ¯ä¸ªä¼šè¯æœ€å¤§æ¶ˆæ¯æ•°
  private readonly MAX_TOTAL_MEMORY_MB = 512;    // æœ€å¤§å†…å­˜ä½¿ç”¨(MB)

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºæ–°ä¼šè¯
   */
  canCreateSession(activeSessions: Session[]): boolean {
    if (activeSessions.length >= this.MAX_ACTIVE_SESSIONS) {
      console.warn(`âš ï¸  è¾¾åˆ°æœ€å¤§ä¼šè¯æ•°é™åˆ¶: ${this.MAX_ACTIVE_SESSIONS}`);
      return false;
    }

    // æ£€æŸ¥å†…å­˜ä½¿ç”¨
    const memoryUsageMB = process.memoryUsage().heapUsed / 1024 / 1024;
    if (memoryUsageMB > this.MAX_TOTAL_MEMORY_MB) {
      console.warn(`âš ï¸  å†…å­˜ä½¿ç”¨è¶…é™: ${memoryUsageMB.toFixed(2)}MB`);
      return false;
    }

    return true;
  }

  /**
   * æ£€æŸ¥ä¼šè¯æ˜¯å¦éœ€è¦æ¸…ç†
   */
  shouldCleanupSession(session: Session): boolean {
    // æ¶ˆæ¯æ•°è¿‡å¤š
    if (session.messages.length > this.MAX_MESSAGES_PER_SESSION) {
      return true;
    }

    // é•¿æ—¶é—´æœªæ´»è·ƒï¼ˆ24å°æ—¶ï¼‰
    const inactiveHours = (Date.now() - session.lastActiveAt.getTime()) / (1000 * 60 * 60);
    if (inactiveHours > 24) {
      return true;
    }

    return false;
  }

  /**
   * è·å–èµ„æºä½¿ç”¨æƒ…å†µ
   */
  getResourceUsage(sessions: Session[]): {
    sessionCount: number;
    totalMessages: number;
    totalTokens: number;
    memoryUsageMB: number;
  } {
    const totalMessages = sessions.reduce((sum, s) => sum + s.messages.length, 0);
    const totalTokens = sessions.reduce((sum, s) => sum + s.stats.tokensUsed, 0);
    const memoryUsageMB = process.memoryUsage().heapUsed / 1024 / 1024;

    return {
      sessionCount: sessions.length,
      totalMessages,
      totalTokens,
      memoryUsageMB
    };
  }

  /**
   * å»ºè®®æ¸…ç†å“ªäº›ä¼šè¯
   */
  suggestCleanup(sessions: Session[]): string[] {
    return sessions
      .filter(s => this.shouldCleanupSession(s))
      .map(s => s.id)
      .slice(0, Math.ceil(sessions.length * 0.2)); // æœ€å¤šæ¸…ç†20%
  }
}

export { ResourceQuotaManager };
```

---

## å…­ã€ä¼šè¯æ¸…ç†å’Œå½’æ¡£

### 6.1 è‡ªåŠ¨æ¸…ç†ç­–ç•¥

```typescript
/**
 * ä¼šè¯æ¸…ç†ç®¡ç†å™¨
 */
class SessionCleanupManager {
  private persistence: SessionPersistence;
  private cleanupIntervalMs: number = 60 * 60 * 1000; // 1å°æ—¶
  private timer?: NodeJS.Timer;

  constructor(persistence: SessionPersistence) {
    this.persistence = persistence;
  }

  /**
   * å¯åŠ¨è‡ªåŠ¨æ¸…ç†
   */
  startAutoCleanup(): void {
    console.log('ğŸ§¹ å¯åŠ¨è‡ªåŠ¨æ¸…ç†ä»»åŠ¡');

    this.timer = setInterval(async () => {
      await this.runCleanup();
    }, this.cleanupIntervalMs);
  }

  /**
   * åœæ­¢è‡ªåŠ¨æ¸…ç†
   */
  stopAutoCleanup(): void {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = undefined;
      console.log('ğŸ›‘ è‡ªåŠ¨æ¸…ç†å·²åœæ­¢');
    }
  }

  /**
   * æ‰§è¡Œæ¸…ç†ä»»åŠ¡
   */
  async runCleanup(): Promise<void> {
    console.log('ğŸ§¹ å¼€å§‹æ¸…ç†ä¼šè¯...');

    try {
      // 1. æ¸…ç†è¶…æ—¶ä¼šè¯ï¼ˆ7å¤©æœªæ´»è·ƒï¼‰
      await this.cleanupInactiveSessions(7);

      // 2. å½’æ¡£å·²å…³é—­ä¼šè¯ï¼ˆ30å¤©å‰ï¼‰
      await this.archiveClosedSessions(30);

      // 3. å‹ç¼©å†å²æ¶ˆæ¯ï¼ˆä¿ç•™æœ€è¿‘100æ¡ï¼‰
      await this.compressOldMessages(100);

      // 4. åˆ é™¤ä¸´æ—¶å¿«ç…§ï¼ˆä¿ç•™æœ€è¿‘5ä¸ªï¼‰
      await this.cleanupOldSnapshots(5);

      console.log('âœ… æ¸…ç†å®Œæˆ');
    } catch (error) {
      console.error('âŒ æ¸…ç†å¤±è´¥:', error);
    }
  }

  /**
   * æ¸…ç†ä¸æ´»è·ƒä¼šè¯
   */
  private async cleanupInactiveSessions(inactiveDays: number): Promise<void> {
    const cutoffTime = Date.now() - (inactiveDays * 24 * 60 * 60 * 1000);

    const db = (this.persistence as any).db;
    const result = db.prepare(`
      UPDATE sessions
      SET status = 'closed'
      WHERE status IN ('active', 'suspended') AND last_active_at < ?
    `).run(cutoffTime);

    if (result.changes > 0) {
      console.log(`  âœ… å·²å…³é—­ ${result.changes} ä¸ªä¸æ´»è·ƒä¼šè¯`);
    }
  }

  /**
   * å½’æ¡£å·²å…³é—­ä¼šè¯
   */
  private async archiveClosedSessions(olderThanDays: number): Promise<void> {
    const cutoffTime = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);

    // 1. æŸ¥æ‰¾éœ€è¦å½’æ¡£çš„ä¼šè¯
    const db = (this.persistence as any).db;
    const sessions = db.prepare(`
      SELECT id FROM sessions
      WHERE status = 'closed' AND last_active_at < ?
    `).all(cutoffTime) as any[];

    if (sessions.length === 0) {
      return;
    }

    console.log(`  ğŸ“¦ å½’æ¡£ ${sessions.length} ä¸ªä¼šè¯...`);

    // 2. å¯¼å‡ºä¸ºJSONæ–‡ä»¶
    for (const { id } of sessions) {
      await this.exportToArchive(id);
    }

    // 3. ä»æ•°æ®åº“åˆ é™¤
    const result = db.prepare(`
      DELETE FROM sessions WHERE status = 'closed' AND last_active_at < ?
    `).run(cutoffTime);

    console.log(`  âœ… å·²å½’æ¡£å¹¶åˆ é™¤ ${result.changes} ä¸ªä¼šè¯`);
  }

  /**
   * å¯¼å‡ºä¼šè¯åˆ°å½’æ¡£æ–‡ä»¶
   */
  private async exportToArchive(sessionId: string): Promise<void> {
    const session = await this.persistence.loadSession(sessionId);
    if (!session) {
      return;
    }

    // å½’æ¡£ç›®å½•: ~/.claude-code/archives/YYYY-MM/
    const archiveDir = path.join(
      process.env.HOME || process.env.USERPROFILE || '',
      '.claude-code',
      'archives',
      new Date().toISOString().slice(0, 7) // YYYY-MM
    );

    if (!fs.existsSync(archiveDir)) {
      fs.mkdirSync(archiveDir, { recursive: true });
    }

    // å½’æ¡£æ–‡ä»¶: session_{id}.json.gz
    const archivePath = path.join(archiveDir, `session_${sessionId}.json.gz`);

    // å‹ç¼©å¹¶ä¿å­˜
    const json = JSON.stringify(session, null, 2);
    const compressed = zlib.gzipSync(json);
    fs.writeFileSync(archivePath, compressed);

    console.log(`  ğŸ“¦ å·²å½’æ¡£: ${archivePath}`);
  }

  /**
   * å‹ç¼©æ—§æ¶ˆæ¯
   */
  private async compressOldMessages(keepRecentCount: number): Promise<void> {
    const db = (this.persistence as any).db;

    // å¯¹æ¯ä¸ªæ´»è·ƒä¼šè¯ï¼Œåªä¿ç•™æœ€è¿‘Næ¡æ¶ˆæ¯
    const sessions = db.prepare(`
      SELECT id FROM sessions WHERE status IN ('active', 'paused', 'suspended')
    `).all() as any[];

    let totalDeleted = 0;

    for (const { id } of sessions) {
      const result = db.prepare(`
        DELETE FROM messages
        WHERE session_id = ? AND id NOT IN (
          SELECT id FROM messages
          WHERE session_id = ?
          ORDER BY timestamp DESC
          LIMIT ?
        )
      `).run(id, id, keepRecentCount);

      totalDeleted += result.changes;
    }

    if (totalDeleted > 0) {
      console.log(`  âœ… å·²åˆ é™¤ ${totalDeleted} æ¡æ—§æ¶ˆæ¯`);
    }
  }

  /**
   * æ¸…ç†æ—§å¿«ç…§
   */
  private async cleanupOldSnapshots(keepRecentCount: number): Promise<void> {
    const db = (this.persistence as any).db;

    const sessions = db.prepare(`
      SELECT id FROM sessions WHERE status IN ('active', 'paused', 'suspended')
    `).all() as any[];

    let totalDeleted = 0;

    for (const { id } of sessions) {
      const result = db.prepare(`
        DELETE FROM context_snapshots
        WHERE session_id = ? AND id NOT IN (
          SELECT id FROM context_snapshots
          WHERE session_id = ?
          ORDER BY timestamp DESC
          LIMIT ?
        )
      `).run(id, id, keepRecentCount);

      totalDeleted += result.changes;
    }

    if (totalDeleted > 0) {
      console.log(`  âœ… å·²åˆ é™¤ ${totalDeleted} ä¸ªæ—§å¿«ç…§`);
    }
  }
}

export { SessionCleanupManager };
```

### 6.2 å½’æ¡£æ ¼å¼å’Œå¯¼å…¥å¯¼å‡º

```typescript
/**
 * ä¼šè¯å¯¼å…¥å¯¼å‡ºç®¡ç†å™¨
 */
class SessionImportExportManager {
  private persistence: SessionPersistence;

  constructor(persistence: SessionPersistence) {
    this.persistence = persistence;
  }

  /**
   * å¯¼å‡ºä¼šè¯ä¸ºJSONæ–‡ä»¶
   */
  async exportSession(sessionId: string, outputPath: string): Promise<void> {
    console.log(`ğŸ“¤ å¯¼å‡ºä¼šè¯: ${sessionId}`);

    // 1. åŠ è½½å®Œæ•´ä¼šè¯
    const session = await this.persistence.loadSession(sessionId);
    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }

    // 2. å‡†å¤‡å¯¼å‡ºæ•°æ®
    const exportData = {
      version: '1.0.0',
      exportedAt: new Date().toISOString(),
      session: {
        ...session,
        // è½¬æ¢Dateä¸ºISOå­—ç¬¦ä¸²
        createdAt: session.createdAt.toISOString(),
        lastActiveAt: session.lastActiveAt.toISOString()
      }
    };

    // 3. å†™å…¥æ–‡ä»¶
    fs.writeFileSync(outputPath, JSON.stringify(exportData, null, 2), 'utf-8');

    console.log(`âœ… ä¼šè¯å·²å¯¼å‡ºåˆ°: ${outputPath}`);
  }

  /**
   * å¯¼å…¥ä¼šè¯ä»JSONæ–‡ä»¶
   */
  async importSession(inputPath: string): Promise<Session> {
    console.log(`ğŸ“¥ å¯¼å…¥ä¼šè¯: ${inputPath}`);

    // 1. è¯»å–æ–‡ä»¶
    const content = fs.readFileSync(inputPath, 'utf-8');
    const exportData = JSON.parse(content);

    // 2. éªŒè¯ç‰ˆæœ¬
    if (exportData.version !== '1.0.0') {
      throw new Error(`Unsupported version: ${exportData.version}`);
    }

    // 3. æ¢å¤ä¼šè¯å¯¹è±¡
    const session: Session = {
      ...exportData.session,
      createdAt: new Date(exportData.session.createdAt),
      lastActiveAt: new Date(exportData.session.lastActiveAt),
      // ç”Ÿæˆæ–°çš„IDï¼ˆé¿å…å†²çªï¼‰
      id: uuidv4(),
      status: SessionStatus.CLOSED  // å¯¼å…¥çš„ä¼šè¯é»˜è®¤ä¸ºå…³é—­çŠ¶æ€
    };

    // 4. ä¿å­˜åˆ°æ•°æ®åº“
    await this.persistence.saveSession(session);

    console.log(`âœ… ä¼šè¯å·²å¯¼å…¥: ${session.id}`);
    return session;
  }

  /**
   * æ‰¹é‡å¯¼å‡ºæ‰€æœ‰ä¼šè¯
   */
  async exportAllSessions(outputDir: string): Promise<void> {
    console.log(`ğŸ“¤ æ‰¹é‡å¯¼å‡ºæ‰€æœ‰ä¼šè¯åˆ°: ${outputDir}`);

    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // åˆ—å‡ºæ‰€æœ‰ä¼šè¯
    const sessions = await this.persistence.listSessions();

    for (const partialSession of sessions) {
      const outputPath = path.join(
        outputDir,
        `session_${partialSession.id}_${Date.now()}.json`
      );

      try {
        await this.exportSession(partialSession.id!, outputPath);
      } catch (error) {
        console.error(`âŒ å¯¼å‡ºå¤±è´¥ [${partialSession.id}]:`, error.message);
      }
    }

    console.log(`âœ… æ‰¹é‡å¯¼å‡ºå®Œæˆï¼Œå…± ${sessions.length} ä¸ªä¼šè¯`);
  }

  /**
   * ä»å½’æ¡£æ¢å¤ä¼šè¯
   */
  async restoreFromArchive(archivePath: string): Promise<Session> {
    console.log(`ğŸ“¦ ä»å½’æ¡£æ¢å¤: ${archivePath}`);

    // å¦‚æœæ˜¯gzipå‹ç¼©æ–‡ä»¶
    let content: string;
    if (archivePath.endsWith('.gz')) {
      const compressed = fs.readFileSync(archivePath);
      const decompressed = zlib.gunzipSync(compressed);
      content = decompressed.toString('utf-8');
    } else {
      content = fs.readFileSync(archivePath, 'utf-8');
    }

    // è§£æå¹¶å¯¼å…¥
    const data = JSON.parse(content);

    const session: Session = {
      ...data,
      createdAt: new Date(data.createdAt),
      lastActiveAt: new Date(data.lastActiveAt)
    };

    await this.persistence.saveSession(session);

    console.log(`âœ… ä¼šè¯å·²ä»å½’æ¡£æ¢å¤: ${session.id}`);
    return session;
  }
}

export { SessionImportExportManager };
```

---

## ä¸ƒã€ä¼šè¯ç®¡ç†å™¨å®Œæ•´å®ç°

å°†æ‰€æœ‰ç»„ä»¶æ•´åˆåˆ°ä¸€èµ·:

```typescript
import * as zlib from 'zlib';
import * as path from 'path';
import * as fs from 'fs';
import { v4 as uuidv4 } from 'uuid';

/**
 * ä¼šè¯ç®¡ç†å™¨ - æ ¸å¿ƒç±»
 */
class SessionManager {
  private persistence: SessionPersistence;
  private stateManager: SessionStateManager;
  private recoveryManager: SessionRecoveryManager;
  private isolationManager: SessionIsolationManager;
  private quotaManager: ResourceQuotaManager;
  private cleanupManager: SessionCleanupManager;
  private importExportManager: SessionImportExportManager;
  private resumableTaskManager: ResumableTaskManager;

  private currentSession: Session | null = null;

  constructor(dbPath?: string) {
    // åˆå§‹åŒ–å„ä¸ªç»„ä»¶
    this.persistence = new SessionPersistence(dbPath);
    this.stateManager = new SessionStateManager();
    this.recoveryManager = new SessionRecoveryManager(this.persistence);
    this.isolationManager = new SessionIsolationManager();
    this.quotaManager = new ResourceQuotaManager();
    this.cleanupManager = new SessionCleanupManager(this.persistence);
    this.importExportManager = new SessionImportExportManager(this.persistence);
    this.resumableTaskManager = new ResumableTaskManager(this.persistence);
  }

  /**
   * å¯åŠ¨ä¼šè¯ç®¡ç†å™¨
   */
  async start(): Promise<void> {
    console.log('ğŸš€ å¯åŠ¨ä¼šè¯ç®¡ç†å™¨...');

    // 1. å°è¯•æ¢å¤æœªå…³é—­çš„ä¼šè¯
    const recovered = await this.recoveryManager.autoRecover();

    if (recovered.length > 0) {
      // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ¢å¤çš„ä¼šè¯
      this.currentSession = recovered[0];
      console.log(`âœ… å·²æ¢å¤ä¼šè¯: ${this.currentSession.id}`);
    } else {
      // åˆ›å»ºæ–°ä¼šè¯
      await this.createNewSession();
    }

    // 2. å¯åŠ¨è‡ªåŠ¨æ¸…ç†
    this.cleanupManager.startAutoCleanup();

    console.log('âœ… ä¼šè¯ç®¡ç†å™¨å·²å¯åŠ¨');
  }

  /**
   * åˆ›å»ºæ–°ä¼šè¯
   */
  async createNewSession(metadata?: Partial<Session['metadata']>): Promise<Session> {
    console.log('ğŸ†• åˆ›å»ºæ–°ä¼šè¯...');

    // æ£€æŸ¥èµ„æºé…é¢
    const activeSessions = this.isolationManager.getActiveSessions();
    if (!this.quotaManager.canCreateSession(activeSessions)) {
      throw new Error('æ— æ³•åˆ›å»ºæ–°ä¼šè¯ï¼šèµ„æºé…é¢ä¸è¶³');
    }

    // åˆ›å»ºä¼šè¯å¯¹è±¡
    const session: Session = {
      id: uuidv4(),
      createdAt: new Date(),
      lastActiveAt: new Date(),
      status: SessionStatus.CREATED,
      metadata: {
        workspaceRoot: process.cwd(),
        projectName: path.basename(process.cwd()),
        ...metadata
      },
      messages: [],
      systemPrompt: undefined,
      context: {
        files: [],
        recentEdits: [],
        snapshots: []
      },
      toolCalls: [],
      config: {
        model: 'claude-3-5-sonnet-20250929',
        maxTokens: 8000,
        temperature: 0,
        enableStreaming: true,
        enableToolCalling: true,
        maxToolCallDepth: 5,
        autoSave: true,
        autoSaveInterval: 60000
      },
      stats: {
        messageCount: 0,
        tokensUsed: 0,
        toolCallsCount: 0,
        filesModified: 0,
        startTime: Date.now(),
        lastActiveTime: Date.now(),
        totalDuration: 0
      },
      isPersisted: false,
      isDirty: false
    };

    // ä¿å­˜åˆ°æ•°æ®åº“
    await this.persistence.saveSession(session);

    // æ›´æ–°çŠ¶æ€
    this.stateManager.transition(SessionStatus.ACTIVE);
    session.status = SessionStatus.ACTIVE;

    // è®¾ç½®ä¸ºå½“å‰ä¼šè¯
    this.currentSession = session;

    console.log(`âœ… æ–°ä¼šè¯å·²åˆ›å»º: ${session.id}`);
    return session;
  }

  /**
   * è·å–å½“å‰ä¼šè¯
   */
  getCurrentSession(): Session | null {
    return this.currentSession;
  }

  /**
   * åˆ‡æ¢ä¼šè¯
   */
  async switchSession(sessionId: string): Promise<void> {
    console.log(`ğŸ”„ åˆ‡æ¢åˆ°ä¼šè¯: ${sessionId}`);

    // 1. ä¿å­˜å½“å‰ä¼šè¯
    if (this.currentSession) {
      await this.persistence.saveSession(this.currentSession);
      this.isolationManager.releaseSession(this.currentSession.id);
    }

    // 2. åŠ è½½æ–°ä¼šè¯
    this.currentSession = await this.isolationManager.acquireSession(sessionId);

    console.log(`âœ… å·²åˆ‡æ¢åˆ°ä¼šè¯: ${sessionId}`);
  }

  /**
   * æ·»åŠ æ¶ˆæ¯åˆ°å½“å‰ä¼šè¯
   */
  async addMessage(message: Omit<Message, 'id' | 'timestamp'>): Promise<Message> {
    if (!this.currentSession) {
      throw new Error('No active session');
    }

    const fullMessage: Message = {
      id: uuidv4(),
      timestamp: Date.now(),
      ...message
    };

    // æ·»åŠ åˆ°ä¼šè¯
    this.currentSession.messages.push(fullMessage);

    // æ›´æ–°ç»Ÿè®¡
    this.currentSession.stats.messageCount++;
    this.currentSession.stats.tokensUsed += fullMessage.tokens || 0;
    this.currentSession.stats.lastActiveTime = Date.now();
    this.currentSession.lastActiveAt = new Date();

    // æ ‡è®°ä¸ºè„æ•°æ®
    this.currentSession.isDirty = true;

    // å¢é‡ä¿å­˜
    await this.persistence.appendMessage(this.currentSession.id, fullMessage);

    return fullMessage;
  }

  /**
   * è®°å½•å·¥å…·è°ƒç”¨
   */
  async recordToolCall(toolCall: Omit<ToolCallRecord, 'id' | 'timestamp' | 'status'>): Promise<void> {
    if (!this.currentSession) {
      throw new Error('No active session');
    }

    const record: ToolCallRecord = {
      id: uuidv4(),
      timestamp: Date.now(),
      status: 'pending',
      ...toolCall
    };

    this.currentSession.toolCalls.push(record);
    this.currentSession.stats.toolCallsCount++;
    this.currentSession.isDirty = true;

    // ä¿å­˜åˆ°æ•°æ®åº“
    const db = (this.persistence as any).db;
    db.prepare(`
      INSERT INTO tool_calls (
        id, session_id, timestamp, tool_name, input, output, error, duration, status
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      record.id,
      this.currentSession.id,
      record.timestamp,
      record.toolName,
      JSON.stringify(record.input),
      record.output ? JSON.stringify(record.output) : null,
      record.error || null,
      record.duration || null,
      record.status
    );
  }

  /**
   * æ›´æ–°å·¥å…·è°ƒç”¨çŠ¶æ€
   */
  async updateToolCallStatus(
    toolCallId: string,
    status: 'success' | 'error',
    output?: any,
    error?: string,
    duration?: number
  ): Promise<void> {
    if (!this.currentSession) {
      throw new Error('No active session');
    }

    const toolCall = this.currentSession.toolCalls.find(t => t.id === toolCallId);
    if (!toolCall) {
      throw new Error(`Tool call ${toolCallId} not found`);
    }

    toolCall.status = status;
    toolCall.output = output;
    toolCall.error = error;
    toolCall.duration = duration;

    // æ›´æ–°æ•°æ®åº“
    const db = (this.persistence as any).db;
    db.prepare(`
      UPDATE tool_calls
      SET status = ?, output = ?, error = ?, duration = ?
      WHERE id = ?
    `).run(
      status,
      output ? JSON.stringify(output) : null,
      error || null,
      duration || null,
      toolCallId
    );
  }

  /**
   * åˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§
   */
  async createSnapshot(): Promise<void> {
    if (!this.currentSession) {
      throw new Error('No active session');
    }

    await this.recoveryManager.createCheckpoint(this.currentSession);
  }

  /**
   * ä¿å­˜å½“å‰ä¼šè¯
   */
  async save(): Promise<void> {
    if (!this.currentSession) {
      return;
    }

    await this.persistence.saveSession(this.currentSession);
    this.currentSession.isDirty = false;
    this.currentSession.isPersisted = true;

    console.log(`ğŸ’¾ ä¼šè¯å·²ä¿å­˜: ${this.currentSession.id}`);
  }

  /**
   * å…³é—­å½“å‰ä¼šè¯
   */
  async closeCurrentSession(): Promise<void> {
    if (!this.currentSession) {
      return;
    }

    console.log(`ğŸ”’ å…³é—­ä¼šè¯: ${this.currentSession.id}`);

    // 1. æ›´æ–°çŠ¶æ€
    this.stateManager.transition(SessionStatus.CLOSING);
    this.currentSession.status = SessionStatus.CLOSING;

    // 2. æœ€åä¸€æ¬¡ä¿å­˜
    await this.persistence.saveSession(this.currentSession);

    // 3. æ›´æ–°ä¸ºå·²å…³é—­
    this.currentSession.status = SessionStatus.CLOSED;
    await this.persistence.updateSessionStatus(this.currentSession.id, SessionStatus.CLOSED);

    // 4. é‡Šæ”¾èµ„æº
    await this.isolationManager.releaseSession(this.currentSession.id, false);

    this.currentSession = null;

    console.log('âœ… ä¼šè¯å·²å…³é—­');
  }

  /**
   * å…³é—­ä¼šè¯ç®¡ç†å™¨
   */
  async shutdown(): Promise<void> {
    console.log('ğŸ›‘ å…³é—­ä¼šè¯ç®¡ç†å™¨...');

    // 1. å…³é—­å½“å‰ä¼šè¯
    await this.closeCurrentSession();

    // 2. åœæ­¢è‡ªåŠ¨æ¸…ç†
    this.cleanupManager.stopAutoCleanup();

    // 3. å…³é—­æ•°æ®åº“è¿æ¥
    this.persistence.close();

    console.log('âœ… ä¼šè¯ç®¡ç†å™¨å·²å…³é—­');
  }

  /**
   * è·å–ä¼šè¯ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): any {
    const dbStats = this.persistence.getStats();
    const activeSessions = this.isolationManager.getActiveSessions();
    const resourceUsage = this.quotaManager.getResourceUsage(activeSessions);

    return {
      database: dbStats,
      resources: resourceUsage,
      currentSession: this.currentSession ? {
        id: this.currentSession.id,
        messageCount: this.currentSession.messages.length,
        tokensUsed: this.currentSession.stats.tokensUsed,
        toolCallsCount: this.currentSession.toolCalls.length,
        duration: Date.now() - this.currentSession.stats.startTime
      } : null
    };
  }

  /**
   * å¯¼å‡ºå½“å‰ä¼šè¯
   */
  async exportCurrentSession(outputPath: string): Promise<void> {
    if (!this.currentSession) {
      throw new Error('No active session');
    }

    await this.importExportManager.exportSession(this.currentSession.id, outputPath);
  }

  /**
   * å¯¼å…¥ä¼šè¯
   */
  async importSession(inputPath: string): Promise<Session> {
    return await this.importExportManager.importSession(inputPath);
  }
}

export { SessionManager };
```

---

## å…«ã€æœ€ä½³å®è·µ

### 8.1 ä¼šè¯ç®¡ç†å»ºè®®

1. **é¢‘ç¹ä¿å­˜**
   - ä½¿ç”¨è‡ªåŠ¨ä¿å­˜æœºåˆ¶
   - æ¯æ¬¡å…³é”®æ“ä½œåæ‰‹åŠ¨ä¿å­˜
   - è®¾ç½®åˆç†çš„ä¿å­˜é—´éš”ï¼ˆæ¨è1åˆ†é’Ÿï¼‰

2. **å®šæœŸæ¸…ç†**
   - å¯ç”¨è‡ªåŠ¨æ¸…ç†
   - å®šæœŸå½’æ¡£æ—§ä¼šè¯
   - å‹ç¼©å†å²æ¶ˆæ¯

3. **èµ„æºæ§åˆ¶**
   - é™åˆ¶å¹¶å‘ä¼šè¯æ•°
   - ç›‘æ§å†…å­˜ä½¿ç”¨
   - åŠæ—¶é‡Šæ”¾ä¸ç”¨çš„ä¼šè¯

4. **é”™è¯¯å¤„ç†**
   - å®ç°å®Œå–„çš„é”™è¯¯æ¢å¤æœºåˆ¶
   - ä¿å­˜å¤šä¸ªæ£€æŸ¥ç‚¹
   - æä¾›æ‰‹åŠ¨æ¢å¤é€‰é¡¹

5. **éšç§ä¿æŠ¤**
   - è¿‡æ»¤æ•æ„Ÿä¿¡æ¯
   - åŠ å¯†å­˜å‚¨ï¼ˆå¦‚éœ€è¦ï¼‰
   - å®šæœŸæ¸…ç†å†å²

### 8.2 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```typescript
/**
 * æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹
 */

// 1. æ‰¹é‡æ’å…¥æ¶ˆæ¯
async function batchInsertMessages(messages: Message[]): Promise<void> {
  const db = persistence.db;
  const transaction = db.transaction(() => {
    const insert = db.prepare(`
      INSERT INTO messages (id, session_id, role, content, timestamp)
      VALUES (?, ?, ?, ?, ?)
    `);

    for (const msg of messages) {
      insert.run(msg.id, sessionId, msg.role, msg.content, msg.timestamp);
    }
  });

  transaction();
}

// 2. ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
// å·²åœ¨Schemaä¸­å®šä¹‰ï¼Œç¡®ä¿æŸ¥è¯¢ä½¿ç”¨ç´¢å¼•
const recentMessages = db.prepare(`
  SELECT * FROM messages
  WHERE session_id = ?
  ORDER BY timestamp DESC
  LIMIT 100
`).all(sessionId);

// 3. å»¶è¿ŸåŠ è½½å¤§æ•°æ®
async function loadSessionLazy(sessionId: string): Promise<Session> {
  // å…ˆåŠ è½½åŸºæœ¬ä¿¡æ¯
  const session = await loadSessionBasic(sessionId);

  // æŒ‰éœ€åŠ è½½æ¶ˆæ¯
  session.loadMessages = async () => {
    return await loadMessages(sessionId);
  };

  return session;
}

// 4. ä½¿ç”¨å†…å­˜ç¼“å­˜
const sessionCache = new Map<string, Session>();

async function getCachedSession(sessionId: string): Promise<Session> {
  if (sessionCache.has(sessionId)) {
    return sessionCache.get(sessionId)!;
  }

  const session = await loadSession(sessionId);
  sessionCache.set(sessionId, session);
  return session;
}
```

---

## ä¹ã€å¸¸è§é—®é¢˜ FAQ

### Q1: ä¼šè¯æ•°æ®ä¼šå ç”¨å¤šå°‘ç©ºé—´ï¼Ÿ

**A:** å–å†³äºä½¿ç”¨æƒ…å†µï¼š
- åŸºæœ¬ä¼šè¯ï¼ˆ10æ¡æ¶ˆæ¯ï¼‰: ~50KB
- ä¸­ç­‰ä¼šè¯ï¼ˆ100æ¡æ¶ˆæ¯ï¼‰: ~500KB
- å¤§å‹ä¼šè¯ï¼ˆ1000æ¡æ¶ˆæ¯ï¼‰: ~5MB
- SQLiteæ•°æ®åº“å¼€é”€: ~10%

**å»ºè®®**:
- å®šæœŸæ¸…ç†æ—§ä¼šè¯
- å‹ç¼©å†å²æ¶ˆæ¯
- å½’æ¡£é•¿æœŸä¸ç”¨çš„ä¼šè¯

### Q2: å¦‚ä½•åœ¨å¤šå°è®¾å¤‡é—´åŒæ­¥ä¼šè¯ï¼Ÿ

**A:** æœ‰å‡ ç§æ–¹æ¡ˆï¼š

```typescript
// æ–¹æ¡ˆ1: å¯¼å‡º/å¯¼å…¥
// è®¾å¤‡Aå¯¼å‡º
await sessionManager.exportCurrentSession('/path/to/session.json');

// è®¾å¤‡Bå¯¼å…¥
await sessionManager.importSession('/path/to/session.json');

// æ–¹æ¡ˆ2: ä½¿ç”¨äº‘å­˜å‚¨åŒæ­¥æ•°æ®åº“æ–‡ä»¶
// å°† ~/.claude-code/sessions.db åŒæ­¥åˆ°äº‘ç›˜

// æ–¹æ¡ˆ3: å®ç°è¿œç¨‹åŒæ­¥æœåŠ¡ï¼ˆé«˜çº§ï¼‰
class RemoteSyncService {
  async syncToCloud(session: Session): Promise<void> {
    // ä¸Šä¼ åˆ°äº‘ç«¯
  }

  async syncFromCloud(sessionId: string): Promise<Session> {
    // ä»äº‘ç«¯ä¸‹è½½
  }
}
```

### Q3: ä¼šè¯å´©æºƒåå¦‚ä½•æ¢å¤ï¼Ÿ

**A:** ä½¿ç”¨æ¢å¤ç®¡ç†å™¨ï¼š

```typescript
// å¯åŠ¨æ—¶è‡ªåŠ¨æ¢å¤
const sessionManager = new SessionManager();
await sessionManager.start();  // ä¼šè‡ªåŠ¨å°è¯•æ¢å¤

// æˆ–æ‰‹åŠ¨æ¢å¤
const recoveryManager = new SessionRecoveryManager(persistence);
const recovered = await recoveryManager.autoRecover();

// å¦‚æœæ•°æ®æŸåï¼Œå°è¯•ä¿®å¤
const session = await recoveryManager.recoverSession(sessionId);
```

### Q4: å¦‚ä½•å®ç°ä¼šè¯çš„æ’¤é”€/é‡åšï¼Ÿ

**A:** åˆ©ç”¨æ¶ˆæ¯å†å²å’Œå¿«ç…§ï¼š

```typescript
class SessionUndoManager {
  private history: Array<{ messages: Message[], timestamp: number }> = [];
  private currentIndex: number = -1;

  /**
   * ä¿å­˜å¿«ç…§
   */
  saveSnapshot(messages: Message[]): void {
    // åˆ é™¤å½“å‰ä½ç½®ä¹‹åçš„å†å²
    this.history = this.history.slice(0, this.currentIndex + 1);

    // æ·»åŠ æ–°å¿«ç…§
    this.history.push({
      messages: JSON.parse(JSON.stringify(messages)),
      timestamp: Date.now()
    });

    this.currentIndex++;
  }

  /**
   * æ’¤é”€
   */
  undo(): Message[] | null {
    if (this.currentIndex <= 0) {
      return null;
    }

    this.currentIndex--;
    return this.history[this.currentIndex].messages;
  }

  /**
   * é‡åš
   */
  redo(): Message[] | null {
    if (this.currentIndex >= this.history.length - 1) {
      return null;
    }

    this.currentIndex++;
    return this.history[this.currentIndex].messages;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤é”€/é‡åš
   */
  canUndo(): boolean {
    return this.currentIndex > 0;
  }

  canRedo(): boolean {
    return this.currentIndex < this.history.length - 1;
  }
}
```

### Q5: å¦‚ä½•ç›‘æ§ä¼šè¯æ€§èƒ½ï¼Ÿ

**A:** å®ç°æ€§èƒ½ç›‘æ§ï¼š

```typescript
class SessionPerformanceMonitor {
  private metrics: {
    saveTime: number[];
    loadTime: number[];
    messageCount: number[];
  } = {
    saveTime: [],
    loadTime: [],
    messageCount: []
  };

  /**
   * æµ‹é‡ä¿å­˜æ—¶é—´
   */
  async measureSave(fn: () => Promise<void>): Promise<void> {
    const start = performance.now();
    await fn();
    const duration = performance.now() - start;

    this.metrics.saveTime.push(duration);

    if (duration > 1000) {
      console.warn(`âš ï¸  ä¿å­˜è€—æ—¶è¿‡é•¿: ${duration.toFixed(2)}ms`);
    }
  }

  /**
   * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
   */
  generateReport(): string {
    const avgSaveTime = this.average(this.metrics.saveTime);
    const avgLoadTime = this.average(this.metrics.loadTime);

    return `
æ€§èƒ½æŠ¥å‘Š:
- å¹³å‡ä¿å­˜æ—¶é—´: ${avgSaveTime.toFixed(2)}ms
- å¹³å‡åŠ è½½æ—¶é—´: ${avgLoadTime.toFixed(2)}ms
- ä¿å­˜æ“ä½œæ•°: ${this.metrics.saveTime.length}
- åŠ è½½æ“ä½œæ•°: ${this.metrics.loadTime.length}
    `.trim();
  }

  private average(arr: number[]): number {
    return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
  }
}
```

---

## åã€å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1: å®ç°ä¼šè¯åˆ—è¡¨å±•ç¤º

**ç›®æ ‡**: åˆ›å»ºä¸€ä¸ªCLIå·¥å…·ï¼Œå±•ç¤ºæ‰€æœ‰ä¼šè¯åˆ—è¡¨

```typescript
async function listSessions() {
  const persistence = new SessionPersistence();
  const sessions = await persistence.listSessions({ limit: 20 });

  console.log('\nä¼šè¯åˆ—è¡¨:\n');
  console.log('ID\t\t\t\tçŠ¶æ€\tæœ€åæ´»è·ƒ\t\tæ¶ˆæ¯æ•°');
  console.log('â”€'.repeat(80));

  for (const session of sessions) {
    console.log(
      `${session.id!.slice(0, 8)}\t` +
      `${session.status}\t` +
      `${session.lastActiveAt?.toLocaleString()}\t` +
      `${session.stats?.messageCount || 0}`
    );
  }

  console.log();
}
```

### ç»ƒä¹ 2: å®ç°ä¼šè¯æœç´¢

**ç›®æ ‡**: æ ¹æ®å…³é”®è¯æœç´¢ä¼šè¯ä¸­çš„æ¶ˆæ¯

```typescript
async function searchSessions(keyword: string): Promise<any[]> {
  const persistence = new SessionPersistence();
  const db = (persistence as any).db;

  const results = db.prepare(`
    SELECT
      m.id,
      m.session_id,
      m.role,
      m.content,
      m.timestamp,
      s.workspace_root,
      s.project_name
    FROM messages m
    JOIN sessions s ON m.session_id = s.id
    WHERE m.content LIKE ?
    ORDER BY m.timestamp DESC
    LIMIT 50
  `).all(`%${keyword}%`);

  return results;
}

// ä½¿ç”¨ç¤ºä¾‹
const results = await searchSessions('bug fix');
console.log(`æ‰¾åˆ° ${results.length} æ¡ç›¸å…³æ¶ˆæ¯`);
```

### ç»ƒä¹ 3: å®ç°ä¼šè¯ç»Ÿè®¡ä»ªè¡¨æ¿

**ç›®æ ‡**: å±•ç¤ºä¼šè¯ä½¿ç”¨ç»Ÿè®¡

```typescript
async function showDashboard() {
  const persistence = new SessionPersistence();
  const stats = persistence.getStats();

  console.log('\nğŸ“Š ä¼šè¯ç»Ÿè®¡ä»ªè¡¨æ¿\n');
  console.log('â”€'.repeat(50));
  console.log(`æ€»ä¼šè¯æ•°: ${stats.totalSessions}`);
  console.log(`æ´»è·ƒä¼šè¯: ${stats.activeSessions}`);
  console.log(`æ€»æ¶ˆæ¯æ•°: ${stats.totalMessages}`);
  console.log(`æ•°æ®åº“å¤§å°: ${(stats.dbSize / 1024 / 1024).toFixed(2)} MB`);
  console.log('â”€'.repeat(50));

  // å±•ç¤ºæœ€è¿‘æ´»è·ƒä¼šè¯
  const recentSessions = await persistence.listSessions({ limit: 5 });
  console.log('\næœ€è¿‘æ´»è·ƒçš„5ä¸ªä¼šè¯:');
  recentSessions.forEach((session, index) => {
    console.log(
      `${index + 1}. ${session.metadata?.projectName || 'Unnamed'} ` +
      `(${session.stats?.messageCount || 0} æ¡æ¶ˆæ¯)`
    );
  });

  console.log();
}
```

---

## åä¸€ã€æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†**
   - å®Œæ•´çš„çŠ¶æ€æœºè®¾è®¡
   - ä¸¥æ ¼çš„çŠ¶æ€è½¬æ¢è§„åˆ™
   - æ”¯æŒæš‚åœã€æ¢å¤ã€å…³é—­

2. **æŒä¹…åŒ–å­˜å‚¨**
   - é€‰æ‹©SQLiteä½œä¸ºå­˜å‚¨æ–¹æ¡ˆ
   - å®Œå–„çš„Schemaè®¾è®¡
   - æ”¯æŒäº‹åŠ¡å’Œå¤–é”®çº¦æŸ

3. **å´©æºƒæ¢å¤æœºåˆ¶**
   - è‡ªåŠ¨æ£€æµ‹æœªå…³é—­ä¼šè¯
   - æ•°æ®å®Œæ•´æ€§éªŒè¯
   - æ£€æŸ¥ç‚¹å’Œæ–­ç‚¹ç»­ä¼ 

4. **å¤šä¼šè¯ç®¡ç†**
   - ä¼šè¯éš”ç¦»å’Œé”æœºåˆ¶
   - èµ„æºé…é¢æ§åˆ¶
   - å¹¶å‘å®‰å…¨ä¿è¯

5. **æ¸…ç†å’Œå½’æ¡£**
   - è‡ªåŠ¨æ¸…ç†ç­–ç•¥
   - ä¼šè¯å½’æ¡£å¯¼å‡º
   - å†å²æ•°æ®å‹ç¼©

6. **æ€§èƒ½ä¼˜åŒ–**
   - æ‰¹é‡æ“ä½œ
   - ç´¢å¼•ä¼˜åŒ–
   - å»¶è¿ŸåŠ è½½

### ç³»åˆ—æ–‡ç« å¯¼èˆª

- [ç¬¬1ç¯‡: æ•´ä½“æ¶æ„è®¾è®¡](/ai/claude-code/architecture/01-overall-architecture)
- [ç¬¬2ç¯‡: æ ¸å¿ƒå¼•æ“å®ç°](/ai/claude-code/architecture/02-core-engine)
- [ç¬¬3ç¯‡: ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ](/ai/claude-code/architecture/03-context-management) (å³å°†å‘å¸ƒ)
- [ç¬¬4ç¯‡: ä¼šè¯ä¸çŠ¶æ€ç®¡ç†](/ai/claude-code/architecture/04-session-management) (å½“å‰)
- [ç¬¬5ç¯‡: å·¥å…·ç³»ç»Ÿæ¶æ„](/ai/claude-code/architecture/05-tools-system) (å³å°†å‘å¸ƒ)

---

**å¦‚æœè¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼Œæ¬¢è¿åˆ†äº«ç»™æ›´å¤šçš„æœ‹å‹ï¼**
