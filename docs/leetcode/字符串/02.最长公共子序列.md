# 最长公共子序列（Longest Common Subsequence）

## 📖 算法简介

最长公共子序列（Longest Common Subsequence，简称LCS）是计算机科学中的一个经典问题，属于动态规划的典型应用。该算法在生物信息学、版本控制系统、文本比较等领域有着广泛的应用。

**核心思想**：找到两个或多个序列中最长的公共子序列。

## 🎯 问题定义

### 基本概念

- **子序列（Subsequence）**：从原序列中删除一些元素（可以不删除任何元素）后得到的序列，**保持剩余元素的相对顺序不变**
- **公共子序列**：同时是多个序列的子序列
- **最长公共子序列**：所有公共子序列中长度最长的那个

### 示例说明

```
字符串1: "ABCDGH"
字符串2: "AEDFHR"

公共子序列: "A", "D", "H", "AD", "AH", "DH", "ADH"
最长公共子序列: "ADH" (长度为3)
```

**注意**：子序列 ≠ 子串
- 子序列：不要求连续，如"ACE"是"ABCDE"的子序列
- 子串：要求连续，如"BCD"是"ABCDE"的子串

## 🧠 算法原理

### 动态规划思路

设两个字符串分别为 `s1[0...m-1]` 和 `s2[0...n-1]`，定义状态：

**dp[i][j]** = s1的前i个字符与s2的前j个字符的最长公共子序列长度

### 状态转移方程

```
if s1[i-1] == s2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

### 边界条件

```
dp[0][j] = 0  (空字符串与任何字符串的LCS长度为0)
dp[i][0] = 0  (任何字符串与空字符串的LCS长度为0)
```

### 算法流程图

```
开始
  ↓
初始化dp数组
  ↓
遍历字符串s1 (i: 1 to m)
  ↓
  遍历字符串s2 (j: 1 to n)
    ↓
    s1[i-1] == s2[j-1]?
    ↓           ↓
   是          否
    ↓           ↓
dp[i][j] =   dp[i][j] = 
dp[i-1][j-1]+1  max(dp[i-1][j], dp[i][j-1])
    ↓           ↓
    ←-----------←
  ↓
返回dp[m][n]
  ↓
结束
```

## 💻 代码实现

### Java实现

#### 基础版本（求长度）

```java
public class LCS {
    /**
     * 计算两个字符串的最长公共子序列长度
     * @param text1 第一个字符串
     * @param text2 第二个字符串
     * @return 最长公共子序列的长度
     */
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        
        // 创建DP表格，dp[i][j]表示text1前i个字符和text2前j个字符的LCS长度
        int[][] dp = new int[m + 1][n + 1];
        
        // 填充DP表格
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    // 字符相同，LCS长度+1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 字符不同，取较大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
}
```

#### 完整版本（求具体序列）

```java
public class LCSComplete {
    /**
     * 获取最长公共子序列的具体内容
     * @param text1 第一个字符串
     * @param text2 第二个字符串
     * @return 最长公共子序列字符串
     */
    public String getLCS(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        // 构建DP表格
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        // 回溯构造LCS
        StringBuilder lcs = new StringBuilder();
        int i = m, j = n;
        
        while (i > 0 && j > 0) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                // 字符相同，加入LCS
                lcs.append(text1.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                // 向上回溯
                i--;
            } else {
                // 向左回溯
                j--;
            }
        }
        
        // 反转字符串（因为是从后往前构造的）
        return lcs.reverse().toString();
    }
}
```

### Python实现

#### 基础版本

```python
def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    计算两个字符串的最长公共子序列长度
    
    Args:
        text1: 第一个字符串
        text2: 第二个字符串
    
    Returns:
        最长公共子序列的长度
    """
    m, n = len(text1), len(text2)
    
    # 创建DP表格
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 填充DP表格
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]
```

#### 完整版本（含路径回溯）

```python
def get_lcs(text1: str, text2: str) -> str:
    """
    获取最长公共子序列的具体内容
    
    Args:
        text1: 第一个字符串
        text2: 第二个字符串
    
    Returns:
        最长公共子序列字符串
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 构建DP表格
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    # 回溯构造LCS
    lcs = []
    i, j = m, n
    
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            lcs.append(text1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    
    # 反转列表（因为是从后往前构造的）
    return ''.join(reversed(lcs))
```

### 测试代码

```python
# 测试用例
if __name__ == "__main__":
    text1 = "ABCDGH"
    text2 = "AEDFHR"
    
    length = longest_common_subsequence(text1, text2)
    lcs_str = get_lcs(text1, text2)
    
    print(f"字符串1: {text1}")
    print(f"字符串2: {text2}")
    print(f"LCS长度: {length}")
    print(f"LCS内容: {lcs_str}")
    
    # 输出:
    # 字符串1: ABCDGH
    # 字符串2: AEDFHR
    # LCS长度: 3
    # LCS内容: ADH
```

## 📊 复杂度分析

### 时间复杂度
- **O(m × n)**：需要填充m×n的DP表格
- 其中m和n分别是两个字符串的长度

### 空间复杂度
- **基础版本**：O(m × n) - 需要二维DP数组
- **优化版本**：O(min(m, n)) - 使用滚动数组优化

## 🚀 算法优化

### 1. 空间优化 - 滚动数组

```python
def lcs_space_optimized(text1: str, text2: str) -> int:
    """
    空间优化版本的LCS算法
    空间复杂度从O(m*n)优化到O(min(m,n))
    """
    m, n = len(text1), len(text2)
    
    # 确保text2是较短的字符串，减少空间使用
    if m < n:
        text1, text2 = text2, text1
        m, n = n, m
    
    # 只需要两行数组
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                curr[j] = prev[j - 1] + 1
            else:
                curr[j] = max(prev[j], curr[j - 1])
        
        # 交换数组
        prev, curr = curr, prev
    
    return prev[n]
```

### 2. 进一步空间优化

```python
def lcs_ultra_optimized(text1: str, text2: str) -> int:
    """
    极致空间优化版本
    只使用一维数组
    """
    m, n = len(text1), len(text2)
    
    if m < n:
        text1, text2 = text2, text1
        m, n = n, m
    
    dp = [0] * (n + 1)
    
    for i in range(1, m + 1):
        prev = 0  # 相当于dp[i-1][j-1]
        for j in range(1, n + 1):
            temp = dp[j]  # 保存dp[i-1][j]
            if text1[i - 1] == text2[j - 1]:
                dp[j] = prev + 1
            else:
                dp[j] = max(dp[j], dp[j - 1])
            prev = temp
    
    return dp[n]
```

## 🔄 变种问题

### 1. 最长公共子串（连续）

```python
def longest_common_substring(text1: str, text2: str) -> int:
    """
    最长公共子串（要求连续）
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_length = 0
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                max_length = max(max_length, dp[i][j])
            else:
                dp[i][j] = 0  # 不连续则重置为0
    
    return max_length
```

### 2. 多个序列的LCS

```python
def lcs_multiple(sequences):
    """
    计算多个序列的最长公共子序列
    """
    if not sequences:
        return 0
    
    if len(sequences) == 1:
        return len(sequences[0])
    
    # 递归处理：LCS(s1,s2,s3) = LCS(LCS(s1,s2), s3)
    result = sequences[0]
    for i in range(1, len(sequences)):
        result = get_lcs(result, sequences[i])
    
    return len(result)
```

### 3. 编辑距离与LCS的关系

```python
def edit_distance_from_lcs(text1: str, text2: str) -> int:
    """
    通过LCS计算编辑距离
    编辑距离 = m + n - 2 * LCS长度
    """
    m, n = len(text1), len(text2)
    lcs_length = longest_common_subsequence(text1, text2)
    
    # 需要删除的字符数 + 需要插入的字符数
    return (m - lcs_length) + (n - lcs_length)
```

## 🎯 实际应用场景

### 1. 版本控制系统
- **Git diff算法**：比较文件版本差异
- **代码合并**：找到不同分支的公共部分

### 2. 生物信息学
- **DNA序列比对**：找到基因序列的相似性
- **蛋白质结构分析**：比较蛋白质序列

### 3. 文本处理
- **抄袭检测**：比较文档相似度
- **翻译记忆**：找到相似的翻译片段

### 4. 数据同步
- **数据库同步**：找到需要更新的记录
- **文件同步**：增量备份和同步

## 📝 常见面试题

### 1. LeetCode 1143: 最长公共子序列

**题目**：给定两个字符串text1和text2，返回这两个字符串的最长公共子序列的长度。

**解答要点**：
- 理解子序列的定义
- 正确设计DP状态和转移方程
- 注意边界条件的处理

### 2. 如何构造具体的LCS序列？

**解答思路**：
1. 先用DP求出长度
2. 从dp[m][n]开始回溯
3. 根据状态转移的逆过程构造序列

### 3. 空间复杂度如何优化？

**解答要点**：
- 观察到每次只需要前一行的信息
- 使用滚动数组技术
- 进一步优化到一维数组

### 4. LCS与编辑距离的关系？

**解答**：
- 编辑距离 = m + n - 2 × LCS长度
- 两者都是衡量字符串相似性的指标
- LCS关注公共部分，编辑距离关注差异部分

## 📈 性能对比

| 算法版本 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|-----------|-----------|----------|
| 基础DP | O(mn) | O(mn) | 需要构造具体LCS |
| 滚动数组 | O(mn) | O(min(m,n)) | 只需要长度 |
| 一维优化 | O(mn) | O(min(m,n)) | 内存受限环境 |
| 递归+记忆化 | O(mn) | O(mn) | 理解递归思路 |

## 🎓 学习总结

### 核心要点
1. **理解概念**：区分子序列和子串的概念
2. **DP设计**：正确定义状态和转移方程
3. **边界处理**：注意数组下标和边界条件
4. **空间优化**：掌握滚动数组等优化技巧
5. **路径回溯**：能够构造具体的LCS序列

### 解题技巧
1. **画图分析**：用小例子理解DP过程
2. **状态定义**：明确dp[i][j]的含义
3. **转移推导**：从递归关系推导DP方程
4. **代码实现**：注意数组下标的对应关系

### 扩展学习
- 最长递增子序列（LIS）
- 最长回文子序列
- 编辑距离算法
- 序列DP的其他应用

---

**总结**：最长公共子序列是动态规划的经典问题，掌握其原理和实现对理解DP思想具有重要意义。在实际应用中，要根据具体需求选择合适的实现版本，平衡时间和空间复杂度。