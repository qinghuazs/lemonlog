# å…¨æ’åˆ—ï¼ˆPermutationsï¼‰

## ğŸ“– ç®—æ³•ç®€ä»‹

å…¨æ’åˆ—æ˜¯ç»„åˆæ•°å­¦ä¸­çš„åŸºæœ¬æ¦‚å¿µï¼Œä¹Ÿæ˜¯å›æº¯ç®—æ³•çš„ç»å…¸åº”ç”¨ã€‚ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ï¼Œè¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—ã€‚è¿™ä¸ªé—®é¢˜åœ¨ç®—æ³•é¢è¯•ä¸­å‡ºç°é¢‘ç‡æé«˜ï¼Œæ˜¯ç†è§£å›æº¯æ€æƒ³çš„é‡è¦å…¥é—¨é¢˜ç›®ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼šé€šè¿‡æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œåœ¨æœç´¢è¿‡ç¨‹ä¸­åšé€‰æ‹©ï¼Œåˆ°è¾¾å¶å­èŠ‚ç‚¹æ—¶æ’¤é”€é€‰æ‹©ï¼ˆå›æº¯ï¼‰ã€‚

## ğŸ¯ é—®é¢˜å®šä¹‰

### åŸºæœ¬æ¦‚å¿µ

- **æ’åˆ—ï¼ˆPermutationï¼‰**ï¼šä»nä¸ªä¸åŒå…ƒç´ ä¸­å–å‡ºmä¸ªå…ƒç´ ï¼ŒæŒ‰ç…§ä¸€å®šé¡ºåºæ’æˆä¸€åˆ—
- **å…¨æ’åˆ—**ï¼šå–å‡ºæ‰€æœ‰nä¸ªå…ƒç´ è¿›è¡Œæ’åˆ—ï¼Œè®°ä½œP(n,n) = n!
- **ç»„åˆ vs æ’åˆ—**ï¼šç»„åˆä¸è€ƒè™‘é¡ºåºï¼Œæ’åˆ—è€ƒè™‘é¡ºåº

### ç¤ºä¾‹è¯´æ˜

```
è¾“å…¥: nums = [1,2,3]
è¾“å‡º: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

è¾“å…¥: nums = [0,1]
è¾“å‡º: [[0,1],[1,0]]

è¾“å…¥: nums = [1]
è¾“å‡º: [[1]]
```

### æ•°å­¦åŸºç¡€

- nä¸ªä¸åŒå…ƒç´ çš„å…¨æ’åˆ—æ•°é‡ï¼š**n!**
- ä¾‹å¦‚ï¼š3ä¸ªå…ƒç´ æœ‰3! = 6ç§æ’åˆ—ï¼Œ4ä¸ªå…ƒç´ æœ‰4! = 24ç§æ’åˆ—

## ğŸ§  ç®—æ³•åŸç†

### å›æº¯ç®—æ³•æ€æƒ³

å›æº¯ç®—æ³•æ˜¯ä¸€ç§é€šè¿‡æ¢ç´¢æ‰€æœ‰å¯èƒ½çš„å€™é€‰è§£æ¥æ‰¾å‡ºæ‰€æœ‰è§£çš„ç®—æ³•ã€‚å¦‚æœå€™é€‰è§£è¢«ç¡®è®¤ä¸æ˜¯ä¸€ä¸ªè§£ï¼Œå›æº¯ç®—æ³•ä¼šèˆå¼ƒè¯¥å€™é€‰è§£ï¼Œå¹¶åœ¨ä¸Šä¸€æ­¥è¿›è¡Œä¸€äº›ä¿®æ”¹åé‡æ–°å°è¯•ã€‚

### å›æº¯ä¸‰è¦ç´ 

1. **é€‰æ‹©åˆ—è¡¨**ï¼šå½“å‰å¯ä»¥åšçš„é€‰æ‹©
2. **è·¯å¾„**ï¼šå·²ç»åšè¿‡çš„é€‰æ‹©
3. **ç»“æŸæ¡ä»¶**ï¼šåˆ°è¾¾å†³ç­–æ ‘åº•å±‚ï¼Œæ— æ³•å†åšé€‰æ‹©çš„æ¡ä»¶

### é€’å½’æ ‘åˆ†æ

ä»¥[1,2,3]ä¸ºä¾‹çš„é€’å½’æ ‘ï¼š

```
                    []
                 /  |  \
               1/   |2  \3
               /    |    \
           [1]     [2]   [3]
          / \      / \    / \
        2/   \3   1/  \3  1/  \2
        /     \   /    \  /    \
    [1,2]   [1,3] [2,1] [2,3] [3,1] [3,2]
      |       |     |     |     |     |
      3       2     3     1     2     1
      |       |     |     |     |     |
  [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1]
```

### ç®—æ³•æµç¨‹

```
1. å®šä¹‰é€’å½’å‡½æ•° backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨)
2. å¦‚æœè·¯å¾„é•¿åº¦ç­‰äºæ•°ç»„é•¿åº¦ï¼Œæ·»åŠ åˆ°ç»“æœé›†
3. éå†é€‰æ‹©åˆ—è¡¨ï¼š
   - åšé€‰æ‹©ï¼šå°†å…ƒç´ åŠ å…¥è·¯å¾„
   - é€’å½’è°ƒç”¨ï¼šbacktrack(æ–°è·¯å¾„, æ–°é€‰æ‹©åˆ—è¡¨)
   - æ’¤é”€é€‰æ‹©ï¼šå°†å…ƒç´ ä»è·¯å¾„ä¸­ç§»é™¤
```

## ğŸ’» ä»£ç å®ç°

### æ–¹æ³•ä¸€ï¼šæ ‡å‡†å›æº¯æ³•ï¼ˆä½¿ç”¨usedæ•°ç»„ï¼‰

#### Javaå®ç°

```java
import java.util.*;

public class Permutations {
    /**
     * ç”Ÿæˆæ•°ç»„çš„æ‰€æœ‰å…¨æ’åˆ—
     * @param nums è¾“å…¥æ•°ç»„
     * @return æ‰€æœ‰æ’åˆ—çš„åˆ—è¡¨
     */
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        
        backtrack(nums, path, used, result);
        return result;
    }
    
    /**
     * å›æº¯å‡½æ•°
     * @param nums åŸæ•°ç»„
     * @param path å½“å‰è·¯å¾„
     * @param used ä½¿ç”¨çŠ¶æ€æ•°ç»„
     * @param result ç»“æœé›†
     */
    private void backtrack(int[] nums, List<Integer> path, 
                          boolean[] used, List<List<Integer>> result) {
        // ç»“æŸæ¡ä»¶ï¼šè·¯å¾„é•¿åº¦ç­‰äºæ•°ç»„é•¿åº¦
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path)); // æ³¨æ„ï¼šéœ€è¦åˆ›å»ºæ–°çš„ArrayList
            return;
        }
        
        // éå†é€‰æ‹©åˆ—è¡¨
        for (int i = 0; i < nums.length; i++) {
            // è·³è¿‡å·²ä½¿ç”¨çš„å…ƒç´ 
            if (used[i]) {
                continue;
            }
            
            // åšé€‰æ‹©
            path.add(nums[i]);
            used[i] = true;
            
            // é€’å½’
            backtrack(nums, path, used, result);
            
            // æ’¤é”€é€‰æ‹©ï¼ˆå›æº¯ï¼‰
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```

#### Pythonå®ç°

```python
from typing import List

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        """
        ç”Ÿæˆæ•°ç»„çš„æ‰€æœ‰å…¨æ’åˆ—
        
        Args:
            nums: è¾“å…¥æ•°ç»„
        
        Returns:
            æ‰€æœ‰æ’åˆ—çš„åˆ—è¡¨
        """
        result = []
        path = []
        used = [False] * len(nums)
        
        self.backtrack(nums, path, used, result)
        return result
    
    def backtrack(self, nums: List[int], path: List[int], 
                  used: List[bool], result: List[List[int]]) -> None:
        """
        å›æº¯å‡½æ•°
        
        Args:
            nums: åŸæ•°ç»„
            path: å½“å‰è·¯å¾„
            used: ä½¿ç”¨çŠ¶æ€æ•°ç»„
            result: ç»“æœé›†
        """
        # ç»“æŸæ¡ä»¶
        if len(path) == len(nums):
            result.append(path[:])  # æ³¨æ„ï¼šéœ€è¦å¤åˆ¶è·¯å¾„
            return
        
        # éå†é€‰æ‹©åˆ—è¡¨
        for i in range(len(nums)):
            # è·³è¿‡å·²ä½¿ç”¨çš„å…ƒç´ 
            if used[i]:
                continue
            
            # åšé€‰æ‹©
            path.append(nums[i])
            used[i] = True
            
            # é€’å½’
            self.backtrack(nums, path, used, result)
            
            # æ’¤é”€é€‰æ‹©ï¼ˆå›æº¯ï¼‰
            path.pop()
            used[i] = False
```

### æ–¹æ³•äºŒï¼šäº¤æ¢æ³•ï¼ˆç©ºé—´ä¼˜åŒ–ï¼‰

```python
class SolutionSwap:
    def permute(self, nums: List[int]) -> List[List[int]]:
        """
        ä½¿ç”¨äº¤æ¢æ³•ç”Ÿæˆå…¨æ’åˆ—ï¼Œç©ºé—´å¤æ‚åº¦æ›´ä¼˜
        """
        result = []
        self.backtrack_swap(nums, 0, result)
        return result
    
    def backtrack_swap(self, nums: List[int], start: int, 
                      result: List[List[int]]) -> None:
        """
        äº¤æ¢æ³•å›æº¯
        
        Args:
            nums: æ•°ç»„ï¼ˆä¼šè¢«ä¿®æ”¹ï¼‰
            start: å½“å‰å¤„ç†çš„ä½ç½®
            result: ç»“æœé›†
        """
        # ç»“æŸæ¡ä»¶
        if start == len(nums):
            result.append(nums[:])
            return
        
        # å°è¯•å°†æ¯ä¸ªå…ƒç´ æ”¾åˆ°startä½ç½®
        for i in range(start, len(nums)):
            # äº¤æ¢
            nums[start], nums[i] = nums[i], nums[start]
            
            # é€’å½’å¤„ç†ä¸‹ä¸€ä¸ªä½ç½®
            self.backtrack_swap(nums, start + 1, result)
            
            # å›æº¯ï¼šäº¤æ¢å›æ¥
            nums[start], nums[i] = nums[i], nums[start]
```

### æ–¹æ³•ä¸‰ï¼šè¿­ä»£å®ç°

```python
from collections import deque

class SolutionIterative:
    def permute(self, nums: List[int]) -> List[List[int]]:
        """
        è¿­ä»£æ–¹å¼ç”Ÿæˆå…¨æ’åˆ—
        """
        if not nums:
            return []
        
        # ä½¿ç”¨é˜Ÿåˆ—å­˜å‚¨ä¸­é—´ç»“æœ
        queue = deque([[]])
        
        for num in nums:
            # å¤„ç†é˜Ÿåˆ—ä¸­çš„æ¯ä¸ªæ’åˆ—
            for _ in range(len(queue)):
                perm = queue.popleft()
                
                # å°†å½“å‰æ•°å­—æ’å…¥åˆ°æ’åˆ—çš„æ¯ä¸ªå¯èƒ½ä½ç½®
                for i in range(len(perm) + 1):
                    new_perm = perm[:i] + [num] + perm[i:]
                    queue.append(new_perm)
        
        return list(queue)
```

### æµ‹è¯•ä»£ç 

```python
def test_permutations():
    """
    æµ‹è¯•å…¨æ’åˆ—ç®—æ³•
    """
    solution = Solution()
    
    # æµ‹è¯•ç”¨ä¾‹1
    nums1 = [1, 2, 3]
    result1 = solution.permute(nums1)
    print(f"è¾“å…¥: {nums1}")
    print(f"è¾“å‡º: {result1}")
    print(f"æ’åˆ—æ•°é‡: {len(result1)}")
    print()
    
    # æµ‹è¯•ç”¨ä¾‹2
    nums2 = [0, 1]
    result2 = solution.permute(nums2)
    print(f"è¾“å…¥: {nums2}")
    print(f"è¾“å‡º: {result2}")
    print(f"æ’åˆ—æ•°é‡: {len(result2)}")
    print()
    
    # æµ‹è¯•ç”¨ä¾‹3
    nums3 = [1]
    result3 = solution.permute(nums3)
    print(f"è¾“å…¥: {nums3}")
    print(f"è¾“å‡º: {result3}")
    print(f"æ’åˆ—æ•°é‡: {len(result3)}")

if __name__ == "__main__":
    test_permutations()
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

### æ—¶é—´å¤æ‚åº¦
- **O(n Ã— n!)**
  - å…±æœ‰n!ä¸ªæ’åˆ—
  - æ¯ä¸ªæ’åˆ—éœ€è¦O(n)æ—¶é—´å¤åˆ¶åˆ°ç»“æœé›†
  - æ€»æ—¶é—´å¤æ‚åº¦ï¼šO(n Ã— n!)

### ç©ºé—´å¤æ‚åº¦
- **æ ‡å‡†å›æº¯æ³•**ï¼šO(n) - é€’å½’æ ˆæ·±åº¦ + usedæ•°ç»„
- **äº¤æ¢æ³•**ï¼šO(n) - ä»…é€’å½’æ ˆæ·±åº¦
- **ç»“æœå­˜å‚¨**ï¼šO(n Ã— n!) - å­˜å‚¨æ‰€æœ‰æ’åˆ—

### æ€§èƒ½å¯¹æ¯”

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|-----------|-----------|------|------|
| æ ‡å‡†å›æº¯ | O(nÃ—n!) | O(n) | æ€è·¯æ¸…æ™°ï¼Œæ˜“ç†è§£ | éœ€è¦é¢å¤–usedæ•°ç»„ |
| äº¤æ¢æ³• | O(nÃ—n!) | O(n) | ç©ºé—´æ•ˆç‡é«˜ | ä¼šä¿®æ”¹åŸæ•°ç»„ |
| è¿­ä»£æ³• | O(nÃ—n!) | O(nÃ—n!) | æ— é€’å½’è°ƒç”¨ | ç©ºé—´æ¶ˆè€—å¤§ |

## ğŸš€ ç®—æ³•ä¼˜åŒ–

### 1. å‰ªæä¼˜åŒ–ï¼ˆå¤„ç†é‡å¤å…ƒç´ ï¼‰

å½“æ•°ç»„åŒ…å«é‡å¤å…ƒç´ æ—¶ï¼Œéœ€è¦è¿›è¡Œå‰ªæé¿å…é‡å¤æ’åˆ—ï¼š

```python
class SolutionII:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        """
        å…¨æ’åˆ— IIï¼šåŒ…å«é‡å¤æ•°å­—çš„å…¨æ’åˆ—
        """
        result = []
        path = []
        used = [False] * len(nums)
        
        # æ’åºæ˜¯å‰ªæçš„å‰æ
        nums.sort()
        
        self.backtrack(nums, path, used, result)
        return result
    
    def backtrack(self, nums: List[int], path: List[int], 
                  used: List[bool], result: List[List[int]]) -> None:
        if len(path) == len(nums):
            result.append(path[:])
            return
        
        for i in range(len(nums)):
            if used[i]:
                continue
            
            # å‰ªæï¼šè·³è¿‡é‡å¤å…ƒç´ 
            # å¦‚æœå½“å‰å…ƒç´ ä¸å‰ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œä¸”å‰ä¸€ä¸ªå…ƒç´ æœªè¢«ä½¿ç”¨ï¼Œåˆ™è·³è¿‡
            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
                continue
            
            path.append(nums[i])
            used[i] = True
            
            self.backtrack(nums, path, used, result)
            
            path.pop()
            used[i] = False
```

### 2. å†…å­˜ä¼˜åŒ–

```python
class SolutionGenerator:
    def permute_generator(self, nums: List[int]):
        """
        ç”Ÿæˆå™¨ç‰ˆæœ¬ï¼ŒæŒ‰éœ€ç”Ÿæˆæ’åˆ—ï¼ŒèŠ‚çœå†…å­˜
        """
        def backtrack(path, used):
            if len(path) == len(nums):
                yield path[:]
                return
            
            for i in range(len(nums)):
                if used[i]:
                    continue
                
                path.append(nums[i])
                used[i] = True
                
                yield from backtrack(path, used)
                
                path.pop()
                used[i] = False
        
        yield from backtrack([], [False] * len(nums))
```

## ğŸ”„ å˜ç§é—®é¢˜

### 1. ä¸‹ä¸€ä¸ªæ’åˆ—

```python
class NextPermutation:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        æ‰¾åˆ°å­—å…¸åºä¸­ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—
        å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™é‡æ–°æ’åˆ—æˆæœ€å°çš„æ’åˆ—
        """
        # ä»å³å‘å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå‡åºå¯¹
        i = len(nums) - 2
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        
        if i >= 0:
            # ä»å³å‘å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºnums[i]çš„å…ƒç´ 
            j = len(nums) - 1
            while nums[j] <= nums[i]:
                j -= 1
            
            # äº¤æ¢
            nums[i], nums[j] = nums[j], nums[i]
        
        # åè½¬i+1åˆ°æœ«å°¾çš„éƒ¨åˆ†
        self.reverse(nums, i + 1)
    
    def reverse(self, nums: List[int], start: int) -> None:
        """åè½¬æ•°ç»„çš„æŒ‡å®šéƒ¨åˆ†"""
        end = len(nums) - 1
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1
```

### 2. ç¬¬kä¸ªæ’åˆ—

```python
class KthPermutation:
    def getPermutation(self, n: int, k: int) -> str:
        """
        ç›´æ¥è®¡ç®—ç¬¬kä¸ªæ’åˆ—ï¼Œä¸ç”Ÿæˆæ‰€æœ‰æ’åˆ—
        """
        # è®¡ç®—é˜¶ä¹˜
        factorial = [1] * n
        for i in range(1, n):
            factorial[i] = factorial[i-1] * i
        
        # å¯é€‰æ•°å­—
        numbers = list(range(1, n + 1))
        result = []
        k -= 1  # è½¬æ¢ä¸º0ç´¢å¼•
        
        for i in range(n):
            # è®¡ç®—å½“å‰ä½ç½®åº”è¯¥é€‰æ‹©çš„æ•°å­—
            index = k // factorial[n - 1 - i]
            result.append(str(numbers[index]))
            numbers.pop(index)
            k %= factorial[n - 1 - i]
        
        return ''.join(result)
```

### 3. éƒ¨åˆ†æ’åˆ—

```python
class PartialPermutation:
    def permute_partial(self, nums: List[int], k: int) -> List[List[int]]:
        """
        ç”Ÿæˆé•¿åº¦ä¸ºkçš„éƒ¨åˆ†æ’åˆ—
        """
        result = []
        path = []
        used = [False] * len(nums)
        
        self.backtrack(nums, k, path, used, result)
        return result
    
    def backtrack(self, nums: List[int], k: int, path: List[int], 
                  used: List[bool], result: List[List[int]]) -> None:
        if len(path) == k:
            result.append(path[:])
            return
        
        for i in range(len(nums)):
            if used[i]:
                continue
            
            path.append(nums[i])
            used[i] = True
            
            self.backtrack(nums, k, path, used, result)
            
            path.pop()
            used[i] = False
```

## ğŸ¯ å®é™…åº”ç”¨åœºæ™¯

### 1. å¯†ç ç ´è§£
```python
def crack_password(chars: str, length: int):
    """
    ç”ŸæˆæŒ‡å®šé•¿åº¦çš„æ‰€æœ‰å¯èƒ½å¯†ç ç»„åˆ
    """
    from itertools import permutations
    
    for perm in permutations(chars, length):
        yield ''.join(perm)
```

### 2. ä»»åŠ¡è°ƒåº¦
```python
def find_optimal_schedule(tasks: List[str]) -> List[str]:
    """
    æ‰¾åˆ°æœ€ä¼˜çš„ä»»åŠ¡æ‰§è¡Œé¡ºåº
    """
    min_cost = float('inf')
    best_schedule = None
    
    for schedule in permutations(tasks):
        cost = calculate_cost(schedule)
        if cost < min_cost:
            min_cost = cost
            best_schedule = schedule
    
    return list(best_schedule)
```

### 3. æ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰
```python
def tsp_brute_force(cities: List[int], distances: List[List[int]]) -> tuple:
    """
    æš´åŠ›è§£æ³•æ±‚è§£æ—…è¡Œå•†é—®é¢˜
    """
    n = len(cities)
    min_distance = float('inf')
    best_path = None
    
    # å›ºå®šèµ·ç‚¹ï¼Œå¯¹å…¶ä»–åŸå¸‚è¿›è¡Œå…¨æ’åˆ—
    for perm in permutations(cities[1:]):
        path = [cities[0]] + list(perm) + [cities[0]]
        distance = sum(distances[path[i]][path[i+1]] for i in range(n))
        
        if distance < min_distance:
            min_distance = distance
            best_path = path
    
    return best_path, min_distance
```

## ğŸ“ å¸¸è§é¢è¯•é¢˜

### 1. LeetCode 46: å…¨æ’åˆ—

**é¢˜ç›®**ï¼šç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„numsï¼Œè¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—ã€‚

**è§£é¢˜è¦ç‚¹**ï¼š
- ç†è§£å›æº¯ç®—æ³•çš„åŸºæœ¬æ€æƒ³
- æ­£ç¡®å®ç°é€’å½’å’Œå›æº¯è¿‡ç¨‹
- æ³¨æ„ç»“æœé›†ä¸­éœ€è¦å¤åˆ¶è·¯å¾„

### 2. LeetCode 47: å…¨æ’åˆ— II

**é¢˜ç›®**ï¼šç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ—numsï¼ŒæŒ‰ä»»æ„é¡ºåºè¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚

**è§£é¢˜è¦ç‚¹**ï¼š
- æ’åºæ˜¯å‰ªæçš„å‰æ
- ç†è§£å‰ªææ¡ä»¶ï¼š`nums[i] == nums[i-1] and not used[i-1]`
- é¿å…é‡å¤æ’åˆ—çš„ç”Ÿæˆ

### 3. LeetCode 31: ä¸‹ä¸€ä¸ªæ’åˆ—

**é¢˜ç›®**ï¼šå®ç°è·å–ä¸‹ä¸€ä¸ªæ’åˆ—çš„å‡½æ•°ï¼Œç®—æ³•éœ€è¦å°†ç»™å®šæ•°å­—åºåˆ—é‡æ–°æ’åˆ—æˆå­—å…¸åºä¸­ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ã€‚

**è§£é¢˜è¦ç‚¹**ï¼š
- ç†è§£å­—å…¸åºçš„æ¦‚å¿µ
- æŒæ¡ä¸‹ä¸€ä¸ªæ’åˆ—çš„ç®—æ³•æ­¥éª¤
- å¤„ç†è¾¹ç•Œæƒ…å†µï¼ˆæœ€å¤§æ’åˆ—ï¼‰

### 4. å›æº¯ç®—æ³•é€šç”¨æ¨¡æ¿

```python
def backtrack_template(é€‰æ‹©åˆ—è¡¨, è·¯å¾„, ç»“æœé›†):
    """
    å›æº¯ç®—æ³•é€šç”¨æ¨¡æ¿
    """
    if æ»¡è¶³ç»“æŸæ¡ä»¶:
        ç»“æœé›†.add(è·¯å¾„)
        return
    
    for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
        if é€‰æ‹©ä¸åˆæ³•:
            continue
        
        # åšé€‰æ‹©
        è·¯å¾„.add(é€‰æ‹©)
        
        # é€’å½’
        backtrack_template(æ–°é€‰æ‹©åˆ—è¡¨, è·¯å¾„, ç»“æœé›†)
        
        # æ’¤é”€é€‰æ‹©
        è·¯å¾„.remove(é€‰æ‹©)
```

## ğŸ“ˆ æ€§èƒ½æµ‹è¯•

```python
import time
from itertools import permutations

def performance_test():
    """
    æ€§èƒ½æµ‹è¯•ï¼šæ¯”è¾ƒä¸åŒå®ç°æ–¹æ³•
    """
    test_cases = [
        [1, 2, 3, 4],
        [1, 2, 3, 4, 5],
        [1, 2, 3, 4, 5, 6]
    ]
    
    solution_backtrack = Solution()
    solution_swap = SolutionSwap()
    
    for nums in test_cases:
        print(f"\næµ‹è¯•æ•°ç»„: {nums} (é•¿åº¦: {len(nums)})")
        
        # æ ‡å‡†å›æº¯æ³•
        start = time.time()
        result1 = solution_backtrack.permute(nums[:])
        time1 = time.time() - start
        
        # äº¤æ¢æ³•
        start = time.time()
        result2 = solution_swap.permute(nums[:])
        time2 = time.time() - start
        
        # Pythonå†…ç½®æ–¹æ³•
        start = time.time()
        result3 = list(permutations(nums))
        time3 = time.time() - start
        
        print(f"æ’åˆ—æ•°é‡: {len(result1)}")
        print(f"æ ‡å‡†å›æº¯æ³•: {time1:.6f}s")
        print(f"äº¤æ¢æ³•: {time2:.6f}s")
        print(f"å†…ç½®æ–¹æ³•: {time3:.6f}s")

if __name__ == "__main__":
    performance_test()
```

## ğŸ“ å­¦ä¹ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹
1. **ç†è§£å›æº¯**ï¼šå›æº¯ = é€’å½’ + æ’¤é”€é€‰æ‹©
2. **ä¸‰è¦ç´ **ï¼šé€‰æ‹©åˆ—è¡¨ã€è·¯å¾„ã€ç»“æŸæ¡ä»¶
3. **æ¨¡æ¿åº”ç”¨**ï¼šæŒæ¡é€šç”¨å›æº¯æ¨¡æ¿
4. **å‰ªæä¼˜åŒ–**ï¼šé¿å…æ— æ•ˆæœç´¢ï¼Œæé«˜æ•ˆç‡
5. **ç©ºé—´ä¼˜åŒ–**ï¼šæ ¹æ®éœ€æ±‚é€‰æ‹©åˆé€‚çš„å®ç°æ–¹æ³•

### è§£é¢˜æŠ€å·§
1. **ç”»é€’å½’æ ‘**ï¼šå¯è§†åŒ–ç†è§£å›æº¯è¿‡ç¨‹
2. **çŠ¶æ€ç®¡ç†**ï¼šæ­£ç¡®ç»´æŠ¤é€‰æ‹©çŠ¶æ€
3. **è¾¹ç•Œå¤„ç†**ï¼šæ³¨æ„é€’å½’ç»ˆæ­¢æ¡ä»¶
4. **ç»“æœå¤åˆ¶**ï¼šé¿å…å¼•ç”¨é—®é¢˜

### å¸¸è§é”™è¯¯
1. **å¿˜è®°å›æº¯**ï¼šæ²¡æœ‰æ’¤é”€é€‰æ‹©
2. **å¼•ç”¨é”™è¯¯**ï¼šç»“æœé›†ä¸­å­˜å‚¨å¼•ç”¨è€Œéå‰¯æœ¬
3. **é‡å¤å¤„ç†**ï¼šæ²¡æœ‰æ­£ç¡®å¤„ç†é‡å¤å…ƒç´ 
4. **è¾¹ç•Œé”™è¯¯**ï¼šé€’å½’ç»ˆæ­¢æ¡ä»¶é”™è¯¯

### æ‰©å±•å­¦ä¹ 
- ç»„åˆé—®é¢˜ï¼ˆCombinationsï¼‰
- å­é›†é—®é¢˜ï¼ˆSubsetsï¼‰
- Nçš‡åé—®é¢˜
- æ•°ç‹¬æ±‚è§£
- å›¾çš„éå†ç®—æ³•

---

**æ€»ç»“**ï¼šå…¨æ’åˆ—æ˜¯å›æº¯ç®—æ³•çš„ç»å…¸å…¥é—¨é—®é¢˜ï¼ŒæŒæ¡å…¶åŸç†å’Œå®ç°å¯¹ç†è§£å›æº¯æ€æƒ³è‡³å…³é‡è¦ã€‚é€šè¿‡å­¦ä¹ å…¨æ’åˆ—ï¼Œå¯ä»¥å»ºç«‹èµ·è§£å†³å…¶ä»–å›æº¯é—®é¢˜çš„æ€ç»´æ¡†æ¶ï¼Œä¸ºåç»­å­¦ä¹ æ›´å¤æ‚çš„ç®—æ³•æ‰“ä¸‹åšå®åŸºç¡€ã€‚