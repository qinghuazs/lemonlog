---
title: æ¯”ç‰¹å¸äº¤æ˜“æ„å»ºä¸å¹¿æ’­
date: 2025-09-30
permalink: /blockchain/bitcoin-transaction-construction.html
tags:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸
  - äº¤æ˜“
  - å¼€å‘å®æˆ˜
categories:
  - åŒºå—é“¾
---

# æ¯”ç‰¹å¸äº¤æ˜“æ„å»ºä¸å¹¿æ’­

## äº¤æ˜“ç»“æ„è¯¦è§£

### äº¤æ˜“çš„ç»„æˆéƒ¨åˆ†

```java
public class Transaction {
    // äº¤æ˜“ç‰ˆæœ¬å·
    private int version;

    // è¾“å…¥åˆ—è¡¨ï¼ˆèŠ±è´¹çš„UTXOï¼‰
    private List<TransactionInput> inputs;

    // è¾“å‡ºåˆ—è¡¨ï¼ˆæ–°åˆ›å»ºçš„UTXOï¼‰
    private List<TransactionOutput> outputs;

    // é”å®šæ—¶é—´ï¼ˆå¯é€‰ï¼‰
    private long lockTime;

    // è§è¯æ•°æ®ï¼ˆSegWitï¼‰
    private List<Witness> witnesses;
}
```

### äº¤æ˜“è¾“å…¥ï¼ˆTxInï¼‰

```java
public class TransactionInput {
    // å¼•ç”¨çš„å‰ä¸€ä¸ªäº¤æ˜“çš„å“ˆå¸Œ
    private String previousTxHash;

    // å¼•ç”¨çš„è¾“å‡ºç´¢å¼•
    private int outputIndex;

    // è§£é”è„šæœ¬ï¼ˆscriptSigï¼‰
    private Script scriptSig;

    // åºåˆ—å·
    private long sequence;

    public String toHex() {
        StringBuilder sb = new StringBuilder();

        // å‰åºäº¤æ˜“å“ˆå¸Œï¼ˆ32å­—èŠ‚ï¼Œå°ç«¯åºï¼‰
        sb.append(reverseHex(previousTxHash));

        // è¾“å‡ºç´¢å¼•ï¼ˆ4å­—èŠ‚ï¼‰
        sb.append(intToHex(outputIndex, 4));

        // è„šæœ¬é•¿åº¦
        byte[] scriptBytes = scriptSig.toBytes();
        sb.append(varInt(scriptBytes.length));

        // è„šæœ¬å†…å®¹
        sb.append(bytesToHex(scriptBytes));

        // åºåˆ—å·ï¼ˆ4å­—èŠ‚ï¼‰
        sb.append(intToHex(sequence, 4));

        return sb.toString();
    }
}
```

### äº¤æ˜“è¾“å‡ºï¼ˆTxOutï¼‰

```java
public class TransactionOutput {
    // é‡‘é¢ï¼ˆèªï¼‰
    private long value;

    // é”å®šè„šæœ¬ï¼ˆscriptPubKeyï¼‰
    private Script scriptPubKey;

    public String toHex() {
        StringBuilder sb = new StringBuilder();

        // é‡‘é¢ï¼ˆ8å­—èŠ‚ï¼Œå°ç«¯åºï¼‰
        sb.append(longToHex(value, 8));

        // è„šæœ¬é•¿åº¦
        byte[] scriptBytes = scriptPubKey.toBytes();
        sb.append(varInt(scriptBytes.length));

        // è„šæœ¬å†…å®¹
        sb.append(bytesToHex(scriptBytes));

        return sb.toString();
    }

    // åˆ›å»º P2PKH è¾“å‡º
    public static TransactionOutput createP2PKH(String address, long amount) {
        TransactionOutput output = new TransactionOutput();
        output.value = amount;

        // P2PKH è„šæœ¬ï¼šOP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        byte[] pubKeyHash = decodeAddress(address);
        Script script = new Script();
        script.addOp(OP_DUP);
        script.addOp(OP_HASH160);
        script.addData(pubKeyHash);
        script.addOp(OP_EQUALVERIFY);
        script.addOp(OP_CHECKSIG);

        output.scriptPubKey = script;
        return output;
    }
}
```

### å®Œæ•´äº¤æ˜“ç»“æ„

```mermaid
graph TD
    A[Transaction] --> B[Version<br/>4 bytes]
    A --> C[Input Count<br/>VarInt]
    A --> D[Inputs]
    A --> E[Output Count<br/>VarInt]
    A --> F[Outputs]
    A --> G[Locktime<br/>4 bytes]

    D --> D1[Input 1]
    D --> D2[Input 2]
    D --> D3[...]

    D1 --> D1A[Prev TxHash<br/>32 bytes]
    D1 --> D1B[Output Index<br/>4 bytes]
    D1 --> D1C[Script Length<br/>VarInt]
    D1 --> D1D[ScriptSig]
    D1 --> D1E[Sequence<br/>4 bytes]

    F --> F1[Output 1]
    F --> F2[Output 2]
    F --> F3[...]

    F1 --> F1A[Value<br/>8 bytes]
    F1 --> F1B[Script Length<br/>VarInt]
    F1 --> F1C[ScriptPubKey]
```

## äº¤æ˜“æ„å»ºæµç¨‹

### 1. é€‰æ‹© UTXO

```java
public class UTXOSelector {
    private List<UTXO> utxoPool;

    // é€‰æ‹©è¶³å¤Ÿçš„ UTXO
    public List<UTXO> selectUTXOs(long targetAmount, long feeRate) {
        List<UTXO> selected = new ArrayList<>();
        long totalAmount = 0;

        // æŒ‰é‡‘é¢ä»å¤§åˆ°å°æ’åº
        utxoPool.sort((a, b) -> Long.compare(b.getAmount(), a.getAmount()));

        // è´ªå¿ƒé€‰æ‹©
        for (UTXO utxo : utxoPool) {
            selected.add(utxo);
            totalAmount += utxo.getAmount();

            // ä¼°ç®—äº¤æ˜“è´¹ç”¨
            long estimatedFee = estimateFee(selected.size(), 2, feeRate);

            // æ£€æŸ¥æ˜¯å¦è¶³å¤Ÿ
            if (totalAmount >= targetAmount + estimatedFee) {
                break;
            }
        }

        if (totalAmount < targetAmount) {
            throw new InsufficientFundsException("ä½™é¢ä¸è¶³");
        }

        return selected;
    }

    // ä¼°ç®—äº¤æ˜“è´¹ç”¨
    private long estimateFee(int numInputs, int numOutputs, long feeRate) {
        // P2PKH äº¤æ˜“å¤§å°ä¼°ç®—
        int txSize = 10  // ç‰ˆæœ¬ + é”å®šæ—¶é—´
                   + numInputs * 148  // æ¯ä¸ªè¾“å…¥çº¦ 148 å­—èŠ‚
                   + numOutputs * 34;  // æ¯ä¸ªè¾“å‡ºçº¦ 34 å­—èŠ‚

        return txSize * feeRate;
    }

    // ä¼˜åŒ–ï¼šCoin Selection ç®—æ³•
    public List<UTXO> branchAndBound(long targetAmount, long feeRate) {
        // Branch and Bound ç®—æ³•ï¼ˆBitcoin Core ä½¿ç”¨ï¼‰
        // å°è¯•æ‰¾åˆ°ç²¾ç¡®åŒ¹é…ï¼Œé¿å…æ‰¾é›¶

        List<UTXO> bestSelection = null;
        long bestWaste = Long.MAX_VALUE;

        // é€’å½’æœç´¢
        findBestSelection(0, new ArrayList<>(), 0, targetAmount,
                         feeRate, bestSelection, bestWaste);

        return bestSelection;
    }
}
```

### 2. åˆ›å»ºäº¤æ˜“

```java
public class TransactionBuilder {

    public Transaction createTransaction(
            List<UTXO> inputs,
            String recipientAddress,
            long amount,
            String changeAddress,
            long feeRate) {

        Transaction tx = new Transaction();
        tx.setVersion(2);  // ä½¿ç”¨ç‰ˆæœ¬ 2

        // 1. æ·»åŠ è¾“å…¥
        long totalInput = 0;
        for (UTXO utxo : inputs) {
            TransactionInput input = new TransactionInput();
            input.setPreviousTxHash(utxo.getTxHash());
            input.setOutputIndex(utxo.getOutputIndex());
            input.setSequence(0xFFFFFFFE);  // å¯ç”¨ RBF

            tx.addInput(input);
            totalInput += utxo.getAmount();
        }

        // 2. æ·»åŠ æ”¯ä»˜è¾“å‡º
        TransactionOutput paymentOutput =
            TransactionOutput.createP2PKH(recipientAddress, amount);
        tx.addOutput(paymentOutput);

        // 3. è®¡ç®—æ‰¾é›¶
        long estimatedFee = estimateFee(inputs.size(), 2, feeRate);
        long changeAmount = totalInput - amount - estimatedFee;

        // å¦‚æœæ‰¾é›¶é‡‘é¢å¤§äºç²‰å°˜é™åˆ¶ï¼Œæ·»åŠ æ‰¾é›¶è¾“å‡º
        if (changeAmount > DUST_LIMIT) {
            TransactionOutput changeOutput =
                TransactionOutput.createP2PKH(changeAddress, changeAmount);
            tx.addOutput(changeOutput);
        } else {
            // æ‰¾é›¶å¤ªå°ï¼Œä½œä¸ºé¢å¤–çš„çŸ¿å·¥è´¹
            System.out.println("æ‰¾é›¶é‡‘é¢ " + changeAmount +
                             " ä½äºç²‰å°˜é™åˆ¶ï¼Œæ·»åŠ åˆ°çŸ¿å·¥è´¹");
        }

        // 4. è®¾ç½®é”å®šæ—¶é—´
        tx.setLockTime(0);  // ç«‹å³æœ‰æ•ˆ

        return tx;
    }

    // ç²‰å°˜é™åˆ¶ï¼ˆ546 èªï¼‰
    private static final long DUST_LIMIT = 546;
}
```

### 3. ç­¾åäº¤æ˜“

```java
public class TransactionSigner {

    // ç­¾å P2PKH äº¤æ˜“
    public void signP2PKH(Transaction tx, int inputIndex,
                          PrivateKey privateKey, UTXO utxo) {

        // 1. æ„å»ºç­¾åå“ˆå¸Œ
        byte[] sigHash = createSignatureHash(tx, inputIndex, utxo);

        // 2. ä½¿ç”¨ç§é’¥ç­¾å
        byte[] signature = ECDSA.sign(sigHash, privateKey);

        // 3. æ·»åŠ  SIGHASH ç±»å‹
        byte[] signatureWithHashType = appendHashType(signature, SIGHASH_ALL);

        // 4. è·å–å…¬é’¥
        PublicKey publicKey = privateKey.getPublicKey();
        byte[] publicKeyBytes = publicKey.toBytes();

        // 5. æ„å»º scriptSig
        Script scriptSig = new Script();
        scriptSig.addData(signatureWithHashType);
        scriptSig.addData(publicKeyBytes);

        // 6. è®¾ç½®åˆ°è¾“å…¥
        tx.getInputs().get(inputIndex).setScriptSig(scriptSig);
    }

    // åˆ›å»ºç­¾åå“ˆå¸Œ
    private byte[] createSignatureHash(Transaction tx, int inputIndex,
                                      UTXO utxo) {
        // 1. å¤åˆ¶äº¤æ˜“
        Transaction txCopy = tx.clone();

        // 2. æ¸…ç©ºæ‰€æœ‰è¾“å…¥çš„ scriptSig
        for (TransactionInput input : txCopy.getInputs()) {
            input.setScriptSig(new Script());
        }

        // 3. å°†å½“å‰è¾“å…¥çš„ scriptSig è®¾ç½®ä¸ºå‰åºè¾“å‡ºçš„ scriptPubKey
        txCopy.getInputs().get(inputIndex)
             .setScriptSig(utxo.getScriptPubKey());

        // 4. åºåˆ—åŒ–äº¤æ˜“
        byte[] txBytes = txCopy.serialize();

        // 5. æ·»åŠ  SIGHASH ç±»å‹ï¼ˆ4å­—èŠ‚ï¼‰
        byte[] txBytesWithHashType = appendBytes(txBytes,
            intToBytes(SIGHASH_ALL, 4));

        // 6. åŒé‡ SHA256
        return SHA256.doubleSha256(txBytesWithHashType);
    }

    // SIGHASH ç±»å‹
    private static final int SIGHASH_ALL = 0x01;
    private static final int SIGHASH_NONE = 0x02;
    private static final int SIGHASH_SINGLE = 0x03;
    private static final int SIGHASH_ANYONECANPAY = 0x80;
}
```

### å®Œæ•´ç¤ºä¾‹

```java
public class TransactionExample {

    public static void main(String[] args) throws Exception {
        // 1. å‡†å¤‡å‚æ•°
        String recipientAddress = "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa";
        long amount = 100_000_000;  // 1 BTC
        long feeRate = 10;  // 10 sat/byte

        // 2. åŠ è½½ç§é’¥
        String wif = "L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1";
        PrivateKey privateKey = PrivateKey.fromWIF(wif);
        String changeAddress = privateKey.getAddress();

        // 3. æŸ¥è¯¢ UTXO
        BitcoinRPC rpc = new BitcoinRPC("user", "pass");
        List<UTXO> utxos = rpc.listUnspent();

        // 4. é€‰æ‹© UTXO
        UTXOSelector selector = new UTXOSelector(utxos);
        List<UTXO> selectedUTXOs = selector.selectUTXOs(amount, feeRate);

        System.out.println("é€‰æ‹©äº† " + selectedUTXOs.size() + " ä¸ª UTXO:");
        for (UTXO utxo : selectedUTXOs) {
            System.out.println("  - " + utxo.getTxHash() + ":" +
                             utxo.getOutputIndex() + " = " +
                             utxo.getAmount() + " sats");
        }

        // 5. æ„å»ºäº¤æ˜“
        TransactionBuilder builder = new TransactionBuilder();
        Transaction tx = builder.createTransaction(
            selectedUTXOs,
            recipientAddress,
            amount,
            changeAddress,
            feeRate
        );

        System.out.println("\næœªç­¾åäº¤æ˜“:");
        System.out.println(tx.toHex());

        // 6. ç­¾åäº¤æ˜“
        TransactionSigner signer = new TransactionSigner();
        for (int i = 0; i < selectedUTXOs.size(); i++) {
            signer.signP2PKH(tx, i, privateKey, selectedUTXOs.get(i));
        }

        System.out.println("\nå·²ç­¾åäº¤æ˜“:");
        System.out.println(tx.toHex());

        // 7. éªŒè¯äº¤æ˜“
        TransactionValidator validator = new TransactionValidator();
        if (!validator.validate(tx, selectedUTXOs)) {
            throw new Exception("äº¤æ˜“éªŒè¯å¤±è´¥!");
        }

        System.out.println("\näº¤æ˜“éªŒè¯é€šè¿‡!");
        System.out.println("äº¤æ˜“ID: " + tx.getTxId());
        System.out.println("äº¤æ˜“å¤§å°: " + tx.getSize() + " bytes");
        System.out.println("äº¤æ˜“è´¹ç”¨: " + tx.getFee() + " sats");

        // 8. å¹¿æ’­äº¤æ˜“
        String txId = rpc.sendRawTransaction(tx.toHex());
        System.out.println("\näº¤æ˜“å·²å¹¿æ’­: " + txId);
    }
}
```

## äº¤æ˜“éªŒè¯

### éªŒè¯æµç¨‹

```java
public class TransactionValidator {

    public boolean validate(Transaction tx, List<UTXO> utxos) {
        // 1. åŸºæœ¬æ ¼å¼éªŒè¯
        if (!validateFormat(tx)) {
            return false;
        }

        // 2. è¾“å…¥éªŒè¯
        if (!validateInputs(tx, utxos)) {
            return false;
        }

        // 3. è¾“å‡ºéªŒè¯
        if (!validateOutputs(tx)) {
            return false;
        }

        // 4. ç­¾åéªŒè¯
        if (!validateSignatures(tx, utxos)) {
            return false;
        }

        // 5. é‡‘é¢éªŒè¯
        if (!validateAmounts(tx, utxos)) {
            return false;
        }

        return true;
    }

    // 1. æ ¼å¼éªŒè¯
    private boolean validateFormat(Transaction tx) {
        // æ£€æŸ¥ç‰ˆæœ¬
        if (tx.getVersion() < 1 || tx.getVersion() > 2) {
            System.out.println("æ— æ•ˆçš„ç‰ˆæœ¬å·: " + tx.getVersion());
            return false;
        }

        // æ£€æŸ¥è¾“å…¥è¾“å‡ºæ•°é‡
        if (tx.getInputs().isEmpty()) {
            System.out.println("äº¤æ˜“å¿…é¡»æœ‰è‡³å°‘ä¸€ä¸ªè¾“å…¥");
            return false;
        }

        if (tx.getOutputs().isEmpty()) {
            System.out.println("äº¤æ˜“å¿…é¡»æœ‰è‡³å°‘ä¸€ä¸ªè¾“å‡º");
            return false;
        }

        // æ£€æŸ¥äº¤æ˜“å¤§å°
        if (tx.getSize() > MAX_BLOCK_SIZE) {
            System.out.println("äº¤æ˜“å¤§å°è¶…è¿‡é™åˆ¶");
            return false;
        }

        return true;
    }

    // 2. è¾“å…¥éªŒè¯
    private boolean validateInputs(Transaction tx, List<UTXO> utxos) {
        for (int i = 0; i < tx.getInputs().size(); i++) {
            TransactionInput input = tx.getInputs().get(i);

            // æ£€æŸ¥æ˜¯å¦å¼•ç”¨æœ‰æ•ˆçš„ UTXO
            UTXO utxo = findUTXO(input, utxos);
            if (utxo == null) {
                System.out.println("è¾“å…¥ " + i + " å¼•ç”¨äº†ä¸å­˜åœ¨çš„ UTXO");
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å·²è¢«èŠ±è´¹
            if (utxo.isSpent()) {
                System.out.println("è¾“å…¥ " + i + " å¼•ç”¨çš„ UTXO å·²è¢«èŠ±è´¹");
                return false;
            }
        }

        return true;
    }

    // 3. è¾“å‡ºéªŒè¯
    private boolean validateOutputs(Transaction tx) {
        for (int i = 0; i < tx.getOutputs().size(); i++) {
            TransactionOutput output = tx.getOutputs().get(i);

            // æ£€æŸ¥é‡‘é¢æ˜¯å¦æœ‰æ•ˆ
            if (output.getValue() < 0) {
                System.out.println("è¾“å‡º " + i + " é‡‘é¢ä¸ºè´Ÿ");
                return false;
            }

            if (output.getValue() > MAX_MONEY) {
                System.out.println("è¾“å‡º " + i + " é‡‘é¢è¿‡å¤§");
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦ä½äºç²‰å°˜é™åˆ¶ï¼ˆå¯é€‰ï¼‰
            if (output.getValue() < DUST_LIMIT) {
                System.out.println("è­¦å‘Šï¼šè¾“å‡º " + i +
                                 " é‡‘é¢ä½äºç²‰å°˜é™åˆ¶");
            }
        }

        return true;
    }

    // 4. ç­¾åéªŒè¯
    private boolean validateSignatures(Transaction tx, List<UTXO> utxos) {
        for (int i = 0; i < tx.getInputs().size(); i++) {
            if (!validateInputSignature(tx, i, utxos.get(i))) {
                System.out.println("è¾“å…¥ " + i + " ç­¾åéªŒè¯å¤±è´¥");
                return false;
            }
        }

        return true;
    }

    private boolean validateInputSignature(Transaction tx, int inputIndex,
                                          UTXO utxo) {
        TransactionInput input = tx.getInputs().get(inputIndex);

        // æå–ç­¾åå’Œå…¬é’¥
        Script scriptSig = input.getScriptSig();
        byte[] signature = scriptSig.getData(0);
        byte[] publicKey = scriptSig.getData(1);

        // é‡å»ºç­¾åå“ˆå¸Œ
        byte[] sigHash = createSignatureHash(tx, inputIndex, utxo);

        // éªŒè¯ç­¾å
        return ECDSA.verify(sigHash, signature, publicKey);
    }

    // 5. é‡‘é¢éªŒè¯
    private boolean validateAmounts(Transaction tx, List<UTXO> utxos) {
        long totalInput = utxos.stream()
            .mapToLong(UTXO::getAmount)
            .sum();

        long totalOutput = tx.getOutputs().stream()
            .mapToLong(TransactionOutput::getValue)
            .sum();

        // è¾“å…¥å¿…é¡» >= è¾“å‡º
        if (totalInput < totalOutput) {
            System.out.println("è¾“å…¥æ€»é¢å°äºè¾“å‡ºæ€»é¢");
            return false;
        }

        // è®¡ç®—æ‰‹ç»­è´¹
        long fee = totalInput - totalOutput;
        System.out.println("äº¤æ˜“è´¹ç”¨: " + fee + " sats");

        // æ£€æŸ¥è´¹ç”¨æ˜¯å¦åˆç†
        if (fee < 0) {
            System.out.println("æ‰‹ç»­è´¹ä¸ºè´Ÿ");
            return false;
        }

        if (fee > totalInput / 2) {
            System.out.println("è­¦å‘Šï¼šæ‰‹ç»­è´¹è¿‡é«˜");
        }

        return true;
    }

    private static final long MAX_MONEY = 21_000_000L * 100_000_000L;
    private static final long DUST_LIMIT = 546;
    private static final int MAX_BLOCK_SIZE = 1_000_000;
}
```

## äº¤æ˜“å¹¿æ’­

### å¹¿æ’­æ–¹å¼

```mermaid
graph TD
    A[åˆ›å»ºå¹¶ç­¾åäº¤æ˜“] --> B{é€‰æ‹©å¹¿æ’­æ–¹å¼}

    B --> C[Bitcoin Core RPC]
    B --> D[å…¬å…±èŠ‚ç‚¹ API]
    B --> E[P2Pç½‘ç»œç›´è¿]

    C --> C1[sendrawtransaction]
    D --> D1[Blockchain.com API]
    D --> D2[BlockCypher API]
    E --> E1[è¿æ¥æ¯”ç‰¹å¸èŠ‚ç‚¹]
    E --> E2[å‘é€ tx æ¶ˆæ¯]

    C1 --> F[è¿›å…¥å†…å­˜æ± ]
    D1 --> F
    D2 --> F
    E2 --> F

    F --> G[ç­‰å¾…çŸ¿å·¥æ‰“åŒ…]
    G --> H[äº¤æ˜“ç¡®è®¤]
```

### 1. é€šè¿‡ Bitcoin Core å¹¿æ’­

```java
public class BitcoinCorebroadcaster {

    public String broadcast(Transaction tx) throws Exception {
        BitcoinRPC rpc = new BitcoinRPC("user", "pass", "localhost", 18332);

        // åºåˆ—åŒ–äº¤æ˜“ä¸ºåå…­è¿›åˆ¶
        String rawTxHex = tx.toHex();

        try {
            // æµ‹è¯•äº¤æ˜“ï¼ˆå¯é€‰ï¼‰
            Map<String, Object> testResult = rpc.testMempoolAccept(
                Arrays.asList(rawTxHex)
            );

            if (!(boolean) testResult.get("allowed")) {
                String rejectReason = (String) testResult.get("reject-reason");
                throw new Exception("äº¤æ˜“è¢«æ‹’ç»: " + rejectReason);
            }

            // å¹¿æ’­äº¤æ˜“
            String txId = rpc.sendRawTransaction(rawTxHex);
            System.out.println("äº¤æ˜“å·²å¹¿æ’­: " + txId);

            return txId;

        } catch (Exception e) {
            System.err.println("å¹¿æ’­å¤±è´¥: " + e.getMessage());
            throw e;
        }
    }

    // å¸¦æœ‰é‡è¯•æœºåˆ¶çš„å¹¿æ’­
    public String broadcastWithRetry(Transaction tx, int maxRetries)
            throws Exception {

        int retries = 0;
        Exception lastException = null;

        while (retries < maxRetries) {
            try {
                return broadcast(tx);
            } catch (Exception e) {
                lastException = e;
                retries++;

                System.out.println("å¹¿æ’­å¤±è´¥ï¼Œé‡è¯• " + retries + "/" + maxRetries);

                // ç­‰å¾…åé‡è¯•
                Thread.sleep(1000 * retries);
            }
        }

        throw new Exception("å¹¿æ’­å¤±è´¥ï¼Œå·²é‡è¯• " + maxRetries + " æ¬¡",
                          lastException);
    }
}
```

### 2. é€šè¿‡å…¬å…± API å¹¿æ’­

```java
public class PublicAPIBroadcaster {

    // Blockchain.com API
    public String broadcastViaBlockchainCom(Transaction tx) throws Exception {
        String apiUrl = "https://blockchain.info/pushtx";
        String txHex = tx.toHex();

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(apiUrl))
            .header("Content-Type", "application/x-www-form-urlencoded")
            .POST(HttpRequest.BodyPublishers.ofString("tx=" + txHex))
            .build();

        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() == 200) {
            System.out.println("äº¤æ˜“å·²å¹¿æ’­");
            return tx.getTxId();
        } else {
            throw new Exception("å¹¿æ’­å¤±è´¥: " + response.body());
        }
    }

    // BlockCypher API
    public String broadcastViaBlockCypher(Transaction tx) throws Exception {
        String apiUrl = "https://api.blockcypher.com/v1/btc/test3/txs/push";
        String txHex = tx.toHex();

        String jsonBody = String.format("{\"tx\": \"%s\"}", txHex);

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(apiUrl))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
            .build();

        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() == 201) {
            JSONObject json = new JSONObject(response.body());
            String txId = json.getString("tx").getString("hash");
            System.out.println("äº¤æ˜“å·²å¹¿æ’­: " + txId);
            return txId;
        } else {
            throw new Exception("å¹¿æ’­å¤±è´¥: " + response.body());
        }
    }
}
```

### 3. ç›‘æ§äº¤æ˜“çŠ¶æ€

```java
public class TransactionMonitor {

    public void monitorTransaction(String txId) throws Exception {
        BitcoinRPC rpc = new BitcoinRPC();

        System.out.println("å¼€å§‹ç›‘æ§äº¤æ˜“: " + txId);

        while (true) {
            try {
                // æŸ¥è¯¢äº¤æ˜“
                Map<String, Object> txInfo = rpc.getTransaction(txId);

                int confirmations = (int) txInfo.get("confirmations");
                System.out.println("ç¡®è®¤æ•°: " + confirmations);

                if (confirmations >= 6) {
                    System.out.println("äº¤æ˜“å·²å……åˆ†ç¡®è®¤!");
                    break;
                }

                // ç­‰å¾…30ç§’åå†æŸ¥è¯¢
                Thread.sleep(30_000);

            } catch (Exception e) {
                // äº¤æ˜“å¯èƒ½è¿˜åœ¨å†…å­˜æ± 
                System.out.println("äº¤æ˜“å°šæœªç¡®è®¤");
                Thread.sleep(30_000);
            }
        }
    }

    // ç›‘æ§äº¤æ˜“äº‹ä»¶
    public void monitorWithCallback(String txId,
                                   Consumer<TransactionStatus> callback) {

        new Thread(() -> {
            TransactionStatus status = new TransactionStatus();
            status.txId = txId;
            status.confirmations = 0;

            while (status.confirmations < 6) {
                try {
                    // æŸ¥è¯¢çŠ¶æ€
                    Map<String, Object> txInfo = rpc.getTransaction(txId);
                    status.confirmations = (int) txInfo.get("confirmations");
                    status.blockHash = (String) txInfo.get("blockhash");

                    // å›è°ƒ
                    callback.accept(status);

                    Thread.sleep(30_000);

                } catch (Exception e) {
                    status.error = e.getMessage();
                    callback.accept(status);
                }
            }
        }).start();
    }
}
```

## é«˜çº§åŠŸèƒ½

### 1. RBFï¼ˆReplace-By-Feeï¼‰

```java
public class RBFTransaction {

    // åˆ›å»ºå¯æ›¿æ¢äº¤æ˜“
    public Transaction createRBFTransaction(/* ... */) {
        Transaction tx = new Transaction();

        // è®¾ç½® sequence < 0xfffffffe å¯ç”¨ RBF
        for (TransactionInput input : tx.getInputs()) {
            input.setSequence(0xfffffffd);  // å¯ç”¨ RBF
        }

        return tx;
    }

    // æ›¿æ¢äº¤æ˜“ï¼ˆæé«˜æ‰‹ç»­è´¹ï¼‰
    public Transaction replaceTransaction(Transaction originalTx,
                                         long newFeeRate) {

        // 1. å¤åˆ¶åŸäº¤æ˜“
        Transaction newTx = originalTx.clone();

        // 2. è®¡ç®—æ–°çš„æ‰‹ç»­è´¹
        long oldFee = originalTx.getFee();
        long newFee = newTx.getSize() * newFeeRate;

        // RBF è§„åˆ™ï¼šæ–°æ‰‹ç»­è´¹å¿…é¡»æ›´é«˜
        if (newFee <= oldFee) {
            throw new IllegalArgumentException(
                "æ–°æ‰‹ç»­è´¹å¿…é¡»é«˜äºåŸæ‰‹ç»­è´¹"
            );
        }

        // 3. å‡å°‘æ‰¾é›¶è¾“å‡º
        TransactionOutput changeOutput = findChangeOutput(newTx);
        long additionalFee = newFee - oldFee;
        changeOutput.setValue(changeOutput.getValue() - additionalFee);

        // 4. é‡æ–°ç­¾å
        // ... ç­¾åé€»è¾‘

        return newTx;
    }
}
```

### 2. CPFPï¼ˆChild Pays For Parentï¼‰

```java
public class CPFPTransaction {

    // åˆ›å»ºå­äº¤æ˜“åŠ é€Ÿçˆ¶äº¤æ˜“
    public Transaction createCPFP(Transaction parentTx,
                                 int outputIndex,
                                 long childFeeRate) {

        // 1. ä½¿ç”¨çˆ¶äº¤æ˜“çš„è¾“å‡ºä½œä¸ºè¾“å…¥
        TransactionInput input = new TransactionInput();
        input.setPreviousTxHash(parentTx.getTxId());
        input.setOutputIndex(outputIndex);

        Transaction childTx = new Transaction();
        childTx.addInput(input);

        // 2. è®¡ç®—ç»„åˆè´¹ç‡
        long parentSize = parentTx.getSize();
        long childSize = estimateSize(childTx);
        long totalSize = parentSize + childSize;

        // ç›®æ ‡ç»„åˆè´¹ç‡
        long targetTotalFee = totalSize * childFeeRate;

        // çˆ¶äº¤æ˜“å·²æ”¯ä»˜çš„è´¹ç”¨
        long parentFee = parentTx.getFee();

        // å­äº¤æ˜“éœ€è¦æ”¯ä»˜çš„è´¹ç”¨
        long childFee = targetTotalFee - parentFee;

        // 3. åˆ›å»ºè¾“å‡ºï¼ˆæ‰£é™¤æ‰‹ç»­è´¹ï¼‰
        long inputAmount = parentTx.getOutputs().get(outputIndex).getValue();
        long outputAmount = inputAmount - childFee;

        if (outputAmount < DUST_LIMIT) {
            throw new IllegalArgumentException(
                "æ‰‹ç»­è´¹è¿‡é«˜ï¼Œè¾“å‡ºä½äºç²‰å°˜é™åˆ¶"
            );
        }

        TransactionOutput output = TransactionOutput.createP2PKH(
            changeAddress, outputAmount
        );
        childTx.addOutput(output);

        return childTx;
    }
}
```

### 3. æ‰¹é‡æ”¯ä»˜

```java
public class BatchPayment {

    // åˆ›å»ºæ‰¹é‡æ”¯ä»˜äº¤æ˜“
    public Transaction createBatchPayment(
            List<UTXO> inputs,
            Map<String, Long> recipients,  // åœ°å€ -> é‡‘é¢
            String changeAddress,
            long feeRate) {

        Transaction tx = new Transaction();

        // 1. æ·»åŠ è¾“å…¥
        long totalInput = 0;
        for (UTXO utxo : inputs) {
            TransactionInput input = new TransactionInput();
            input.setPreviousTxHash(utxo.getTxHash());
            input.setOutputIndex(utxo.getOutputIndex());
            tx.addInput(input);
            totalInput += utxo.getAmount();
        }

        // 2. æ·»åŠ æ‰€æœ‰æ”¯ä»˜è¾“å‡º
        long totalOutput = 0;
        for (Map.Entry<String, Long> entry : recipients.entrySet()) {
            String address = entry.getKey();
            long amount = entry.getValue();

            TransactionOutput output =
                TransactionOutput.createP2PKH(address, amount);
            tx.addOutput(output);
            totalOutput += amount;
        }

        // 3. è®¡ç®—å¹¶æ·»åŠ æ‰¾é›¶
        int numOutputs = recipients.size() + 1;  // +1 for change
        long fee = estimateFee(inputs.size(), numOutputs, feeRate);
        long changeAmount = totalInput - totalOutput - fee;

        if (changeAmount > DUST_LIMIT) {
            TransactionOutput changeOutput =
                TransactionOutput.createP2PKH(changeAddress, changeAmount);
            tx.addOutput(changeOutput);
        }

        System.out.println("æ‰¹é‡æ”¯ä»˜äº¤æ˜“:");
        System.out.println("- è¾“å…¥: " + inputs.size());
        System.out.println("- è¾“å‡º: " + recipients.size());
        System.out.println("- æ€»æ”¯ä»˜: " + totalOutput + " sats");
        System.out.println("- æ‰‹ç»­è´¹: " + fee + " sats");
        System.out.println("- èŠ‚çœ: " + calculateSavings(recipients.size()) + "%");

        return tx;
    }

    // è®¡ç®—æ‰¹é‡æ”¯ä»˜èŠ‚çœçš„æ‰‹ç»­è´¹
    private double calculateSavings(int numRecipients) {
        // å•ç‹¬æ”¯ä»˜çš„æ€»è´¹ç”¨
        long individualTotalFee = numRecipients * 250 * 10;  // å‡è®¾æ¯ç¬”250å­—èŠ‚

        // æ‰¹é‡æ”¯ä»˜çš„è´¹ç”¨
        long batchFee = (180 + numRecipients * 34) * 10;

        return (1 - (double) batchFee / individualTotalFee) * 100;
    }
}
```

## å®æˆ˜æ¡ˆä¾‹

### å®Œæ•´çš„è½¬è´¦ç¤ºä¾‹

```java
public class BitcoinTransferDemo {

    public static void main(String[] args) {
        try {
            // é…ç½®
            String network = "testnet";
            String rpcUrl = "http://testnet_user:testnet_pass@localhost:18332";

            // 1. è¿æ¥èŠ‚ç‚¹
            BitcoinRPC rpc = new BitcoinRPC(rpcUrl);
            System.out.println("è¿æ¥åˆ°æ¯”ç‰¹å¸" + network);

            // 2. å‡†å¤‡å¯†é’¥
            String wif = "cVt4o7BGAig1UXywgGSmARhxMdzP5qvQsxKkSsc1XEkw3tDTQFpy";
            PrivateKey privateKey = PrivateKey.fromWIF(wif, true);
            String fromAddress = privateKey.getAddress(network);
            System.out.println("å‘é€åœ°å€: " + fromAddress);

            // 3. æŸ¥è¯¢ä½™é¢
            List<UTXO> utxos = rpc.listUnspent(fromAddress);
            long balance = utxos.stream().mapToLong(UTXO::getAmount).sum();
            System.out.println("å¯ç”¨ä½™é¢: " + balance / 100_000_000.0 + " BTC");

            // 4. æ„å»ºäº¤æ˜“
            String toAddress = "tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx";
            long amount = 10_000_000;  // 0.1 BTC
            long feeRate = 10;  // 10 sat/byte

            System.out.println("\næ„å»ºäº¤æ˜“:");
            System.out.println("æ¥æ”¶åœ°å€: " + toAddress);
            System.out.println("é‡‘é¢: " + amount / 100_000_000.0 + " BTC");

            // é€‰æ‹© UTXO
            UTXOSelector selector = new UTXOSelector(utxos);
            List<UTXO> selected = selector.selectUTXOs(amount, feeRate);

            // åˆ›å»ºäº¤æ˜“
            TransactionBuilder builder = new TransactionBuilder();
            Transaction tx = builder.createTransaction(
                selected, toAddress, amount, fromAddress, feeRate
            );

            // 5. ç­¾åäº¤æ˜“
            System.out.println("\nç­¾åäº¤æ˜“...");
            TransactionSigner signer = new TransactionSigner();
            for (int i = 0; i < selected.size(); i++) {
                signer.signP2PKH(tx, i, privateKey, selected.get(i));
            }

            // 6. éªŒè¯äº¤æ˜“
            System.out.println("éªŒè¯äº¤æ˜“...");
            TransactionValidator validator = new TransactionValidator();
            if (!validator.validate(tx, selected)) {
                throw new Exception("äº¤æ˜“éªŒè¯å¤±è´¥");
            }

            System.out.println("äº¤æ˜“è¯¦æƒ…:");
            System.out.println("- TxID: " + tx.getTxId());
            System.out.println("- å¤§å°: " + tx.getSize() + " bytes");
            System.out.println("- è´¹ç”¨: " + tx.getFee() + " sats");
            System.out.println("- è´¹ç‡: " + tx.getFeeRate() + " sat/byte");

            // 7. å¹¿æ’­äº¤æ˜“
            System.out.println("\nå¹¿æ’­äº¤æ˜“...");
            String txId = rpc.sendRawTransaction(tx.toHex());
            System.out.println("âœ… äº¤æ˜“å·²å¹¿æ’­: " + txId);

            // 8. ç›‘æ§ç¡®è®¤
            System.out.println("\nç›‘æ§äº¤æ˜“ç¡®è®¤...");
            monitorTransaction(rpc, txId);

        } catch (Exception e) {
            System.err.println("é”™è¯¯: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void monitorTransaction(BitcoinRPC rpc, String txId)
            throws Exception {
        int confirmations = 0;
        while (confirmations < 6) {
            Thread.sleep(30_000);  // ç­‰å¾…30ç§’

            try {
                Map<String, Object> tx = rpc.getTransaction(txId);
                confirmations = (int) tx.get("confirmations");
                System.out.println("ç¡®è®¤æ•°: " + confirmations + "/6");
            } catch (Exception e) {
                System.out.println("ç­‰å¾…äº¤æ˜“ç¡®è®¤...");
            }
        }

        System.out.println("âœ… äº¤æ˜“å·²è·å¾—6æ¬¡ç¡®è®¤!");
    }
}
```

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

âœ… **äº¤æ˜“æ„å»º**
- é€‰æ‹©åˆé€‚çš„ UTXO
- è®¡ç®—æ­£ç¡®çš„æ‰¾é›¶
- è®¾ç½®åˆç†çš„æ‰‹ç»­è´¹
- å¤„ç†ç²‰å°˜è¾“å‡º

âœ… **äº¤æ˜“ç­¾å**
- ç”Ÿæˆç­¾åå“ˆå¸Œ
- ECDSA ç­¾å
- æ„å»º scriptSig
- æ”¯æŒå¤šç§è„šæœ¬ç±»å‹

âœ… **äº¤æ˜“éªŒè¯**
- æ ¼å¼æ£€æŸ¥
- è¾“å…¥è¾“å‡ºéªŒè¯
- ç­¾åéªŒè¯
- é‡‘é¢å¹³è¡¡æ£€æŸ¥

âœ… **äº¤æ˜“å¹¿æ’­**
- Bitcoin Core RPC
- å…¬å…± API
- çŠ¶æ€ç›‘æ§
- é”™è¯¯å¤„ç†

### æœ€ä½³å®è·µ

1. **æ‰‹ç»­è´¹ç®¡ç†**ï¼šæ ¹æ®ç½‘ç»œçŠ¶å†µåŠ¨æ€è°ƒæ•´
2. **UTXO ç®¡ç†**ï¼šåˆç†æ•´ç† UTXOï¼Œé¿å…è¿‡å¤šå°é¢è¾“å‡º
3. **æ‰¹é‡æ”¯ä»˜**ï¼šå¤šç¬”æ”¯ä»˜æ—¶ä½¿ç”¨æ‰¹é‡äº¤æ˜“èŠ‚çœè´¹ç”¨
4. **ç¡®è®¤ç­‰å¾…**ï¼šé‡è¦äº¤æ˜“ç­‰å¾…è‡³å°‘ 6 æ¬¡ç¡®è®¤

---

**ç›¸å…³æ–‡æ¡£ï¼š**
- [æ¯”ç‰¹å¸äº¤æ˜“è¯¦è§£](./03.æ¯”ç‰¹å¸äº¤æ˜“è¯¦è§£.md)
- [æ¯”ç‰¹å¸è„šæœ¬è¯­è¨€è¯¦è§£](./09.æ¯”ç‰¹å¸è„šæœ¬è¯­è¨€è¯¦è§£.md)
- [æ¯”ç‰¹å¸å¼€å‘ç¯å¢ƒæ­å»º](./15.æ¯”ç‰¹å¸å¼€å‘ç¯å¢ƒæ­å»º.md)

æŒæ¡äº¤æ˜“æ„å»ºå’Œå¹¿æ’­æ˜¯æ¯”ç‰¹å¸å¼€å‘çš„æ ¸å¿ƒæŠ€èƒ½ï¼ğŸ’¡