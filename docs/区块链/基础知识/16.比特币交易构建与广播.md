---
title: 比特币交易构建与广播
date: 2025-09-30
permalink: /blockchain/bitcoin-transaction-construction.html
tags:
  - 区块链
  - 比特币
  - 交易
  - 开发实战
categories:
  - 区块链
---

# 比特币交易构建与广播

## 交易结构详解

### 交易的组成部分

```java
public class Transaction {
    // 交易版本号
    private int version;

    // 输入列表（花费的UTXO）
    private List<TransactionInput> inputs;

    // 输出列表（新创建的UTXO）
    private List<TransactionOutput> outputs;

    // 锁定时间（可选）
    private long lockTime;

    // 见证数据（SegWit）
    private List<Witness> witnesses;
}
```

### 交易输入（TxIn）

```java
public class TransactionInput {
    // 引用的前一个交易的哈希
    private String previousTxHash;

    // 引用的输出索引
    private int outputIndex;

    // 解锁脚本（scriptSig）
    private Script scriptSig;

    // 序列号
    private long sequence;

    public String toHex() {
        StringBuilder sb = new StringBuilder();

        // 前序交易哈希（32字节，小端序）
        sb.append(reverseHex(previousTxHash));

        // 输出索引（4字节）
        sb.append(intToHex(outputIndex, 4));

        // 脚本长度
        byte[] scriptBytes = scriptSig.toBytes();
        sb.append(varInt(scriptBytes.length));

        // 脚本内容
        sb.append(bytesToHex(scriptBytes));

        // 序列号（4字节）
        sb.append(intToHex(sequence, 4));

        return sb.toString();
    }
}
```

### 交易输出（TxOut）

```java
public class TransactionOutput {
    // 金额（聪）
    private long value;

    // 锁定脚本（scriptPubKey）
    private Script scriptPubKey;

    public String toHex() {
        StringBuilder sb = new StringBuilder();

        // 金额（8字节，小端序）
        sb.append(longToHex(value, 8));

        // 脚本长度
        byte[] scriptBytes = scriptPubKey.toBytes();
        sb.append(varInt(scriptBytes.length));

        // 脚本内容
        sb.append(bytesToHex(scriptBytes));

        return sb.toString();
    }

    // 创建 P2PKH 输出
    public static TransactionOutput createP2PKH(String address, long amount) {
        TransactionOutput output = new TransactionOutput();
        output.value = amount;

        // P2PKH 脚本：OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        byte[] pubKeyHash = decodeAddress(address);
        Script script = new Script();
        script.addOp(OP_DUP);
        script.addOp(OP_HASH160);
        script.addData(pubKeyHash);
        script.addOp(OP_EQUALVERIFY);
        script.addOp(OP_CHECKSIG);

        output.scriptPubKey = script;
        return output;
    }
}
```

### 完整交易结构

```mermaid
graph TD
    A[Transaction] --> B[Version<br/>4 bytes]
    A --> C[Input Count<br/>VarInt]
    A --> D[Inputs]
    A --> E[Output Count<br/>VarInt]
    A --> F[Outputs]
    A --> G[Locktime<br/>4 bytes]

    D --> D1[Input 1]
    D --> D2[Input 2]
    D --> D3[...]

    D1 --> D1A[Prev TxHash<br/>32 bytes]
    D1 --> D1B[Output Index<br/>4 bytes]
    D1 --> D1C[Script Length<br/>VarInt]
    D1 --> D1D[ScriptSig]
    D1 --> D1E[Sequence<br/>4 bytes]

    F --> F1[Output 1]
    F --> F2[Output 2]
    F --> F3[...]

    F1 --> F1A[Value<br/>8 bytes]
    F1 --> F1B[Script Length<br/>VarInt]
    F1 --> F1C[ScriptPubKey]
```

## 交易构建流程

### 1. 选择 UTXO

```java
public class UTXOSelector {
    private List<UTXO> utxoPool;

    // 选择足够的 UTXO
    public List<UTXO> selectUTXOs(long targetAmount, long feeRate) {
        List<UTXO> selected = new ArrayList<>();
        long totalAmount = 0;

        // 按金额从大到小排序
        utxoPool.sort((a, b) -> Long.compare(b.getAmount(), a.getAmount()));

        // 贪心选择
        for (UTXO utxo : utxoPool) {
            selected.add(utxo);
            totalAmount += utxo.getAmount();

            // 估算交易费用
            long estimatedFee = estimateFee(selected.size(), 2, feeRate);

            // 检查是否足够
            if (totalAmount >= targetAmount + estimatedFee) {
                break;
            }
        }

        if (totalAmount < targetAmount) {
            throw new InsufficientFundsException("余额不足");
        }

        return selected;
    }

    // 估算交易费用
    private long estimateFee(int numInputs, int numOutputs, long feeRate) {
        // P2PKH 交易大小估算
        int txSize = 10  // 版本 + 锁定时间
                   + numInputs * 148  // 每个输入约 148 字节
                   + numOutputs * 34;  // 每个输出约 34 字节

        return txSize * feeRate;
    }

    // 优化：Coin Selection 算法
    public List<UTXO> branchAndBound(long targetAmount, long feeRate) {
        // Branch and Bound 算法（Bitcoin Core 使用）
        // 尝试找到精确匹配，避免找零

        List<UTXO> bestSelection = null;
        long bestWaste = Long.MAX_VALUE;

        // 递归搜索
        findBestSelection(0, new ArrayList<>(), 0, targetAmount,
                         feeRate, bestSelection, bestWaste);

        return bestSelection;
    }
}
```

### 2. 创建交易

```java
public class TransactionBuilder {

    public Transaction createTransaction(
            List<UTXO> inputs,
            String recipientAddress,
            long amount,
            String changeAddress,
            long feeRate) {

        Transaction tx = new Transaction();
        tx.setVersion(2);  // 使用版本 2

        // 1. 添加输入
        long totalInput = 0;
        for (UTXO utxo : inputs) {
            TransactionInput input = new TransactionInput();
            input.setPreviousTxHash(utxo.getTxHash());
            input.setOutputIndex(utxo.getOutputIndex());
            input.setSequence(0xFFFFFFFE);  // 启用 RBF

            tx.addInput(input);
            totalInput += utxo.getAmount();
        }

        // 2. 添加支付输出
        TransactionOutput paymentOutput =
            TransactionOutput.createP2PKH(recipientAddress, amount);
        tx.addOutput(paymentOutput);

        // 3. 计算找零
        long estimatedFee = estimateFee(inputs.size(), 2, feeRate);
        long changeAmount = totalInput - amount - estimatedFee;

        // 如果找零金额大于粉尘限制，添加找零输出
        if (changeAmount > DUST_LIMIT) {
            TransactionOutput changeOutput =
                TransactionOutput.createP2PKH(changeAddress, changeAmount);
            tx.addOutput(changeOutput);
        } else {
            // 找零太小，作为额外的矿工费
            System.out.println("找零金额 " + changeAmount +
                             " 低于粉尘限制，添加到矿工费");
        }

        // 4. 设置锁定时间
        tx.setLockTime(0);  // 立即有效

        return tx;
    }

    // 粉尘限制（546 聪）
    private static final long DUST_LIMIT = 546;
}
```

### 3. 签名交易

```java
public class TransactionSigner {

    // 签名 P2PKH 交易
    public void signP2PKH(Transaction tx, int inputIndex,
                          PrivateKey privateKey, UTXO utxo) {

        // 1. 构建签名哈希
        byte[] sigHash = createSignatureHash(tx, inputIndex, utxo);

        // 2. 使用私钥签名
        byte[] signature = ECDSA.sign(sigHash, privateKey);

        // 3. 添加 SIGHASH 类型
        byte[] signatureWithHashType = appendHashType(signature, SIGHASH_ALL);

        // 4. 获取公钥
        PublicKey publicKey = privateKey.getPublicKey();
        byte[] publicKeyBytes = publicKey.toBytes();

        // 5. 构建 scriptSig
        Script scriptSig = new Script();
        scriptSig.addData(signatureWithHashType);
        scriptSig.addData(publicKeyBytes);

        // 6. 设置到输入
        tx.getInputs().get(inputIndex).setScriptSig(scriptSig);
    }

    // 创建签名哈希
    private byte[] createSignatureHash(Transaction tx, int inputIndex,
                                      UTXO utxo) {
        // 1. 复制交易
        Transaction txCopy = tx.clone();

        // 2. 清空所有输入的 scriptSig
        for (TransactionInput input : txCopy.getInputs()) {
            input.setScriptSig(new Script());
        }

        // 3. 将当前输入的 scriptSig 设置为前序输出的 scriptPubKey
        txCopy.getInputs().get(inputIndex)
             .setScriptSig(utxo.getScriptPubKey());

        // 4. 序列化交易
        byte[] txBytes = txCopy.serialize();

        // 5. 添加 SIGHASH 类型（4字节）
        byte[] txBytesWithHashType = appendBytes(txBytes,
            intToBytes(SIGHASH_ALL, 4));

        // 6. 双重 SHA256
        return SHA256.doubleSha256(txBytesWithHashType);
    }

    // SIGHASH 类型
    private static final int SIGHASH_ALL = 0x01;
    private static final int SIGHASH_NONE = 0x02;
    private static final int SIGHASH_SINGLE = 0x03;
    private static final int SIGHASH_ANYONECANPAY = 0x80;
}
```

### 完整示例

```java
public class TransactionExample {

    public static void main(String[] args) throws Exception {
        // 1. 准备参数
        String recipientAddress = "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa";
        long amount = 100_000_000;  // 1 BTC
        long feeRate = 10;  // 10 sat/byte

        // 2. 加载私钥
        String wif = "L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1";
        PrivateKey privateKey = PrivateKey.fromWIF(wif);
        String changeAddress = privateKey.getAddress();

        // 3. 查询 UTXO
        BitcoinRPC rpc = new BitcoinRPC("user", "pass");
        List<UTXO> utxos = rpc.listUnspent();

        // 4. 选择 UTXO
        UTXOSelector selector = new UTXOSelector(utxos);
        List<UTXO> selectedUTXOs = selector.selectUTXOs(amount, feeRate);

        System.out.println("选择了 " + selectedUTXOs.size() + " 个 UTXO:");
        for (UTXO utxo : selectedUTXOs) {
            System.out.println("  - " + utxo.getTxHash() + ":" +
                             utxo.getOutputIndex() + " = " +
                             utxo.getAmount() + " sats");
        }

        // 5. 构建交易
        TransactionBuilder builder = new TransactionBuilder();
        Transaction tx = builder.createTransaction(
            selectedUTXOs,
            recipientAddress,
            amount,
            changeAddress,
            feeRate
        );

        System.out.println("\n未签名交易:");
        System.out.println(tx.toHex());

        // 6. 签名交易
        TransactionSigner signer = new TransactionSigner();
        for (int i = 0; i < selectedUTXOs.size(); i++) {
            signer.signP2PKH(tx, i, privateKey, selectedUTXOs.get(i));
        }

        System.out.println("\n已签名交易:");
        System.out.println(tx.toHex());

        // 7. 验证交易
        TransactionValidator validator = new TransactionValidator();
        if (!validator.validate(tx, selectedUTXOs)) {
            throw new Exception("交易验证失败!");
        }

        System.out.println("\n交易验证通过!");
        System.out.println("交易ID: " + tx.getTxId());
        System.out.println("交易大小: " + tx.getSize() + " bytes");
        System.out.println("交易费用: " + tx.getFee() + " sats");

        // 8. 广播交易
        String txId = rpc.sendRawTransaction(tx.toHex());
        System.out.println("\n交易已广播: " + txId);
    }
}
```

## 交易验证

### 验证流程

```java
public class TransactionValidator {

    public boolean validate(Transaction tx, List<UTXO> utxos) {
        // 1. 基本格式验证
        if (!validateFormat(tx)) {
            return false;
        }

        // 2. 输入验证
        if (!validateInputs(tx, utxos)) {
            return false;
        }

        // 3. 输出验证
        if (!validateOutputs(tx)) {
            return false;
        }

        // 4. 签名验证
        if (!validateSignatures(tx, utxos)) {
            return false;
        }

        // 5. 金额验证
        if (!validateAmounts(tx, utxos)) {
            return false;
        }

        return true;
    }

    // 1. 格式验证
    private boolean validateFormat(Transaction tx) {
        // 检查版本
        if (tx.getVersion() < 1 || tx.getVersion() > 2) {
            System.out.println("无效的版本号: " + tx.getVersion());
            return false;
        }

        // 检查输入输出数量
        if (tx.getInputs().isEmpty()) {
            System.out.println("交易必须有至少一个输入");
            return false;
        }

        if (tx.getOutputs().isEmpty()) {
            System.out.println("交易必须有至少一个输出");
            return false;
        }

        // 检查交易大小
        if (tx.getSize() > MAX_BLOCK_SIZE) {
            System.out.println("交易大小超过限制");
            return false;
        }

        return true;
    }

    // 2. 输入验证
    private boolean validateInputs(Transaction tx, List<UTXO> utxos) {
        for (int i = 0; i < tx.getInputs().size(); i++) {
            TransactionInput input = tx.getInputs().get(i);

            // 检查是否引用有效的 UTXO
            UTXO utxo = findUTXO(input, utxos);
            if (utxo == null) {
                System.out.println("输入 " + i + " 引用了不存在的 UTXO");
                return false;
            }

            // 检查是否已被花费
            if (utxo.isSpent()) {
                System.out.println("输入 " + i + " 引用的 UTXO 已被花费");
                return false;
            }
        }

        return true;
    }

    // 3. 输出验证
    private boolean validateOutputs(Transaction tx) {
        for (int i = 0; i < tx.getOutputs().size(); i++) {
            TransactionOutput output = tx.getOutputs().get(i);

            // 检查金额是否有效
            if (output.getValue() < 0) {
                System.out.println("输出 " + i + " 金额为负");
                return false;
            }

            if (output.getValue() > MAX_MONEY) {
                System.out.println("输出 " + i + " 金额过大");
                return false;
            }

            // 检查是否低于粉尘限制（可选）
            if (output.getValue() < DUST_LIMIT) {
                System.out.println("警告：输出 " + i +
                                 " 金额低于粉尘限制");
            }
        }

        return true;
    }

    // 4. 签名验证
    private boolean validateSignatures(Transaction tx, List<UTXO> utxos) {
        for (int i = 0; i < tx.getInputs().size(); i++) {
            if (!validateInputSignature(tx, i, utxos.get(i))) {
                System.out.println("输入 " + i + " 签名验证失败");
                return false;
            }
        }

        return true;
    }

    private boolean validateInputSignature(Transaction tx, int inputIndex,
                                          UTXO utxo) {
        TransactionInput input = tx.getInputs().get(inputIndex);

        // 提取签名和公钥
        Script scriptSig = input.getScriptSig();
        byte[] signature = scriptSig.getData(0);
        byte[] publicKey = scriptSig.getData(1);

        // 重建签名哈希
        byte[] sigHash = createSignatureHash(tx, inputIndex, utxo);

        // 验证签名
        return ECDSA.verify(sigHash, signature, publicKey);
    }

    // 5. 金额验证
    private boolean validateAmounts(Transaction tx, List<UTXO> utxos) {
        long totalInput = utxos.stream()
            .mapToLong(UTXO::getAmount)
            .sum();

        long totalOutput = tx.getOutputs().stream()
            .mapToLong(TransactionOutput::getValue)
            .sum();

        // 输入必须 >= 输出
        if (totalInput < totalOutput) {
            System.out.println("输入总额小于输出总额");
            return false;
        }

        // 计算手续费
        long fee = totalInput - totalOutput;
        System.out.println("交易费用: " + fee + " sats");

        // 检查费用是否合理
        if (fee < 0) {
            System.out.println("手续费为负");
            return false;
        }

        if (fee > totalInput / 2) {
            System.out.println("警告：手续费过高");
        }

        return true;
    }

    private static final long MAX_MONEY = 21_000_000L * 100_000_000L;
    private static final long DUST_LIMIT = 546;
    private static final int MAX_BLOCK_SIZE = 1_000_000;
}
```

## 交易广播

### 广播方式

```mermaid
graph TD
    A[创建并签名交易] --> B{选择广播方式}

    B --> C[Bitcoin Core RPC]
    B --> D[公共节点 API]
    B --> E[P2P网络直连]

    C --> C1[sendrawtransaction]
    D --> D1[Blockchain.com API]
    D --> D2[BlockCypher API]
    E --> E1[连接比特币节点]
    E --> E2[发送 tx 消息]

    C1 --> F[进入内存池]
    D1 --> F
    D2 --> F
    E2 --> F

    F --> G[等待矿工打包]
    G --> H[交易确认]
```

### 1. 通过 Bitcoin Core 广播

```java
public class BitcoinCorebroadcaster {

    public String broadcast(Transaction tx) throws Exception {
        BitcoinRPC rpc = new BitcoinRPC("user", "pass", "localhost", 18332);

        // 序列化交易为十六进制
        String rawTxHex = tx.toHex();

        try {
            // 测试交易（可选）
            Map<String, Object> testResult = rpc.testMempoolAccept(
                Arrays.asList(rawTxHex)
            );

            if (!(boolean) testResult.get("allowed")) {
                String rejectReason = (String) testResult.get("reject-reason");
                throw new Exception("交易被拒绝: " + rejectReason);
            }

            // 广播交易
            String txId = rpc.sendRawTransaction(rawTxHex);
            System.out.println("交易已广播: " + txId);

            return txId;

        } catch (Exception e) {
            System.err.println("广播失败: " + e.getMessage());
            throw e;
        }
    }

    // 带有重试机制的广播
    public String broadcastWithRetry(Transaction tx, int maxRetries)
            throws Exception {

        int retries = 0;
        Exception lastException = null;

        while (retries < maxRetries) {
            try {
                return broadcast(tx);
            } catch (Exception e) {
                lastException = e;
                retries++;

                System.out.println("广播失败，重试 " + retries + "/" + maxRetries);

                // 等待后重试
                Thread.sleep(1000 * retries);
            }
        }

        throw new Exception("广播失败，已重试 " + maxRetries + " 次",
                          lastException);
    }
}
```

### 2. 通过公共 API 广播

```java
public class PublicAPIBroadcaster {

    // Blockchain.com API
    public String broadcastViaBlockchainCom(Transaction tx) throws Exception {
        String apiUrl = "https://blockchain.info/pushtx";
        String txHex = tx.toHex();

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(apiUrl))
            .header("Content-Type", "application/x-www-form-urlencoded")
            .POST(HttpRequest.BodyPublishers.ofString("tx=" + txHex))
            .build();

        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() == 200) {
            System.out.println("交易已广播");
            return tx.getTxId();
        } else {
            throw new Exception("广播失败: " + response.body());
        }
    }

    // BlockCypher API
    public String broadcastViaBlockCypher(Transaction tx) throws Exception {
        String apiUrl = "https://api.blockcypher.com/v1/btc/test3/txs/push";
        String txHex = tx.toHex();

        String jsonBody = String.format("{\"tx\": \"%s\"}", txHex);

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(apiUrl))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
            .build();

        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() == 201) {
            JSONObject json = new JSONObject(response.body());
            String txId = json.getString("tx").getString("hash");
            System.out.println("交易已广播: " + txId);
            return txId;
        } else {
            throw new Exception("广播失败: " + response.body());
        }
    }
}
```

### 3. 监控交易状态

```java
public class TransactionMonitor {

    public void monitorTransaction(String txId) throws Exception {
        BitcoinRPC rpc = new BitcoinRPC();

        System.out.println("开始监控交易: " + txId);

        while (true) {
            try {
                // 查询交易
                Map<String, Object> txInfo = rpc.getTransaction(txId);

                int confirmations = (int) txInfo.get("confirmations");
                System.out.println("确认数: " + confirmations);

                if (confirmations >= 6) {
                    System.out.println("交易已充分确认!");
                    break;
                }

                // 等待30秒后再查询
                Thread.sleep(30_000);

            } catch (Exception e) {
                // 交易可能还在内存池
                System.out.println("交易尚未确认");
                Thread.sleep(30_000);
            }
        }
    }

    // 监控交易事件
    public void monitorWithCallback(String txId,
                                   Consumer<TransactionStatus> callback) {

        new Thread(() -> {
            TransactionStatus status = new TransactionStatus();
            status.txId = txId;
            status.confirmations = 0;

            while (status.confirmations < 6) {
                try {
                    // 查询状态
                    Map<String, Object> txInfo = rpc.getTransaction(txId);
                    status.confirmations = (int) txInfo.get("confirmations");
                    status.blockHash = (String) txInfo.get("blockhash");

                    // 回调
                    callback.accept(status);

                    Thread.sleep(30_000);

                } catch (Exception e) {
                    status.error = e.getMessage();
                    callback.accept(status);
                }
            }
        }).start();
    }
}
```

## 高级功能

### 1. RBF（Replace-By-Fee）

```java
public class RBFTransaction {

    // 创建可替换交易
    public Transaction createRBFTransaction(/* ... */) {
        Transaction tx = new Transaction();

        // 设置 sequence < 0xfffffffe 启用 RBF
        for (TransactionInput input : tx.getInputs()) {
            input.setSequence(0xfffffffd);  // 启用 RBF
        }

        return tx;
    }

    // 替换交易（提高手续费）
    public Transaction replaceTransaction(Transaction originalTx,
                                         long newFeeRate) {

        // 1. 复制原交易
        Transaction newTx = originalTx.clone();

        // 2. 计算新的手续费
        long oldFee = originalTx.getFee();
        long newFee = newTx.getSize() * newFeeRate;

        // RBF 规则：新手续费必须更高
        if (newFee <= oldFee) {
            throw new IllegalArgumentException(
                "新手续费必须高于原手续费"
            );
        }

        // 3. 减少找零输出
        TransactionOutput changeOutput = findChangeOutput(newTx);
        long additionalFee = newFee - oldFee;
        changeOutput.setValue(changeOutput.getValue() - additionalFee);

        // 4. 重新签名
        // ... 签名逻辑

        return newTx;
    }
}
```

### 2. CPFP（Child Pays For Parent）

```java
public class CPFPTransaction {

    // 创建子交易加速父交易
    public Transaction createCPFP(Transaction parentTx,
                                 int outputIndex,
                                 long childFeeRate) {

        // 1. 使用父交易的输出作为输入
        TransactionInput input = new TransactionInput();
        input.setPreviousTxHash(parentTx.getTxId());
        input.setOutputIndex(outputIndex);

        Transaction childTx = new Transaction();
        childTx.addInput(input);

        // 2. 计算组合费率
        long parentSize = parentTx.getSize();
        long childSize = estimateSize(childTx);
        long totalSize = parentSize + childSize;

        // 目标组合费率
        long targetTotalFee = totalSize * childFeeRate;

        // 父交易已支付的费用
        long parentFee = parentTx.getFee();

        // 子交易需要支付的费用
        long childFee = targetTotalFee - parentFee;

        // 3. 创建输出（扣除手续费）
        long inputAmount = parentTx.getOutputs().get(outputIndex).getValue();
        long outputAmount = inputAmount - childFee;

        if (outputAmount < DUST_LIMIT) {
            throw new IllegalArgumentException(
                "手续费过高，输出低于粉尘限制"
            );
        }

        TransactionOutput output = TransactionOutput.createP2PKH(
            changeAddress, outputAmount
        );
        childTx.addOutput(output);

        return childTx;
    }
}
```

### 3. 批量支付

```java
public class BatchPayment {

    // 创建批量支付交易
    public Transaction createBatchPayment(
            List<UTXO> inputs,
            Map<String, Long> recipients,  // 地址 -> 金额
            String changeAddress,
            long feeRate) {

        Transaction tx = new Transaction();

        // 1. 添加输入
        long totalInput = 0;
        for (UTXO utxo : inputs) {
            TransactionInput input = new TransactionInput();
            input.setPreviousTxHash(utxo.getTxHash());
            input.setOutputIndex(utxo.getOutputIndex());
            tx.addInput(input);
            totalInput += utxo.getAmount();
        }

        // 2. 添加所有支付输出
        long totalOutput = 0;
        for (Map.Entry<String, Long> entry : recipients.entrySet()) {
            String address = entry.getKey();
            long amount = entry.getValue();

            TransactionOutput output =
                TransactionOutput.createP2PKH(address, amount);
            tx.addOutput(output);
            totalOutput += amount;
        }

        // 3. 计算并添加找零
        int numOutputs = recipients.size() + 1;  // +1 for change
        long fee = estimateFee(inputs.size(), numOutputs, feeRate);
        long changeAmount = totalInput - totalOutput - fee;

        if (changeAmount > DUST_LIMIT) {
            TransactionOutput changeOutput =
                TransactionOutput.createP2PKH(changeAddress, changeAmount);
            tx.addOutput(changeOutput);
        }

        System.out.println("批量支付交易:");
        System.out.println("- 输入: " + inputs.size());
        System.out.println("- 输出: " + recipients.size());
        System.out.println("- 总支付: " + totalOutput + " sats");
        System.out.println("- 手续费: " + fee + " sats");
        System.out.println("- 节省: " + calculateSavings(recipients.size()) + "%");

        return tx;
    }

    // 计算批量支付节省的手续费
    private double calculateSavings(int numRecipients) {
        // 单独支付的总费用
        long individualTotalFee = numRecipients * 250 * 10;  // 假设每笔250字节

        // 批量支付的费用
        long batchFee = (180 + numRecipients * 34) * 10;

        return (1 - (double) batchFee / individualTotalFee) * 100;
    }
}
```

## 实战案例

### 完整的转账示例

```java
public class BitcoinTransferDemo {

    public static void main(String[] args) {
        try {
            // 配置
            String network = "testnet";
            String rpcUrl = "http://testnet_user:testnet_pass@localhost:18332";

            // 1. 连接节点
            BitcoinRPC rpc = new BitcoinRPC(rpcUrl);
            System.out.println("连接到比特币" + network);

            // 2. 准备密钥
            String wif = "cVt4o7BGAig1UXywgGSmARhxMdzP5qvQsxKkSsc1XEkw3tDTQFpy";
            PrivateKey privateKey = PrivateKey.fromWIF(wif, true);
            String fromAddress = privateKey.getAddress(network);
            System.out.println("发送地址: " + fromAddress);

            // 3. 查询余额
            List<UTXO> utxos = rpc.listUnspent(fromAddress);
            long balance = utxos.stream().mapToLong(UTXO::getAmount).sum();
            System.out.println("可用余额: " + balance / 100_000_000.0 + " BTC");

            // 4. 构建交易
            String toAddress = "tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx";
            long amount = 10_000_000;  // 0.1 BTC
            long feeRate = 10;  // 10 sat/byte

            System.out.println("\n构建交易:");
            System.out.println("接收地址: " + toAddress);
            System.out.println("金额: " + amount / 100_000_000.0 + " BTC");

            // 选择 UTXO
            UTXOSelector selector = new UTXOSelector(utxos);
            List<UTXO> selected = selector.selectUTXOs(amount, feeRate);

            // 创建交易
            TransactionBuilder builder = new TransactionBuilder();
            Transaction tx = builder.createTransaction(
                selected, toAddress, amount, fromAddress, feeRate
            );

            // 5. 签名交易
            System.out.println("\n签名交易...");
            TransactionSigner signer = new TransactionSigner();
            for (int i = 0; i < selected.size(); i++) {
                signer.signP2PKH(tx, i, privateKey, selected.get(i));
            }

            // 6. 验证交易
            System.out.println("验证交易...");
            TransactionValidator validator = new TransactionValidator();
            if (!validator.validate(tx, selected)) {
                throw new Exception("交易验证失败");
            }

            System.out.println("交易详情:");
            System.out.println("- TxID: " + tx.getTxId());
            System.out.println("- 大小: " + tx.getSize() + " bytes");
            System.out.println("- 费用: " + tx.getFee() + " sats");
            System.out.println("- 费率: " + tx.getFeeRate() + " sat/byte");

            // 7. 广播交易
            System.out.println("\n广播交易...");
            String txId = rpc.sendRawTransaction(tx.toHex());
            System.out.println("✅ 交易已广播: " + txId);

            // 8. 监控确认
            System.out.println("\n监控交易确认...");
            monitorTransaction(rpc, txId);

        } catch (Exception e) {
            System.err.println("错误: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void monitorTransaction(BitcoinRPC rpc, String txId)
            throws Exception {
        int confirmations = 0;
        while (confirmations < 6) {
            Thread.sleep(30_000);  // 等待30秒

            try {
                Map<String, Object> tx = rpc.getTransaction(txId);
                confirmations = (int) tx.get("confirmations");
                System.out.println("确认数: " + confirmations + "/6");
            } catch (Exception e) {
                System.out.println("等待交易确认...");
            }
        }

        System.out.println("✅ 交易已获得6次确认!");
    }
}
```

## 总结

### 核心要点

✅ **交易构建**
- 选择合适的 UTXO
- 计算正确的找零
- 设置合理的手续费
- 处理粉尘输出

✅ **交易签名**
- 生成签名哈希
- ECDSA 签名
- 构建 scriptSig
- 支持多种脚本类型

✅ **交易验证**
- 格式检查
- 输入输出验证
- 签名验证
- 金额平衡检查

✅ **交易广播**
- Bitcoin Core RPC
- 公共 API
- 状态监控
- 错误处理

### 最佳实践

1. **手续费管理**：根据网络状况动态调整
2. **UTXO 管理**：合理整理 UTXO，避免过多小额输出
3. **批量支付**：多笔支付时使用批量交易节省费用
4. **确认等待**：重要交易等待至少 6 次确认

---

**相关文档：**
- [比特币交易详解](./03.比特币交易详解.md)
- [比特币脚本语言详解](./09.比特币脚本语言详解.md)
- [比特币开发环境搭建](./15.比特币开发环境搭建.md)

掌握交易构建和广播是比特币开发的核心技能！💡