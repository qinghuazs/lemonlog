---
title: æ¯”ç‰¹å¸SPVè½»èŠ‚ç‚¹å®ç°
date: 2025-09-30
permalink: /blockchain/bitcoin-spv-node.html
tags:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸
  - SPV
  - è½»èŠ‚ç‚¹
categories:
  - åŒºå—é“¾
---

# æ¯”ç‰¹å¸SPVè½»èŠ‚ç‚¹å®ç°

## SPVæ¦‚è¿°

SPVï¼ˆSimplified Payment Verificationï¼Œç®€åŒ–æ”¯ä»˜éªŒè¯ï¼‰æ˜¯ä¸€ç§è½»é‡çº§çš„æ¯”ç‰¹å¸éªŒè¯æ–¹å¼ï¼Œå…è®¸å®¢æˆ·ç«¯åœ¨ä¸ä¸‹è½½å®Œæ•´åŒºå—é“¾çš„æƒ…å†µä¸‹éªŒè¯äº¤æ˜“ã€‚

### SPV vs å…¨èŠ‚ç‚¹

```mermaid
graph TD
    A[æ¯”ç‰¹å¸èŠ‚ç‚¹] --> B[å…¨èŠ‚ç‚¹]
    A --> C[SPVè½»èŠ‚ç‚¹]

    B --> B1[å­˜å‚¨å®Œæ•´åŒºå—é“¾<br/>~500GB]
    B --> B2[éªŒè¯æ‰€æœ‰äº¤æ˜“]
    B --> B3[å®Œå…¨å»ä¿¡ä»»]

    C --> C1[ä»…å­˜å‚¨åŒºå—å¤´<br/>~100MB]
    C --> C2[éªŒè¯è‡ªå·±çš„äº¤æ˜“]
    C --> C3[ä¾èµ–å…¨èŠ‚ç‚¹]
```

| ç‰¹æ€§ | å…¨èŠ‚ç‚¹ | SPVèŠ‚ç‚¹ |
|------|--------|---------|
| **å­˜å‚¨** | ~500GB | ~100MB |
| **åŒæ­¥æ—¶é—´** | æ•°å°æ—¶ | å‡ åˆ†é’Ÿ |
| **å¸¦å®½** | é«˜ | ä½ |
| **éªŒè¯** | å®Œå…¨éªŒè¯ | ç®€åŒ–éªŒè¯ |
| **éšç§** | é«˜ | è¾ƒä½ |
| **å®‰å…¨** | æœ€é«˜ | ä¾èµ–å…¨èŠ‚ç‚¹ |
| **é€‚ç”¨** | æœåŠ¡å™¨ | ç§»åŠ¨è®¾å¤‡ |

## SPVåŸç†

### 1. åŒºå—å¤´ç»“æ„

```java
public class BlockHeader {
    // åŒºå—å¤´ï¼š80å­—èŠ‚
    private int version;              // 4å­—èŠ‚
    private String previousBlockHash; // 32å­—èŠ‚
    private String merkleRoot;        // 32å­—èŠ‚
    private long timestamp;           // 4å­—èŠ‚
    private int bits;                 // 4å­—èŠ‚ï¼ˆéš¾åº¦ç›®æ ‡ï¼‰
    private int nonce;                // 4å­—èŠ‚

    // åºåˆ—åŒ–åŒºå—å¤´
    public byte[] serialize() {
        ByteBuffer buffer = ByteBuffer.allocate(80);
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        buffer.putInt(version);
        buffer.put(hexToBytes(reverseHex(previousBlockHash)));
        buffer.put(hexToBytes(reverseHex(merkleRoot)));
        buffer.putInt((int) timestamp);
        buffer.putInt(bits);
        buffer.putInt(nonce);

        return buffer.array();
    }

    // è®¡ç®—åŒºå—å“ˆå¸Œ
    public String calculateHash() {
        byte[] header = serialize();
        byte[] hash = SHA256.doubleSha256(header);
        return bytesToHex(reverse(hash));
    }

    // éªŒè¯å·¥ä½œé‡è¯æ˜
    public boolean verifyProofOfWork() {
        String hash = calculateHash();
        BigInteger hashNum = new BigInteger(hash, 16);
        BigInteger target = bitsToTarget(bits);

        return hashNum.compareTo(target) < 0;
    }

    // éš¾åº¦ç›®æ ‡è½¬æ¢
    private BigInteger bitsToTarget(int bits) {
        int exponent = (bits >>> 24) & 0xFF;
        int mantissa = bits & 0x00FFFFFF;

        return BigInteger.valueOf(mantissa)
            .multiply(BigInteger.valueOf(256).pow(exponent - 3));
    }

    public void printInfo() {
        System.out.println("=== åŒºå—å¤´ä¿¡æ¯ ===");
        System.out.println("ç‰ˆæœ¬: " + version);
        System.out.println("å‰åºå“ˆå¸Œ: " + previousBlockHash);
        System.out.println("Merkleæ ¹: " + merkleRoot);
        System.out.println("æ—¶é—´æˆ³: " + new Date(timestamp * 1000));
        System.out.println("éš¾åº¦: " + bits);
        System.out.println("Nonce: " + nonce);
        System.out.println("åŒºå—å“ˆå¸Œ: " + calculateHash());
        System.out.println("PoWæœ‰æ•ˆ: " + verifyProofOfWork());
    }
}
```

### 2. Merkleè¯æ˜

```java
public class MerkleProof {

    // Merkleæ ‘èŠ‚ç‚¹
    public static class MerkleNode {
        String hash;
        MerkleNode left;
        MerkleNode right;

        public MerkleNode(String hash) {
            this.hash = hash;
        }
    }

    // æ„å»ºMerkleæ ‘
    public MerkleNode buildMerkleTree(List<String> txHashes) {
        System.out.println("=== æ„å»ºMerkleæ ‘ ===\n");

        if (txHashes.isEmpty()) {
            return null;
        }

        // åˆ›å»ºå¶å­èŠ‚ç‚¹
        List<MerkleNode> nodes = new ArrayList<>();
        for (String txHash : txHashes) {
            nodes.add(new MerkleNode(txHash));
            System.out.println("å¶å­: " + txHash);
        }

        // é€å±‚æ„å»º
        int level = 0;
        while (nodes.size() > 1) {
            level++;
            System.out.println("\nç¬¬" + level + "å±‚:");

            List<MerkleNode> nextLevel = new ArrayList<>();

            for (int i = 0; i < nodes.size(); i += 2) {
                MerkleNode left = nodes.get(i);
                MerkleNode right = (i + 1 < nodes.size()) ?
                                   nodes.get(i + 1) : left;

                // è®¡ç®—çˆ¶èŠ‚ç‚¹å“ˆå¸Œ
                String combined = left.hash + right.hash;
                String parentHash = SHA256.doubleSha256Hex(combined);

                MerkleNode parent = new MerkleNode(parentHash);
                parent.left = left;
                parent.right = right;

                nextLevel.add(parent);
                System.out.println("  " + parentHash.substring(0, 16) + "...");
            }

            nodes = nextLevel;
        }

        MerkleNode root = nodes.get(0);
        System.out.println("\nMerkleæ ¹: " + root.hash);

        return root;
    }

    // ç”ŸæˆMerkleè¯æ˜
    public List<MerkleProofNode> generateProof(
            List<String> txHashes,
            String targetTxHash) {

        System.out.println("\n=== ç”ŸæˆMerkleè¯æ˜ ===");
        System.out.println("ç›®æ ‡äº¤æ˜“: " + targetTxHash);

        List<MerkleProofNode> proof = new ArrayList<>();

        // æ‰¾åˆ°ç›®æ ‡äº¤æ˜“çš„ç´¢å¼•
        int index = txHashes.indexOf(targetTxHash);
        if (index == -1) {
            throw new IllegalArgumentException("äº¤æ˜“ä¸å­˜åœ¨");
        }

        System.out.println("äº¤æ˜“ç´¢å¼•: " + index);
        System.out.println("\nè¯æ˜è·¯å¾„:");

        // æ„å»ºè¯æ˜è·¯å¾„
        List<String> currentLevel = new ArrayList<>(txHashes);

        while (currentLevel.size() > 1) {
            // æ‰¾åˆ°å…„å¼ŸèŠ‚ç‚¹
            int siblingIndex = (index % 2 == 0) ? index + 1 : index - 1;

            if (siblingIndex < currentLevel.size()) {
                String siblingHash = currentLevel.get(siblingIndex);
                boolean isRight = (index % 2 == 0);

                MerkleProofNode node = new MerkleProofNode(
                    siblingHash,
                    isRight ? Position.RIGHT : Position.LEFT
                );
                proof.add(node);

                System.out.println("  " + (isRight ? "å³" : "å·¦") +
                                 ": " + siblingHash.substring(0, 16) + "...");
            }

            // è®¡ç®—ä¸‹ä¸€å±‚
            List<String> nextLevel = new ArrayList<>();
            for (int i = 0; i < currentLevel.size(); i += 2) {
                String left = currentLevel.get(i);
                String right = (i + 1 < currentLevel.size()) ?
                              currentLevel.get(i + 1) : left;

                String parent = SHA256.doubleSha256Hex(left + right);
                nextLevel.add(parent);
            }

            currentLevel = nextLevel;
            index = index / 2;
        }

        System.out.println("\nè¯æ˜èŠ‚ç‚¹æ•°: " + proof.size());
        return proof;
    }

    // éªŒè¯Merkleè¯æ˜
    public boolean verifyProof(
            String txHash,
            String merkleRoot,
            List<MerkleProofNode> proof) {

        System.out.println("\n=== éªŒè¯Merkleè¯æ˜ ===");
        System.out.println("äº¤æ˜“å“ˆå¸Œ: " + txHash);
        System.out.println("Merkleæ ¹: " + merkleRoot);

        String computedHash = txHash;

        for (MerkleProofNode node : proof) {
            String combined;
            if (node.position == Position.LEFT) {
                combined = node.hash + computedHash;
                System.out.println("  å·¦: " + node.hash.substring(0, 16) + "...");
            } else {
                combined = computedHash + node.hash;
                System.out.println("  å³: " + node.hash.substring(0, 16) + "...");
            }

            computedHash = SHA256.doubleSha256Hex(combined);
            System.out.println("  => " + computedHash.substring(0, 16) + "...");
        }

        boolean valid = computedHash.equals(merkleRoot);
        System.out.println("\nè®¡ç®—çš„æ ¹: " + computedHash);
        System.out.println("éªŒè¯ç»“æœ: " + (valid ? "âœ… æœ‰æ•ˆ" : "âŒ æ— æ•ˆ"));

        return valid;
    }

    // Merkleè¯æ˜èŠ‚ç‚¹
    public static class MerkleProofNode {
        String hash;
        Position position;

        public MerkleProofNode(String hash, Position position) {
            this.hash = hash;
            this.position = position;
        }
    }

    public enum Position {
        LEFT, RIGHT
    }

    // å®Œæ•´ç¤ºä¾‹
    public void demonstrateMerkleProof() {
        System.out.println("=== Merkleè¯æ˜å®Œæ•´ç¤ºä¾‹ ===\n");

        // æ¨¡æ‹ŸåŒºå—çš„äº¤æ˜“
        List<String> transactions = List.of(
            "tx1_hash_aaaa",
            "tx2_hash_bbbb",
            "tx3_hash_cccc",
            "tx4_hash_dddd",
            "tx5_hash_eeee",
            "tx6_hash_ffff",
            "tx7_hash_gggg",
            "tx8_hash_hhhh"
        );

        // 1. æ„å»ºMerkleæ ‘
        MerkleNode root = buildMerkleTree(transactions);

        // 2. ä¸ºtx3ç”Ÿæˆè¯æ˜
        String targetTx = "tx3_hash_cccc";
        List<MerkleProofNode> proof = generateProof(transactions, targetTx);

        // 3. SPVèŠ‚ç‚¹éªŒè¯
        boolean valid = verifyProof(targetTx, root.hash, proof);

        System.out.println("\nç»“è®ºï¼š");
        System.out.println("SPVèŠ‚ç‚¹åªéœ€è¦:");
        System.out.println("- ç›®æ ‡äº¤æ˜“: " + targetTx);
        System.out.println("- Merkleè¯æ˜: " + proof.size() + " ä¸ªå“ˆå¸Œ");
        System.out.println("- åŒºå—å¤´ä¸­çš„Merkleæ ¹");
        System.out.println("\næ— éœ€ä¸‹è½½åŒºå—çš„æ‰€æœ‰äº¤æ˜“ï¼");
    }
}
```

## SPVå®¢æˆ·ç«¯å®ç°

### 1. SPVèŠ‚ç‚¹æ ¸å¿ƒ

```java
public class SPVNode {
    private List<BlockHeader> headers = new ArrayList<>();
    private BloomFilter filter;
    private List<Peer> peers = new ArrayList<>();
    private Set<String> watchedAddresses = new HashSet<>();

    // åˆå§‹åŒ–SPVèŠ‚ç‚¹
    public void initialize() {
        System.out.println("=== åˆå§‹åŒ–SPVèŠ‚ç‚¹ ===\n");

        // 1. åŠ è½½æ£€æŸ¥ç‚¹
        loadCheckpoints();

        // 2. è¿æ¥åˆ°å…¨èŠ‚ç‚¹
        connectToPeers();

        // 3. åŒæ­¥åŒºå—å¤´
        syncHeaders();

        // 4. è®¾ç½®å¸ƒéš†è¿‡æ»¤å™¨
        setupBloomFilter();

        System.out.println("SPVèŠ‚ç‚¹åˆå§‹åŒ–å®Œæˆ");
        System.out.println("åŒºå—é«˜åº¦: " + headers.size());
        System.out.println("è¿æ¥èŠ‚ç‚¹: " + peers.size());
    }

    // åŒæ­¥åŒºå—å¤´
    public void syncHeaders() {
        System.out.println("\n=== åŒæ­¥åŒºå—å¤´ ===");

        int startHeight = headers.size();
        Peer peer = peers.get(0);

        System.out.println("ä»é«˜åº¦ " + startHeight + " å¼€å§‹åŒæ­¥");

        // å‘é€ getheaders æ¶ˆæ¯
        BlockLocator locator = createBlockLocator();
        peer.sendGetHeaders(locator);

        // æ¥æ”¶ headers æ¶ˆæ¯
        while (true) {
            List<BlockHeader> newHeaders = peer.receiveHeaders();

            if (newHeaders.isEmpty()) {
                break;
            }

            for (BlockHeader header : newHeaders) {
                if (validateHeader(header)) {
                    headers.add(header);

                    if (headers.size() % 1000 == 0) {
                        System.out.println("å·²åŒæ­¥: " + headers.size() + " ä¸ªåŒºå—å¤´");
                    }
                }
            }

            // ç»§ç»­è¯·æ±‚
            if (newHeaders.size() < 2000) {
                break;  // å·²åŒæ­¥åˆ°æœ€æ–°
            }

            locator = createBlockLocator();
            peer.sendGetHeaders(locator);
        }

        System.out.println("åŒæ­¥å®Œæˆï¼Œå½“å‰é«˜åº¦: " + headers.size());
    }

    // éªŒè¯åŒºå—å¤´
    private boolean validateHeader(BlockHeader header) {
        // 1. éªŒè¯PoW
        if (!header.verifyProofOfWork()) {
            System.out.println("âŒ PoWéªŒè¯å¤±è´¥");
            return false;
        }

        // 2. éªŒè¯é“¾æ¥
        if (!headers.isEmpty()) {
            BlockHeader prev = headers.get(headers.size() - 1);
            if (!header.previousBlockHash.equals(prev.calculateHash())) {
                System.out.println("âŒ åŒºå—é“¾æ¥é”™è¯¯");
                return false;
            }
        }

        // 3. éªŒè¯æ—¶é—´æˆ³
        if (!validateTimestamp(header)) {
            System.out.println("âŒ æ—¶é—´æˆ³æ— æ•ˆ");
            return false;
        }

        // 4. éªŒè¯éš¾åº¦
        if (!validateDifficulty(header)) {
            System.out.println("âŒ éš¾åº¦ä¸æ­£ç¡®");
            return false;
        }

        return true;
    }

    // åˆ›å»ºåŒºå—å®šä½å™¨
    private BlockLocator createBlockLocator() {
        List<String> hashes = new ArrayList<>();

        int step = 1;
        int index = headers.size() - 1;

        // æŒ‡æ•°é€€é¿
        while (index >= 0) {
            hashes.add(headers.get(index).calculateHash());

            if (hashes.size() >= 10) {
                step *= 2;
            }

            index -= step;
        }

        // æ€»æ˜¯åŒ…å«åˆ›ä¸–åŒºå—
        if (!hashes.contains(GENESIS_BLOCK_HASH)) {
            hashes.add(GENESIS_BLOCK_HASH);
        }

        return new BlockLocator(hashes);
    }

    // ç›‘æ§åœ°å€
    public void watchAddress(String address) {
        System.out.println("\nç›‘æ§åœ°å€: " + address);

        watchedAddresses.add(address);

        // æ›´æ–°å¸ƒéš†è¿‡æ»¤å™¨
        filter.add(address.getBytes());

        // å‘é€ç»™æ‰€æœ‰èŠ‚ç‚¹
        for (Peer peer : peers) {
            peer.sendFilterLoad(filter);
        }
    }

    // æŸ¥è¯¢äº¤æ˜“
    public Transaction getTransaction(String txId) {
        System.out.println("\n=== æŸ¥è¯¢äº¤æ˜“ ===");
        System.out.println("TxID: " + txId);

        // è¯·æ±‚äº¤æ˜“æ•°æ®
        Peer peer = peers.get(0);
        peer.sendGetData(txId);

        // æ¥æ”¶äº¤æ˜“
        Transaction tx = peer.receiveTransaction();

        // æ¥æ”¶Merkleè¯æ˜
        MerkleBlock merkleBlock = peer.receiveMerkleBlock();

        // éªŒè¯äº¤æ˜“åœ¨åŒºå—ä¸­
        if (verifyTransactionInBlock(tx, merkleBlock)) {
            System.out.println("âœ… äº¤æ˜“éªŒè¯æˆåŠŸ");

            // æ£€æŸ¥ç¡®è®¤æ•°
            int confirmations = getConfirmations(merkleBlock.blockHash);
            System.out.println("ç¡®è®¤æ•°: " + confirmations);

            return tx;
        } else {
            System.out.println("âŒ äº¤æ˜“éªŒè¯å¤±è´¥");
            return null;
        }
    }

    // éªŒè¯äº¤æ˜“åœ¨åŒºå—ä¸­
    private boolean verifyTransactionInBlock(
            Transaction tx,
            MerkleBlock merkleBlock) {

        // 1. æ‰¾åˆ°åŒºå—å¤´
        BlockHeader header = findHeader(merkleBlock.blockHash);
        if (header == null) {
            return false;
        }

        // 2. éªŒè¯Merkleè¯æ˜
        MerkleProof merkleProof = new MerkleProof();
        return merkleProof.verifyProof(
            tx.getTxId(),
            header.merkleRoot,
            merkleBlock.merkleProof
        );
    }

    // è·å–ç¡®è®¤æ•°
    private int getConfirmations(String blockHash) {
        for (int i = 0; i < headers.size(); i++) {
            if (headers.get(i).calculateHash().equals(blockHash)) {
                return headers.size() - i;
            }
        }
        return 0;
    }
}
```

### 2. å¸ƒéš†è¿‡æ»¤å™¨

```java
public class BloomFilter {
    private byte[] data;         // ä½æ•°ç»„
    private int numHashFunctions; // å“ˆå¸Œå‡½æ•°æ•°é‡
    private int nonce;           // éšæœºnonce

    public BloomFilter(int size, double falsePositiveRate) {
        // è®¡ç®—æœ€ä¼˜å‚æ•°
        this.data = new byte[size];

        double ln2 = Math.log(2);
        this.numHashFunctions = (int) Math.ceil(
            (size * 8.0 / size) * ln2
        );

        this.nonce = new Random().nextInt();

        System.out.println("=== å¸ƒéš†è¿‡æ»¤å™¨ ===");
        System.out.println("å¤§å°: " + size + " å­—èŠ‚");
        System.out.println("å“ˆå¸Œå‡½æ•°: " + numHashFunctions);
        System.out.println("è¯¯åˆ¤ç‡: " + String.format("%.4f%%",
                          falsePositiveRate * 100));
    }

    // æ·»åŠ å…ƒç´ 
    public void add(byte[] element) {
        for (int i = 0; i < numHashFunctions; i++) {
            int hash = hash(element, i);
            int bitIndex = hash % (data.length * 8);

            // è®¾ç½®ä½
            data[bitIndex / 8] |= (1 << (bitIndex % 8));
        }
    }

    // æ£€æŸ¥å…ƒç´ 
    public boolean contains(byte[] element) {
        for (int i = 0; i < numHashFunctions; i++) {
            int hash = hash(element, i);
            int bitIndex = hash % (data.length * 8);

            // æ£€æŸ¥ä½
            if ((data[bitIndex / 8] & (1 << (bitIndex % 8))) == 0) {
                return false;  // ç»å¯¹ä¸å­˜åœ¨
            }
        }

        return true;  // å¯èƒ½å­˜åœ¨ï¼ˆæœ‰è¯¯åˆ¤ï¼‰
    }

    // MurmurHash3
    private int hash(byte[] data, int hashNum) {
        int seed = (hashNum * 0xFBA4C795) + nonce;
        return murmurHash3(data, seed);
    }

    // åºåˆ—åŒ–ï¼ˆBIP 37ï¼‰
    public byte[] serialize() {
        ByteBuffer buffer = ByteBuffer.allocate(
            data.length + 9
        );

        buffer.put(varInt(data.length));
        buffer.put(data);
        buffer.putInt(numHashFunctions);
        buffer.putInt(nonce);
        buffer.put((byte) 0);  // æ›´æ–°ç±»å‹

        return buffer.array();
    }

    // å¸ƒéš†è¿‡æ»¤å™¨ç¤ºä¾‹
    public void demonstrateBloomFilter() {
        System.out.println("\n=== å¸ƒéš†è¿‡æ»¤å™¨æ¼”ç¤º ===\n");

        // åˆ›å»ºè¿‡æ»¤å™¨
        BloomFilter filter = new BloomFilter(1000, 0.001);

        // æ·»åŠ åœ°å€
        List<String> addresses = List.of(
            "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
            "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2",
            "1JfbZRwdDHKZmuiZgYArJZhcuuzuw2HuMu"
        );

        for (String addr : addresses) {
            filter.add(addr.getBytes());
            System.out.println("æ·»åŠ : " + addr);
        }

        // æµ‹è¯•æŸ¥è¯¢
        System.out.println("\næŸ¥è¯¢æµ‹è¯•:");

        String test1 = "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa";
        System.out.println(test1 + ": " +
            (filter.contains(test1.getBytes()) ? "âœ… å­˜åœ¨" : "âŒ ä¸å­˜åœ¨"));

        String test2 = "1BitcoinEaterAddressDontSendf59kuE";
        System.out.println(test2 + ": " +
            (filter.contains(test2.getBytes()) ? "å¯èƒ½å­˜åœ¨" : "âŒ ä¸å­˜åœ¨"));

        System.out.println("\næ³¨æ„ï¼šå¸ƒéš†è¿‡æ»¤å™¨æœ‰è¯¯åˆ¤ï¼Œä½†ä¸ä¼šæ¼åˆ¤");
    }
}
```

### 3. äº¤æ˜“ç›‘æ§

```java
public class TransactionMonitor {
    private SPVNode spvNode;
    private Map<String, List<TransactionCallback>> callbacks = new HashMap<>();

    // ç›‘æ§åœ°å€
    public void watchAddress(String address, TransactionCallback callback) {
        System.out.println("=== ç›‘æ§åœ°å€ ===");
        System.out.println("åœ°å€: " + address);

        // æ·»åŠ åˆ°SPVèŠ‚ç‚¹
        spvNode.watchAddress(address);

        // æ³¨å†Œå›è°ƒ
        callbacks.computeIfAbsent(address, k -> new ArrayList<>())
                .add(callback);
    }

    // å¤„ç†æ–°äº¤æ˜“
    public void onNewTransaction(Transaction tx) {
        System.out.println("\næ”¶åˆ°æ–°äº¤æ˜“: " + tx.getTxId());

        // æ£€æŸ¥äº¤æ˜“æ˜¯å¦æ¶‰åŠç›‘æ§çš„åœ°å€
        for (TxOutput output : tx.getOutputs()) {
            String address = output.getAddress();

            if (callbacks.containsKey(address)) {
                System.out.println("è§¦å‘å›è°ƒ: " + address);

                // è°ƒç”¨æ‰€æœ‰å›è°ƒ
                for (TransactionCallback callback : callbacks.get(address)) {
                    callback.onTransaction(tx);
                }
            }
        }
    }

    // äº¤æ˜“å›è°ƒæ¥å£
    public interface TransactionCallback {
        void onTransaction(Transaction tx);
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public void demonstrateMonitoring() {
        System.out.println("=== äº¤æ˜“ç›‘æ§ç¤ºä¾‹ ===\n");

        SPVNode node = new SPVNode();
        node.initialize();

        TransactionMonitor monitor = new TransactionMonitor();
        monitor.spvNode = node;

        // ç›‘æ§æ¥æ”¶åœ°å€
        String receiveAddress = "1A1zP1eP...";

        monitor.watchAddress(receiveAddress, (tx) -> {
            System.out.println("\nğŸ’° æ”¶åˆ°æ”¯ä»˜ï¼");
            System.out.println("äº¤æ˜“ID: " + tx.getTxId());
            System.out.println("é‡‘é¢: " + tx.getAmount() / 1e8 + " BTC");

            // ç­‰å¾…ç¡®è®¤
            waitForConfirmations(tx.getTxId(), 6);

            System.out.println("âœ… æ”¯ä»˜å·²ç¡®è®¤");
        });

        System.out.println("å¼€å§‹ç›‘æ§...");
    }
}
```

## SPVçš„å®‰å…¨æ€§

### å®‰å…¨é£é™©

```java
public class SPVSecurity {

    // SPVé¢ä¸´çš„æ”»å‡»
    public void analyzeSPVRisks() {
        System.out.println("=== SPVå®‰å…¨é£é™© ===\n");

        System.out.println("1. æ— æ³•éªŒè¯è§„åˆ™");
        System.out.println("   - SPVä¸éªŒè¯äº¤æ˜“æœ‰æ•ˆæ€§");
        System.out.println("   - ä¾èµ–å…¨èŠ‚ç‚¹è¯šå®");
        System.out.println("   - å¯èƒ½æ¥å—æ— æ•ˆäº¤æ˜“");

        System.out.println("\n2. éšç§æ³„éœ²");
        System.out.println("   - å¸ƒéš†è¿‡æ»¤å™¨æš´éœ²å…´è¶£");
        System.out.println("   - å…¨èŠ‚ç‚¹å¯è¿½è¸ªç”¨æˆ·");
        System.out.println("   - IPåœ°å€æš´éœ²");

        System.out.println("\n3. æ—¥èš€æ”»å‡»");
        System.out.println("   - è¿æ¥æ¶æ„èŠ‚ç‚¹");
        System.out.println("   - æ¥æ”¶è™šå‡ä¿¡æ¯");
        System.out.println("   - åŒèŠ±æ”»å‡»");

        System.out.println("\n4. å¸ƒéš†è¿‡æ»¤å™¨æ”»å‡»");
        System.out.println("   - å‘é€å¤§é‡æ•°æ®");
        System.out.println("   - æ¶ˆè€—å¸¦å®½");
        System.out.println("   - DoSæ”»å‡»");
    }

    // å®‰å…¨æªæ–½
    public void securityMeasures() {
        System.out.println("\n=== å®‰å…¨æªæ–½ ===\n");

        System.out.println("1. è¿æ¥å¤šä¸ªèŠ‚ç‚¹");
        System.out.println("   - è‡³å°‘8ä¸ªèŠ‚ç‚¹");
        System.out.println("   - ä¸åŒåœ°ç†ä½ç½®");
        System.out.println("   - äº¤å‰éªŒè¯");

        System.out.println("\n2. ç­‰å¾…å¤šæ¬¡ç¡®è®¤");
        System.out.println("   - å°é¢ï¼š3æ¬¡");
        System.out.println("   - ä¸­é¢ï¼š6æ¬¡");
        System.out.println("   - å¤§é¢ï¼š12+æ¬¡");

        System.out.println("\n3. ä½¿ç”¨æ£€æŸ¥ç‚¹");
        System.out.println("   - ç¡¬ç¼–ç æ£€æŸ¥ç‚¹");
        System.out.println("   - é˜²æ­¢é•¿é“¾æ”»å‡»");

        System.out.println("\n4. éšç§å¢å¼º");
        System.out.println("   - è¾ƒå¤§çš„å¸ƒéš†è¿‡æ»¤å™¨");
        System.out.println("   - ä½¿ç”¨Torç½‘ç»œ");
        System.out.println("   - å®šæœŸæ›´æ¢èŠ‚ç‚¹");
    }

    // æ£€æŸ¥ç‚¹éªŒè¯
    public boolean validateAgainstCheckpoint(BlockHeader header) {
        Map<Integer, String> checkpoints = Map.of(
            11111, "0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d",
            33333, "000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6",
            74000, "0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20"
        );

        int height = getHeaderHeight(header);

        if (checkpoints.containsKey(height)) {
            String expectedHash = checkpoints.get(height);
            String actualHash = header.calculateHash();

            if (!expectedHash.equals(actualHash)) {
                System.out.println("âŒ æ£€æŸ¥ç‚¹éªŒè¯å¤±è´¥ï¼");
                System.out.println("é«˜åº¦: " + height);
                System.out.println("æœŸæœ›: " + expectedHash);
                System.out.println("å®é™…: " + actualHash);
                return false;
            }

            System.out.println("âœ… æ£€æŸ¥ç‚¹éªŒè¯é€šè¿‡: " + height);
        }

        return true;
    }
}
```

## å®ç°å®Œæ•´çš„SPVé’±åŒ…

```java
public class SPVWallet {
    private SPVNode node;
    private HDWallet wallet;
    private TransactionMonitor monitor;
    private double balance = 0;

    public void start() {
        System.out.println("=== å¯åŠ¨SPVé’±åŒ… ===\n");

        // 1. åˆå§‹åŒ–SPVèŠ‚ç‚¹
        node = new SPVNode();
        node.initialize();

        // 2. åŠ è½½é’±åŒ…
        wallet = HDWallet.load();
        System.out.println("é’±åŒ…åœ°å€: " + wallet.getAddress());

        // 3. è®¾ç½®ç›‘æ§
        monitor = new TransactionMonitor();
        monitor.watchAddress(wallet.getAddress(), this::onReceive);

        // 4. æŸ¥è¯¢ä½™é¢
        updateBalance();

        System.out.println("SPVé’±åŒ…å·²å¯åŠ¨");
        System.out.println("ä½™é¢: " + balance + " BTC");
    }

    // æ¥æ”¶å›è°ƒ
    private void onReceive(Transaction tx) {
        System.out.println("\nğŸ“¬ æ”¶åˆ°æ–°äº¤æ˜“");
        System.out.println("TxID: " + tx.getTxId());

        double amount = calculateReceivedAmount(tx);
        System.out.println("é‡‘é¢: " + amount + " BTC");

        // æ›´æ–°ä½™é¢
        balance += amount;

        // é€šçŸ¥ç”¨æˆ·
        notifyUser("æ”¶åˆ° " + amount + " BTC");
    }

    // å‘é€æ¯”ç‰¹å¸
    public String send(String toAddress, double amount) {
        System.out.println("\n=== å‘é€æ¯”ç‰¹å¸ ===");
        System.out.println("æ¥æ”¶æ–¹: " + toAddress);
        System.out.println("é‡‘é¢: " + amount + " BTC");

        // 1. æ£€æŸ¥ä½™é¢
        if (balance < amount) {
            throw new InsufficientFundsException("ä½™é¢ä¸è¶³");
        }

        // 2. æ„å»ºäº¤æ˜“
        Transaction tx = wallet.createTransaction(toAddress, amount);

        // 3. ç­¾å
        wallet.sign(tx);

        // 4. å¹¿æ’­
        node.broadcastTransaction(tx);

        System.out.println("âœ… äº¤æ˜“å·²å¹¿æ’­: " + tx.getTxId());

        return tx.getTxId();
    }

    // æ›´æ–°ä½™é¢
    private void updateBalance() {
        System.out.println("\næŸ¥è¯¢ä½™é¢...");

        // æŸ¥è¯¢UTXO
        List<UTXO> utxos = node.getUTXOs(wallet.getAddress());

        balance = utxos.stream()
            .mapToDouble(UTXO::getAmount)
            .sum() / 1e8;

        System.out.println("ä½™é¢: " + balance + " BTC");
    }
}
```

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

âœ… **SPVåŸç†**
- ä»…ä¸‹è½½åŒºå—å¤´ï¼ˆ80å­—èŠ‚ï¼‰
- ä½¿ç”¨Merkleè¯æ˜éªŒè¯äº¤æ˜“
- èŠ‚çœå­˜å‚¨å’Œå¸¦å®½

âœ… **å…³é”®æŠ€æœ¯**
- åŒºå—å¤´é“¾
- Merkleæ ‘å’Œè¯æ˜
- å¸ƒéš†è¿‡æ»¤å™¨
- P2Påè®®

âœ… **ä¼˜ç¼ºç‚¹**
- ä¼˜åŠ¿ï¼šè½»é‡ã€å¿«é€Ÿã€é€‚åˆç§»åŠ¨ç«¯
- åŠ£åŠ¿ï¼šä¾èµ–å…¨èŠ‚ç‚¹ã€éšç§è¾ƒä½

âœ… **å®‰å…¨å»ºè®®**
- è¿æ¥å¤šä¸ªèŠ‚ç‚¹
- ç­‰å¾…è¶³å¤Ÿç¡®è®¤
- ä½¿ç”¨æ£€æŸ¥ç‚¹
- å¢å¼ºéšç§

---

**ç›¸å…³æ–‡æ¡£ï¼š**
- [æ¯”ç‰¹å¸ç½‘ç»œåè®®è¯¦è§£](./06.æ¯”ç‰¹å¸ç½‘ç»œåè®®è¯¦è§£.md)
- [æ¯”ç‰¹å¸é’±åŒ…æŠ€æœ¯å®ç°](./07.æ¯”ç‰¹å¸é’±åŒ…æŠ€æœ¯å®ç°.md)
- [æ¯”ç‰¹å¸å®‰å…¨æœºåˆ¶](./14.æ¯”ç‰¹å¸å®‰å…¨æœºåˆ¶.md)

SPVæ˜¯ç§»åŠ¨é’±åŒ…çš„åŸºç¡€ï¼Œç†è§£SPVæœ‰åŠ©äºå¼€å‘è½»é‡çº§æ¯”ç‰¹å¸åº”ç”¨ï¼ğŸ“±