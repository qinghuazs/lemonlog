---
title: æ¯”ç‰¹å¸è·¨é“¾æŠ€æœ¯
date: 2025-09-30
permalink: /blockchain/bitcoin-cross-chain.html
tags:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸
  - è·¨é“¾
  - åŸå­äº¤æ¢
categories:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸åŸºç¡€
---

# æ¯”ç‰¹å¸è·¨é“¾æŠ€æœ¯

## 1. è·¨é“¾æŠ€æœ¯æ¦‚è¿°

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦è·¨é“¾

```mermaid
graph LR
    A[åŒºå—é“¾å­¤å²›] --> B[è·¨é“¾éœ€æ±‚]

    B --> C[èµ„äº§è½¬ç§»]
    B --> D[ä»·å€¼äº¤æ¢]
    B --> E[äº’æ“ä½œæ€§]
    B --> F[æµåŠ¨æ€§]

    C --> C1[BTC â†’ ETH]
    D --> D1[å»ä¿¡ä»»äº¤æ¢]
    E --> E1[è·¨é“¾DeFi]
    F --> F1[ç»Ÿä¸€æµåŠ¨æ€§æ± ]
```

### 1.2 è·¨é“¾æŠ€æœ¯åˆ†ç±»

```java
/**
 * è·¨é“¾æŠ€æœ¯åˆ†ç±»
 */
public class CrossChainTechnologies {

    /**
     * è·¨é“¾æ–¹æ¡ˆç±»å‹
     */
    public enum CrossChainType {
        ATOMIC_SWAP("åŸå­äº¤æ¢", "ç‚¹å¯¹ç‚¹,æ— éœ€ç¬¬ä¸‰æ–¹"),
        HASH_TIME_LOCK("å“ˆå¸Œæ—¶é—´é”", "HTLCæœºåˆ¶"),
        SIDECHAIN("ä¾§é“¾", "åŒå‘é”šå®š"),
        RELAY("ä¸­ç»§é“¾", "è·¨é“¾æ¶ˆæ¯ä¼ é€’"),
        WRAPPED_TOKEN("åŒ…è£…ä»£å¸", "é”å®š+é“¸é€ "),
        BRIDGE("è·¨é“¾æ¡¥", "æ‰˜ç®¡å¼æˆ–å»ä¿¡ä»»å¼");

        private String name;
        private String description;

        CrossChainType(String name, String description) {
            this.name = name;
            this.description = description;
        }

        public String getName() {
            return name;
        }

        public String getDescription() {
            return description;
        }
    }

    /**
     * è·¨é“¾æ–¹æ¡ˆå¯¹æ¯”
     */
    public static class CrossChainComparison {
        private CrossChainType type;
        private boolean trustless;      // å»ä¿¡ä»»
        private boolean custodial;      // æ‰˜ç®¡å¼
        private int securityLevel;      // å®‰å…¨ç­‰çº§(1-10)
        private int complexityLevel;    // å¤æ‚åº¦(1-10)
        private String useCase;

        public CrossChainComparison(CrossChainType type,
                boolean trustless, boolean custodial,
                int security, int complexity, String useCase) {
            this.type = type;
            this.trustless = trustless;
            this.custodial = custodial;
            this.securityLevel = security;
            this.complexityLevel = complexity;
            this.useCase = useCase;
        }

        @Override
        public String toString() {
            return String.format("%-12s | %-6s | %-6s | å®‰å…¨:%d | å¤æ‚åº¦:%d | %s",
                type.getName(),
                trustless ? "æ˜¯" : "å¦",
                custodial ? "æ˜¯" : "å¦",
                securityLevel,
                complexityLevel,
                useCase);
        }
    }

    /**
     * æ˜¾ç¤ºè·¨é“¾æ–¹æ¡ˆå¯¹æ¯”
     */
    public static void displayComparison() {
        System.out.println("=== è·¨é“¾æ–¹æ¡ˆå¯¹æ¯” ===\n");

        List<CrossChainComparison> comparisons = Arrays.asList(
            new CrossChainComparison(
                CrossChainType.ATOMIC_SWAP,
                true, false, 10, 7,
                "BTC-LTCç‚¹å¯¹ç‚¹äº¤æ¢"
            ),
            new CrossChainComparison(
                CrossChainType.WRAPPED_TOKEN,
                false, true, 6, 3,
                "WBTCåœ¨ä»¥å¤ªåŠDeFi"
            ),
            new CrossChainComparison(
                CrossChainType.SIDECHAIN,
                true, false, 8, 9,
                "Liquid, RSK"
            ),
            new CrossChainComparison(
                CrossChainType.RELAY,
                true, false, 9, 10,
                "IBC, Polkadot"
            ),
            new CrossChainComparison(
                CrossChainType.BRIDGE,
                false, true, 5, 4,
                "å¤šæ•°ä¸­å¿ƒåŒ–æ¡¥"
            )
        );

        System.out.println("ç±»å‹         | å»ä¿¡ä»» | æ‰˜ç®¡å¼ | å®‰å…¨æ€§ | å¤æ‚åº¦  | åº”ç”¨åœºæ™¯");
        System.out.println("-------------|--------|--------|--------|---------|------------------");

        for (CrossChainComparison comp : comparisons) {
            System.out.println(comp);
        }

        System.out.println();
        System.out.println("ğŸ’¡ é€‰æ‹©å»ºè®®:");
        System.out.println("â€¢ å®‰å…¨ç¬¬ä¸€: åŸå­äº¤æ¢ > ä¾§é“¾ > ä¸­ç»§");
        System.out.println("â€¢ æ˜“ç”¨æ€§: åŒ…è£…ä»£å¸ > è·¨é“¾æ¡¥ > åŸå­äº¤æ¢");
        System.out.println("â€¢ DeFié›†æˆ: åŒ…è£…ä»£å¸(WBTC)æœ€æµè¡Œ");
        System.out.println("â€¢ é•¿æœŸæ–¹æ¡ˆ: ä¾§é“¾ã€ä¸­ç»§é“¾");
    }

    public static void main(String[] args) {
        displayComparison();
    }
}
```

## 2. åŸå­äº¤æ¢ (Atomic Swap)

### 2.1 åŸå­äº¤æ¢åŸç†

**åŸå­æ€§**ï¼šäº¤æ˜“è¦ä¹ˆå…¨éƒ¨å®Œæˆï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œä¸å­˜åœ¨ä¸€æ–¹æ”¶åˆ°èµ„äº§è€Œå¦ä¸€æ–¹æœªæ”¶åˆ°çš„æƒ…å†µã€‚

```mermaid
sequenceDiagram
    participant A as Alice<br/>(BTCæŒæœ‰è€…)
    participant B as Bob<br/>(LTCæŒæœ‰è€…)

    Note over A,B: 1. åå•†äº¤æ¢æ¡ä»¶
    A->>B: æè®®: 1 BTC â‡„ 100 LTC

    Note over A,B: 2. Aliceåˆ›å»ºHTLC(BTC)
    A->>A: ç”Ÿæˆç§˜å¯†S,è®¡ç®—H(S)
    A->>B: åœ¨BTCé“¾åˆ›å»ºHTLC<br/>é”å®š1 BTC<br/>æ¡ä»¶: Bobç”¨Sè§£é” æˆ– 48håAliceé€€æ¬¾

    Note over A,B: 3. Bobåˆ›å»ºHTLC(LTC)
    B->>A: åœ¨LTCé“¾åˆ›å»ºHTLC<br/>é”å®š100 LTC<br/>æ¡ä»¶: Aliceç”¨Sè§£é” æˆ– 24håBobé€€æ¬¾

    Note over A,B: 4. Aliceè§£é”LTC(å…¬å¼€S)
    A->>A: ç”¨ç§˜å¯†Sè§£é”LTC
    Note over A: è·å¾—100 LTC,Sè¢«å…¬å¼€

    Note over A,B: 5. Bobè§£é”BTC(ä½¿ç”¨å…¬å¼€çš„S)
    B->>B: ç”¨Sè§£é”BTC
    Note over B: è·å¾—1 BTC

    Note over A,B: âœ… äº¤æ¢å®Œæˆ
```

### 2.2 åŸå­äº¤æ¢Javaå®ç°

```java
import java.security.*;
import java.util.*;

/**
 * æ¯”ç‰¹å¸åŸå­äº¤æ¢å®ç°
 */
public class AtomicSwap {

    /**
     * HTLC (Hash Time Locked Contract)
     */
    public static class HTLC {
        private byte[] secretHash;      // H(secret)
        private String recipientPubKey; // æ¥æ”¶æ–¹å…¬é’¥
        private String refundPubKey;    // é€€æ¬¾æ–¹å…¬é’¥
        private long lockTime;          // é”å®šæ—¶é—´(åŒºå—é«˜åº¦æˆ–æ—¶é—´æˆ³)
        private double amount;
        private String chain;           // BTCæˆ–LTC

        /**
         * åˆ›å»ºHTLCè„šæœ¬
         */
        public byte[] createScript() {
            /*
             * Bitcoin Script:
             * OP_IF
             *   OP_SHA256 <secretHash> OP_EQUALVERIFY
             *   <recipientPubKey> OP_CHECKSIG
             * OP_ELSE
             *   <lockTime> OP_CHECKLOCKTIMEVERIFY OP_DROP
             *   <refundPubKey> OP_CHECKSIG
             * OP_ENDIF
             */

            ByteArrayOutputStream script = new ByteArrayOutputStream();

            // OP_IF (0x63)
            script.write(0x63);

            // æˆåŠŸè·¯å¾„: ç”¨secretè§£é”
            script.write(0xA8); // OP_SHA256
            script.write(0x20); // 32å­—èŠ‚é•¿åº¦
            script.write(secretHash, 0, secretHash.length);
            script.write(0x88); // OP_EQUALVERIFY
            script.write(recipientPubKey.getBytes(), 0,
                recipientPubKey.getBytes().length);
            script.write(0xAC); // OP_CHECKSIG

            // OP_ELSE (0x67)
            script.write(0x67);

            // é€€æ¬¾è·¯å¾„: è¶…æ—¶åé€€æ¬¾
            writeLockTime(script, lockTime);
            script.write(0xB1); // OP_CHECKLOCKTIMEVERIFY
            script.write(0x75); // OP_DROP
            script.write(refundPubKey.getBytes(), 0,
                refundPubKey.getBytes().length);
            script.write(0xAC); // OP_CHECKSIG

            // OP_ENDIF (0x68)
            script.write(0x68);

            return script.toByteArray();
        }

        /**
         * ç”¨ç§˜å¯†è§£é”
         */
        public Transaction redeem(byte[] secret, String recipientPrivKey) {
            Transaction tx = new Transaction();
            tx.version = 2;

            // è¾“å…¥: æ¥è‡ªHTLC
            TxInput input = new TxInput();
            input.prevTxId = new byte[32]; // HTLCäº¤æ˜“ID
            input.prevIndex = 0;

            // Witness: <signature> <secret> <1> <script>
            List<byte[]> witness = new ArrayList<>();
            witness.add(signTransaction(tx, recipientPrivKey));
            witness.add(secret);
            witness.add(new byte[]{0x01}); // true(èµ°IFåˆ†æ”¯)
            witness.add(createScript());

            input.witness = witness;
            tx.inputs.add(input);

            // è¾“å‡º: å‘é€ç»™æ¥æ”¶æ–¹
            TxOutput output = new TxOutput();
            output.amount = (long)(amount * 100_000_000);
            output.scriptPubKey = createP2WPKHScript(recipientPubKey);
            tx.outputs.add(output);

            return tx;
        }

        /**
         * è¶…æ—¶é€€æ¬¾
         */
        public Transaction refund(String refundPrivKey) {
            Transaction tx = new Transaction();
            tx.version = 2;
            tx.lockTime = (int)lockTime;

            TxInput input = new TxInput();
            input.prevTxId = new byte[32];
            input.prevIndex = 0;
            input.sequence = 0; // å¯ç”¨locktime

            // Witness: <signature> <0> <script>
            List<byte[]> witness = new ArrayList<>();
            witness.add(signTransaction(tx, refundPrivKey));
            witness.add(new byte[]{0x00}); // false(èµ°ELSEåˆ†æ”¯)
            witness.add(createScript());

            input.witness = witness;
            tx.inputs.add(input);

            TxOutput output = new TxOutput();
            output.amount = (long)(amount * 100_000_000);
            output.scriptPubKey = createP2WPKHScript(refundPubKey);
            tx.outputs.add(output);

            return tx;
        }

        private void writeLockTime(ByteArrayOutputStream bos, long lockTime) {
            // å†™å…¥lockTime(4å­—èŠ‚,å°ç«¯åº)
            bos.write((int)(lockTime & 0xFF));
            bos.write((int)((lockTime >> 8) & 0xFF));
            bos.write((int)((lockTime >> 16) & 0xFF));
            bos.write((int)((lockTime >> 24) & 0xFF));
        }

        private byte[] signTransaction(Transaction tx, String privKey) {
            // ç®€åŒ–: å®é™…éœ€è¦ç­¾åäº¤æ˜“
            return new byte[64];
        }

        private byte[] createP2WPKHScript(String pubKey) {
            // OP_0 <20-byte-pubkey-hash>
            return new byte[22];
        }
    }

    /**
     * åŸå­äº¤æ¢åè°ƒå™¨
     */
    public static class AtomicSwapCoordinator {

        /**
         * å‘èµ·åŸå­äº¤æ¢
         */
        public SwapSession initiateSwap(
                Party alice,
                Party bob,
                double btcAmount,
                double ltcAmount) throws Exception {

            SwapSession session = new SwapSession();
            session.alice = alice;
            session.bob = bob;
            session.btcAmount = btcAmount;
            session.ltcAmount = ltcAmount;

            System.out.println("=== å‘èµ·åŸå­äº¤æ¢ ===");
            System.out.printf("Alice: %.8f BTC â†’ Bob%n", btcAmount);
            System.out.printf("Bob:   %.2f LTC â†’ Alice%n", ltcAmount);
            System.out.println();

            // 1. Aliceç”Ÿæˆç§˜å¯†
            SecureRandom random = new SecureRandom();
            byte[] secret = new byte[32];
            random.nextBytes(secret);

            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            byte[] secretHash = sha256.digest(secret);

            session.secret = secret;
            session.secretHash = secretHash;

            System.out.println("1ï¸âƒ£  Aliceç”Ÿæˆç§˜å¯†");
            System.out.println("ç§˜å¯†å“ˆå¸Œ: " + bytesToHex(secretHash).substring(0, 16) + "...");
            System.out.println();

            // 2. Aliceåˆ›å»ºBTC HTLC
            HTLC aliceHTLC = new HTLC();
            aliceHTLC.secretHash = secretHash;
            aliceHTLC.recipientPubKey = bob.btcPubKey;
            aliceHTLC.refundPubKey = alice.btcPubKey;
            aliceHTLC.lockTime = System.currentTimeMillis() / 1000 + 48 * 3600; // 48å°æ—¶
            aliceHTLC.amount = btcAmount;
            aliceHTLC.chain = "BTC";

            session.aliceHTLC = aliceHTLC;

            System.out.println("2ï¸âƒ£  Aliceåœ¨BTCé“¾åˆ›å»ºHTLC");
            System.out.println("é”å®šé‡‘é¢: " + btcAmount + " BTC");
            System.out.println("æ¥æ”¶æ–¹: Bob");
            System.out.println("è¶…æ—¶æ—¶é—´: 48å°æ—¶");
            System.out.println();

            // 3. Bobåˆ›å»ºLTC HTLC
            HTLC bobHTLC = new HTLC();
            bobHTLC.secretHash = secretHash;
            bobHTLC.recipientPubKey = alice.ltcPubKey;
            bobHTLC.refundPubKey = bob.ltcPubKey;
            bobHTLC.lockTime = System.currentTimeMillis() / 1000 + 24 * 3600; // 24å°æ—¶
            bobHTLC.amount = ltcAmount;
            bobHTLC.chain = "LTC";

            session.bobHTLC = bobHTLC;

            System.out.println("3ï¸âƒ£  Bobåœ¨LTCé“¾åˆ›å»ºHTLC");
            System.out.println("é”å®šé‡‘é¢: " + ltcAmount + " LTC");
            System.out.println("æ¥æ”¶æ–¹: Alice");
            System.out.println("è¶…æ—¶æ—¶é—´: 24å°æ—¶");
            System.out.println();

            session.status = SwapStatus.HTLC_CREATED;

            return session;
        }

        /**
         * Aliceè§£é”LTC(å…¬å¼€ç§˜å¯†)
         */
        public void aliceRedeemLTC(SwapSession session) {
            System.out.println("4ï¸âƒ£  Aliceç”¨ç§˜å¯†è§£é”LTC");

            Transaction redeemTx = session.bobHTLC.redeem(
                session.secret,
                session.alice.ltcPrivKey
            );

            System.out.println("âœ“ Aliceè·å¾— " + session.ltcAmount + " LTC");
            System.out.println("âœ“ ç§˜å¯†å·²å…¬å¼€: " +
                bytesToHex(session.secret).substring(0, 16) + "...");
            System.out.println();

            session.status = SwapStatus.ALICE_REDEEMED;
        }

        /**
         * Bobä»å…¬å¼€çš„ç§˜å¯†è§£é”BTC
         */
        public void bobRedeemBTC(SwapSession session) {
            System.out.println("5ï¸âƒ£  Bobç”¨å…¬å¼€çš„ç§˜å¯†è§£é”BTC");

            // Bobä»LTCé“¾ä¸ŠAliceçš„è§£é”äº¤æ˜“ä¸­æå–ç§˜å¯†
            byte[] extractedSecret = extractSecretFromChain("LTC");

            Transaction redeemTx = session.aliceHTLC.redeem(
                extractedSecret,
                session.bob.btcPrivKey
            );

            System.out.println("âœ“ Bobè·å¾— " + session.btcAmount + " BTC");
            System.out.println();

            session.status = SwapStatus.COMPLETED;

            System.out.println("âœ… åŸå­äº¤æ¢å®Œæˆ!");
            System.out.println("Alice: " + session.ltcAmount + " LTC");
            System.out.println("Bob:   " + session.btcAmount + " BTC");
        }

        private byte[] extractSecretFromChain(String chain) {
            // å®é™…åº”ä»é“¾ä¸Šäº¤æ˜“ä¸­æå–ç§˜å¯†
            return new byte[32];
        }

        private String bytesToHex(byte[] bytes) {
            StringBuilder sb = new StringBuilder();
            for (byte b : bytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        }
    }

    /**
     * äº¤æ¢çŠ¶æ€
     */
    public enum SwapStatus {
        INITIATED("å·²å‘èµ·"),
        HTLC_CREATED("HTLCå·²åˆ›å»º"),
        ALICE_REDEEMED("Aliceå·²è§£é”"),
        COMPLETED("å·²å®Œæˆ"),
        REFUNDED("å·²é€€æ¬¾");

        private String name;

        SwapStatus(String name) {
            this.name = name;
        }
    }

    /**
     * äº¤æ¢ä¼šè¯
     */
    public static class SwapSession {
        Party alice;
        Party bob;
        double btcAmount;
        double ltcAmount;
        byte[] secret;
        byte[] secretHash;
        HTLC aliceHTLC;
        HTLC bobHTLC;
        SwapStatus status;
    }

    public static class Party {
        String name;
        String btcPubKey;
        String btcPrivKey;
        String ltcPubKey;
        String ltcPrivKey;
    }

    // ç®€åŒ–çš„äº¤æ˜“ç»“æ„
    public static class Transaction {
        int version;
        List<TxInput> inputs = new ArrayList<>();
        List<TxOutput> outputs = new ArrayList<>();
        int lockTime;
    }

    public static class TxInput {
        byte[] prevTxId;
        int prevIndex;
        int sequence;
        List<byte[]> witness;
    }

    public static class TxOutput {
        long amount;
        byte[] scriptPubKey;
    }

    /**
     * ä½¿ç”¨ç¤ºä¾‹
     */
    public static void main(String[] args) throws Exception {
        System.out.println("=== åŸå­äº¤æ¢ç¤ºä¾‹ ===\n");

        // åˆ›å»ºå‚ä¸æ–¹
        Party alice = new Party();
        alice.name = "Alice";
        alice.btcPubKey = "alice_btc_pub";
        alice.btcPrivKey = "alice_btc_priv";
        alice.ltcPubKey = "alice_ltc_pub";
        alice.ltcPrivKey = "alice_ltc_priv";

        Party bob = new Party();
        bob.name = "Bob";
        bob.btcPubKey = "bob_btc_pub";
        bob.btcPrivKey = "bob_btc_priv";
        bob.ltcPubKey = "bob_ltc_pub";
        bob.ltcPrivKey = "bob_ltc_priv";

        AtomicSwapCoordinator coordinator = new AtomicSwapCoordinator();

        // å‘èµ·äº¤æ¢
        SwapSession session = coordinator.initiateSwap(
            alice, bob,
            1.0,    // 1 BTC
            100.0   // 100 LTC
        );

        // Aliceè§£é”LTC
        coordinator.aliceRedeemLTC(session);

        // Bobè§£é”BTC
        coordinator.bobRedeemBTC(session);

        System.out.println("\nğŸ’¡ åŸå­äº¤æ¢ä¼˜åŠ¿:");
        System.out.println("â€¢ å®Œå…¨å»ä¿¡ä»»,æ— éœ€ç¬¬ä¸‰æ–¹");
        System.out.println("â€¢ åŸå­æ€§ä¿è¯,ä¸ä¼šæœ‰ä¸€æ–¹æŸå¤±");
        System.out.println("â€¢ ç‚¹å¯¹ç‚¹äº¤æ¢,éšç§æ€§å¥½");
        System.out.println();
        System.out.println("âš ï¸  é™åˆ¶:");
        System.out.println("â€¢ éœ€è¦åŒæ–¹åŒæ—¶åœ¨çº¿");
        System.out.println("â€¢ åªæ”¯æŒåŒç±»è„šæœ¬çš„é“¾(å¦‚BTC-LTC)");
        System.out.println("â€¢ ç”¨æˆ·ä½“éªŒå¤æ‚");
    }
}
```

## 3. åŒ…è£…æ¯”ç‰¹å¸ (Wrapped BTC)

### 3.1 WBTCæ¨¡å‹

```mermaid
graph TB
    A[ç”¨æˆ·] -->|1. å‘é€BTC| B[å•†æˆ·Merchant]
    B -->|2. éªŒè¯BTC| C[æ‰˜ç®¡æ–¹Custodian]
    C -->|3. é”å®šBTC| D[BTCå†·é’±åŒ…]
    C -->|4. è¯·æ±‚é“¸é€ | E[WBTCæ™ºèƒ½åˆçº¦]
    E -->|5. é“¸é€ WBTC| F[ä»¥å¤ªåŠ]
    F -->|6. è½¬è´¦WBTC| A

    A -->|7. èµå›:å‘é€WBTC| E
    E -->|8. é”€æ¯WBTC| E
    E -->|9. é€šçŸ¥é‡Šæ”¾| C
    C -->|10. é‡Šæ”¾BTC| A
```

### 3.2 WBTCå®ç°

```java
/**
 * Wrapped BTC (WBTC) å®ç°
 */
public class WrappedBTC {

    /**
     * WBTC Custodian (æ‰˜ç®¡æ–¹)
     */
    public static class WBTCCustodian {
        private Map<String, CustodyRecord> custodyRecords = new HashMap<>();
        private double totalLockedBTC = 0;

        /**
         * é”å®šBTCå¹¶é“¸é€ WBTC
         */
        public MintRequest lockAndMint(
                String userBTCAddress,
                double btcAmount,
                String userETHAddress) throws Exception {

            System.out.println("=== WBTCé“¸é€ æµç¨‹ ===\n");

            // 1. KYCéªŒè¯
            if (!performKYC(userETHAddress)) {
                throw new Exception("KYCéªŒè¯å¤±è´¥");
            }
            System.out.println("1ï¸âƒ£  KYCéªŒè¯é€šè¿‡");

            // 2. æ¥æ”¶BTC
            String custodyAddress = generateCustodyAddress();
            System.out.println("2ï¸âƒ£  è¯·å°†BTCå‘é€åˆ°æ‰˜ç®¡åœ°å€: " + custodyAddress);

            // æ¨¡æ‹Ÿç­‰å¾…BTCç¡®è®¤
            System.out.println("3ï¸âƒ£  ç­‰å¾…BTCäº¤æ˜“ç¡®è®¤...");
            Thread.sleep(1000);

            boolean confirmed = waitForBTCConfirmation(
                userBTCAddress, custodyAddress, btcAmount);

            if (!confirmed) {
                throw new Exception("BTCäº¤æ˜“æœªç¡®è®¤");
            }

            System.out.println("âœ“ BTCäº¤æ˜“å·²ç¡®è®¤ (6ä¸ªç¡®è®¤)");
            System.out.println();

            // 3. é”å®šBTC
            CustodyRecord record = new CustodyRecord();
            record.userBTCAddress = userBTCAddress;
            record.userETHAddress = userETHAddress;
            record.btcAmount = btcAmount;
            record.custodyAddress = custodyAddress;
            record.timestamp = System.currentTimeMillis();
            record.status = CustodyStatus.LOCKED;

            custodyRecords.put(custodyAddress, record);
            totalLockedBTC += btcAmount;

            System.out.println("4ï¸âƒ£  BTCå·²é”å®š");
            System.out.println("é”å®šæ•°é‡: " + btcAmount + " BTC");
            System.out.println("æ€»é”å®šé‡: " + totalLockedBTC + " BTC");
            System.out.println();

            // 4. åˆ›å»ºé“¸é€ è¯·æ±‚
            MintRequest mintRequest = new MintRequest();
            mintRequest.custodyAddress = custodyAddress;
            mintRequest.amount = btcAmount;
            mintRequest.recipientETHAddress = userETHAddress;
            mintRequest.timestamp = System.currentTimeMillis();

            System.out.println("5ï¸âƒ£  å‘WBTCåˆçº¦å‘èµ·é“¸é€ è¯·æ±‚");
            System.out.println("é“¸é€ æ•°é‡: " + btcAmount + " WBTC");
            System.out.println("æ¥æ”¶åœ°å€: " + userETHAddress);

            return mintRequest;
        }

        /**
         * é”€æ¯WBTCå¹¶é‡Šæ”¾BTC
         */
        public BurnRequest unlockAndBurn(
                String userETHAddress,
                double wbtcAmount,
                String recipientBTCAddress) throws Exception {

            System.out.println("\n=== WBTCèµå›æµç¨‹ ===\n");

            // 1. éªŒè¯WBTCä½™é¢
            System.out.println("1ï¸âƒ£  éªŒè¯WBTCä½™é¢");

            // 2. é”€æ¯WBTC
            BurnRequest burnRequest = new BurnRequest();
            burnRequest.userETHAddress = userETHAddress;
            burnRequest.amount = wbtcAmount;
            burnRequest.recipientBTCAddress = recipientBTCAddress;
            burnRequest.timestamp = System.currentTimeMillis();

            System.out.println("2ï¸âƒ£  é”€æ¯ " + wbtcAmount + " WBTC");
            System.out.println();

            // 3. é‡Šæ”¾BTC
            System.out.println("3ï¸âƒ£  é‡Šæ”¾BTC");

            // æ‰¾åˆ°å¯¹åº”çš„æ‰˜ç®¡è®°å½•
            CustodyRecord record = findCustodyRecord(wbtcAmount);

            if (record == null) {
                throw new Exception("æœªæ‰¾åˆ°å¯¹åº”çš„æ‰˜ç®¡è®°å½•");
            }

            // ä»å†·é’±åŒ…å‘é€BTC
            sendBTCFromColdWallet(recipientBTCAddress, wbtcAmount);

            record.status = CustodyStatus.RELEASED;
            totalLockedBTC -= wbtcAmount;

            System.out.println("âœ“ BTCå·²å‘é€åˆ°: " + recipientBTCAddress);
            System.out.println("é‡Šæ”¾æ•°é‡: " + wbtcAmount + " BTC");
            System.out.println("å‰©ä½™é”å®šé‡: " + totalLockedBTC + " BTC");

            return burnRequest;
        }

        /**
         * è·å–å‚¨å¤‡è¯æ˜
         */
        public ProofOfReserve getProofOfReserve() {
            ProofOfReserve proof = new ProofOfReserve();
            proof.totalWBTCSupply = getTotalWBTCSupply();
            proof.totalBTCLocked = totalLockedBTC;
            proof.ratio = proof.totalBTCLocked / proof.totalWBTCSupply;
            proof.custodyAddresses = new ArrayList<>(custodyRecords.keySet());
            proof.timestamp = System.currentTimeMillis();

            return proof;
        }

        // è¾…åŠ©æ–¹æ³•
        private boolean performKYC(String ethAddress) {
            return true; // ç®€åŒ–
        }

        private String generateCustodyAddress() {
            return "bc1q" + UUID.randomUUID().toString().substring(0, 38);
        }

        private boolean waitForBTCConfirmation(
                String from, String to, double amount) {
            return true; // ç®€åŒ–
        }

        private CustodyRecord findCustodyRecord(double amount) {
            for (CustodyRecord record : custodyRecords.values()) {
                if (record.btcAmount >= amount &&
                    record.status == CustodyStatus.LOCKED) {
                    return record;
                }
            }
            return null;
        }

        private void sendBTCFromColdWallet(String address, double amount) {
            // å®é™…éœ€è¦ä»å¤šç­¾å†·é’±åŒ…å‘é€
        }

        private double getTotalWBTCSupply() {
            // æŸ¥è¯¢ä»¥å¤ªåŠä¸Šçš„WBTCæ€»ä¾›åº”é‡
            return totalLockedBTC;
        }
    }

    /**
     * æ‰˜ç®¡è®°å½•
     */
    public static class CustodyRecord {
        String userBTCAddress;
        String userETHAddress;
        double btcAmount;
        String custodyAddress;
        long timestamp;
        CustodyStatus status;
    }

    public enum CustodyStatus {
        LOCKED, RELEASED
    }

    public static class MintRequest {
        String custodyAddress;
        double amount;
        String recipientETHAddress;
        long timestamp;
    }

    public static class BurnRequest {
        String userETHAddress;
        double amount;
        String recipientBTCAddress;
        long timestamp;
    }

    /**
     * å‚¨å¤‡è¯æ˜
     */
    public static class ProofOfReserve {
        double totalWBTCSupply;     // æµé€šä¸­çš„WBTC
        double totalBTCLocked;      // é”å®šçš„BTC
        double ratio;               // æŠµæŠ¼ç‡
        List<String> custodyAddresses;
        long timestamp;

        @Override
        public String toString() {
            return String.format(
                "=== WBTCå‚¨å¤‡è¯æ˜ ===\n" +
                "æµé€šWBTC: %.8f\n" +
                "é”å®šBTC:  %.8f\n" +
                "æŠµæŠ¼ç‡:   %.2f%%\n" +
                "æ‰˜ç®¡åœ°å€æ•°: %d",
                totalWBTCSupply,
                totalBTCLocked,
                ratio * 100,
                custodyAddresses.size()
            );
        }
    }

    /**
     * ä½¿ç”¨ç¤ºä¾‹
     */
    public static void main(String[] args) throws Exception {
        System.out.println("=== WBTCç¤ºä¾‹ ===\n");

        WBTCCustodian custodian = new WBTCCustodian();

        // åœºæ™¯1: é“¸é€ WBTC
        MintRequest mintReq = custodian.lockAndMint(
            "bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh",
            5.0,
            "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb"
        );

        // åœºæ™¯2: æŸ¥çœ‹å‚¨å¤‡è¯æ˜
        System.out.println("\n" + custodian.getProofOfReserve());

        // åœºæ™¯3: èµå›BTC
        BurnRequest burnReq = custodian.unlockAndBurn(
            "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
            2.0,
            "bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq"
        );

        System.out.println("\nğŸ’¡ WBTCç‰¹ç‚¹:");
        System.out.println("â€¢ ä¼˜åŠ¿: ç®€å•æ˜“ç”¨,DeFié›†æˆå¹¿æ³›");
        System.out.println("â€¢ åŠ£åŠ¿: ä¸­å¿ƒåŒ–æ‰˜ç®¡,éœ€è¦ä¿¡ä»»");
        System.out.println("â€¢ å½“å‰: ä»¥å¤ªåŠä¸Šæœ€æµè¡Œçš„BTCä»£å¸");
        System.out.println();
        System.out.println("ğŸ“Š WBTCæ•°æ®(2024):");
        System.out.println("â€¢ æ€»ä¾›åº”é‡: ~150,000 WBTC");
        System.out.println("â€¢ å¸‚å€¼: ~$90äº¿ç¾å…ƒ");
        System.out.println("â€¢ TVL: åœ¨DeFiåè®®ä¸­é”å®š");
    }
}
```

## 4. æ¯”ç‰¹å¸ä¾§é“¾

### 4.1 Liquid Network

```java
/**
 * Liquid Network - æ¯”ç‰¹å¸ä¾§é“¾
 */
public class LiquidNetwork {

    /**
     * åŒå‘é”šå®š (2-Way Peg)
     */
    public static class TwoWayPeg {

        /**
         * Peg-in: BTC â†’ L-BTC
         */
        public PegInTransaction pegIn(
                String userBTCAddress,
                double btcAmount,
                String liquidAddress) {

            System.out.println("=== Peg-in: BTC â†’ L-BTC ===\n");

            PegInTransaction pegIn = new PegInTransaction();
            pegIn.userBTCAddress = userBTCAddress;
            pegIn.btcAmount = btcAmount;
            pegIn.liquidAddress = liquidAddress;

            // 1. ç”¨æˆ·å‘é€BTCåˆ°è”ç›Ÿå¤šç­¾åœ°å€
            String federationAddress = "3Liquid..." ; // 11-of-15å¤šç­¾
            System.out.println("1ï¸âƒ£  å‘é€BTCåˆ°è”ç›Ÿåœ°å€: " + federationAddress);
            System.out.println("é‡‘é¢: " + btcAmount + " BTC");
            System.out.println();

            // 2. ç­‰å¾…102ä¸ªç¡®è®¤(çº¦17å°æ—¶)
            System.out.println("2ï¸âƒ£  ç­‰å¾…102ä¸ªBTCåŒºå—ç¡®è®¤...");
            System.out.println("(é˜²æ­¢é‡ç»„æ”»å‡»)");
            System.out.println();

            // 3. åŠŸèƒ½äºº(Functionary)æ£€æµ‹åˆ°Peg-in
            System.out.println("3ï¸âƒ£  åŠŸèƒ½äººéªŒè¯Peg-inäº¤æ˜“");
            boolean verified = verifyPegIn(userBTCAddress, btcAmount);

            if (!verified) {
                pegIn.status = PegStatus.FAILED;
                return pegIn;
            }
            System.out.println("âœ“ 11-of-15åŠŸèƒ½äººç­¾åç¡®è®¤");
            System.out.println();

            // 4. åœ¨Liquidä¾§é“¾é“¸é€ L-BTC
            System.out.println("4ï¸âƒ£  åœ¨Liquidé“¾é“¸é€ L-BTC");
            mintLBTC(liquidAddress, btcAmount);

            System.out.println("âœ“ é“¸é€  " + btcAmount + " L-BTC");
            System.out.println("æ¥æ”¶åœ°å€: " + liquidAddress);
            System.out.println();

            pegIn.status = PegStatus.COMPLETED;
            pegIn.lbtcAmount = btcAmount;

            System.out.println("âœ… Peg-inå®Œæˆ!");
            System.out.println("ç”¨æ—¶: ~17å°æ—¶(102ç¡®è®¤)");

            return pegIn;
        }

        /**
         * Peg-out: L-BTC â†’ BTC
         */
        public PegOutTransaction pegOut(
                String liquidAddress,
                double lbtcAmount,
                String btcAddress) {

            System.out.println("\n=== Peg-out: L-BTC â†’ BTC ===\n");

            PegOutTransaction pegOut = new PegOutTransaction();
            pegOut.liquidAddress = liquidAddress;
            pegOut.lbtcAmount = lbtcAmount;
            pegOut.btcAddress = btcAddress;

            // 1. ç”¨æˆ·åœ¨Liquidä¸Šé”€æ¯L-BTC
            System.out.println("1ï¸âƒ£  åœ¨Liquidé“¾é”€æ¯L-BTC");
            burnLBTC(liquidAddress, lbtcAmount);
            System.out.println("é”€æ¯æ•°é‡: " + lbtcAmount + " L-BTC");
            System.out.println();

            // 2. åŠŸèƒ½äººæ£€æµ‹åˆ°Peg-outè¯·æ±‚
            System.out.println("2ï¸âƒ£  åŠŸèƒ½äººæ£€æµ‹åˆ°Peg-outè¯·æ±‚");
            System.out.println();

            // 3. åŠŸèƒ½äººä»è”ç›Ÿå¤šç­¾é‡Šæ”¾BTC
            System.out.println("3ï¸âƒ£  åŠŸèƒ½äººç­¾åé‡Šæ”¾BTC");
            boolean signed = signPegOut(lbtcAmount, btcAddress);

            if (signed) {
                System.out.println("âœ“ 11-of-15åŠŸèƒ½äººå·²ç­¾å");
                System.out.println();

                // 4. å‘é€BTCåˆ°ç”¨æˆ·åœ°å€
                System.out.println("4ï¸âƒ£  å‘é€BTCåˆ°ç”¨æˆ·åœ°å€");
                sendBTC(btcAddress, lbtcAmount);

                System.out.println("âœ“ å‘é€ " + lbtcAmount + " BTC");
                System.out.println("æ¥æ”¶åœ°å€: " + btcAddress);
                System.out.println();

                pegOut.status = PegStatus.COMPLETED;

                System.out.println("âœ… Peg-outå®Œæˆ!");
                System.out.println("ç”¨æ—¶: ~2å°æ—¶");
            } else {
                pegOut.status = PegStatus.FAILED;
            }

            return pegOut;
        }

        // è¾…åŠ©æ–¹æ³•
        private boolean verifyPegIn(String address, double amount) {
            return true;
        }

        private void mintLBTC(String address, double amount) {
            // åœ¨Liquidé“¾ä¸Šé“¸é€ L-BTC
        }

        private void burnLBTC(String address, double amount) {
            // åœ¨Liquidé“¾ä¸Šé”€æ¯L-BTC
        }

        private boolean signPegOut(double amount, String address) {
            return true;
        }

        private void sendBTC(String address, double amount) {
            // ä»è”ç›Ÿå¤šç­¾å‘é€BTC
        }
    }

    public enum PegStatus {
        PENDING, COMPLETED, FAILED
    }

    public static class PegInTransaction {
        String userBTCAddress;
        double btcAmount;
        String liquidAddress;
        double lbtcAmount;
        PegStatus status;
    }

    public static class PegOutTransaction {
        String liquidAddress;
        double lbtcAmount;
        String btcAddress;
        PegStatus status;
    }

    /**
     * Liquidç‰¹æ€§
     */
    public static class LiquidFeatures {

        /**
         * ä¿å¯†äº¤æ˜“ (Confidential Transactions)
         */
        public ConfidentialTransaction createConfidentialTx(
                String sender,
                String recipient,
                double amount) {

            ConfidentialTransaction ctx = new ConfidentialTransaction();
            ctx.sender = sender;
            ctx.recipient = recipient;

            // é‡‘é¢æ‰¿è¯º (Pedersen Commitment)
            // C = amount*G + blinding_factor*H
            ctx.amountCommitment = commitAmount(amount);

            // èŒƒå›´è¯æ˜ (Range Proof)
            // è¯æ˜é‡‘é¢åœ¨æœ‰æ•ˆèŒƒå›´å†…,ä½†ä¸æ³„éœ²å…·ä½“å€¼
            ctx.rangeProof = generateRangeProof(amount);

            System.out.println("åˆ›å»ºä¿å¯†äº¤æ˜“:");
            System.out.println("â€¢ å‘é€æ–¹: " + sender);
            System.out.println("â€¢ æ¥æ”¶æ–¹: " + recipient);
            System.out.println("â€¢ é‡‘é¢: éšè—");
            System.out.println("â€¢ é‡‘é¢æ‰¿è¯º: " + ctx.amountCommitment.substring(0, 16) + "...");
            System.out.println("â€¢ èŒƒå›´è¯æ˜å¤§å°: " + ctx.rangeProof.length + " å­—èŠ‚");

            return ctx;
        }

        /**
         * å‘è¡Œèµ„äº§ (Issued Assets)
         */
        public IssuedAsset issueAsset(
                String issuerAddress,
                String assetName,
                long supply) {

            IssuedAsset asset = new IssuedAsset();
            asset.assetId = generateAssetId();
            asset.name = assetName;
            asset.supply = supply;
            asset.issuer = issuerAddress;

            System.out.println("\nå‘è¡ŒLiquidèµ„äº§:");
            System.out.println("â€¢ èµ„äº§åç§°: " + assetName);
            System.out.println("â€¢ èµ„äº§ID: " + asset.assetId.substring(0, 16) + "...");
            System.out.println("â€¢ ä¾›åº”é‡: " + String.format("%,d", supply));
            System.out.println("â€¢ å‘è¡Œæ–¹: " + issuerAddress);
            System.out.println();
            System.out.println("ğŸ’¡ ç”¨é€”: ç¨³å®šå¸ã€è¯åˆ¸å‹ä»£å¸ã€ç§¯åˆ†ç­‰");

            return asset;
        }

        private String commitAmount(double amount) {
            return "commitment_" + UUID.randomUUID();
        }

        private byte[] generateRangeProof(double amount) {
            return new byte[2048]; // BulletproofsèŒƒå›´è¯æ˜
        }

        private String generateAssetId() {
            return UUID.randomUUID().toString();
        }
    }

    public static class ConfidentialTransaction {
        String sender;
        String recipient;
        String amountCommitment;
        byte[] rangeProof;
    }

    public static class IssuedAsset {
        String assetId;
        String name;
        long supply;
        String issuer;
    }

    /**
     * ä½¿ç”¨ç¤ºä¾‹
     */
    public static void main(String[] args) {
        System.out.println("=== Liquid Networkç¤ºä¾‹ ===\n");

        TwoWayPeg peg = new TwoWayPeg();

        // Peg-in
        PegInTransaction pegIn = peg.pegIn(
            "bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh",
            10.0,
            "VJL..." // Liquidåœ°å€
        );

        // ä¿å¯†äº¤æ˜“
        LiquidFeatures features = new LiquidFeatures();
        ConfidentialTransaction ctx = features.createConfidentialTx(
            "VJL...",
            "VTp...",
            5.0
        );

        // å‘è¡Œèµ„äº§
        IssuedAsset asset = features.issueAsset(
            "VJL...",
            "Tether USD (USDt)",
            1000000000 // 10äº¿
        );

        // Peg-out
        PegOutTransaction pegOut = peg.pegOut(
            "VJL...",
            5.0,
            "bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq"
        );

        System.out.println("\nğŸ’¡ Liquidä¼˜åŠ¿:");
        System.out.println("â€¢ å¿«é€Ÿç»“ç®—: 1åˆ†é’ŸåŒºå—æ—¶é—´");
        System.out.println("â€¢ ä¿å¯†äº¤æ˜“: é‡‘é¢å’Œèµ„äº§ç±»å‹éšè—");
        System.out.println("â€¢ èµ„äº§å‘è¡Œ: æ”¯æŒå¤šç§èµ„äº§");
        System.out.println("â€¢ æœ€ç»ˆæ€§: 2ä¸ªç¡®è®¤å³æœ€ç»ˆ");
        System.out.println();
        System.out.println("ğŸ“Š Liquidæ•°æ®:");
        System.out.println("â€¢ é”å®šBTC: ~3,500 BTC");
        System.out.println("â€¢ åŠŸèƒ½äºº: 15ä¸ªæœºæ„(Blockstreamç­‰)");
        System.out.println("â€¢ ç”¨ä¾‹: äº¤æ˜“æ‰€ç»“ç®—ã€ç¨³å®šå¸ã€è¯åˆ¸");
    }
}
```

## 5. ç›¸å…³æ–‡æ¡£

- [31.æ¯”ç‰¹å¸ä¸DeFi.md](./31.æ¯”ç‰¹å¸ä¸DeFi.md) - DeFié›†æˆ
- [30.æ¯”ç‰¹å¸äºŒå±‚ç”Ÿæ€å…¨æ™¯.md](./30.æ¯”ç‰¹å¸äºŒå±‚ç”Ÿæ€å…¨æ™¯.md) - Layer 2æ–¹æ¡ˆ
- [21.æ¯”ç‰¹å¸æ™ºèƒ½åˆçº¦.md](./21.æ¯”ç‰¹å¸æ™ºèƒ½åˆçº¦.md) - æ™ºèƒ½åˆçº¦åŸºç¡€

## 6. å‚è€ƒèµ„æ–™

- [Atomic Swapåè®®](https://en.bitcoin.it/wiki/Atomic_swap)
- [WBTCç™½çš®ä¹¦](https://wbtc.network/assets/wrapped-tokens-whitepaper.pdf)
- [Liquid Networkæ–‡æ¡£](https://docs.liquid.net/)