---
title: 比特币性能优化
date: 2025-09-30
permalink: /blockchain/bitcoin-performance-optimization.html
tags:
  - 区块链
  - 比特币
  - 性能优化
categories:
  - 区块链
---

# 比特币性能优化

## 1. 交易费用优化

### 1.1 动态费率估算

```java
/**
 * 智能费率估算器
 */
public class SmartFeeEstimator {

    private BitcoinRpcClient rpcClient;
    private FeeRateCache cache;

    public static class FeeRate {
        double satPerByte;
        double satPerVByte;  // 虚拟字节(SegWit)
        int targetBlocks;
        double confidence;
    }

    /**
     * 估算最优费率
     */
    public FeeRate estimateOptimalFee(int urgency) throws Exception {
        // urgency: 1=最快, 6=正常, 144=经济
        int targetBlocks = getTargetBlocks(urgency);

        // 使用Bitcoin Core的费率估算
        JSONObject estimate = rpcClient.call("estimatesmartfee", targetBlocks);

        FeeRate feeRate = new FeeRate();
        feeRate.targetBlocks = targetBlocks;

        if (estimate.has("feerate")) {
            // BTC/KB -> sat/vByte
            double btcPerKB = estimate.getDouble("feerate");
            feeRate.satPerVByte = btcPerKB * 100000 / 1000;
            feeRate.confidence = 0.95;
        } else {
            // 使用保守估算
            feeRate.satPerVByte = getConservativeEstimate();
            feeRate.confidence = 0.5;
        }

        return feeRate;
    }

    /**
     * 根据内存池状态估算费率
     */
    public FeeRate estimateFromMempool() throws Exception {
        JSONObject mempoolInfo = rpcClient.call("getmempoolinfo");

        long mempoolSize = mempoolInfo.getLong("size");
        long mempoolBytes = mempoolInfo.getLong("bytes");
        double minFee = mempoolInfo.getDouble("mempoolminfee");

        FeeRate feeRate = new FeeRate();

        // 根据内存池拥堵程度调整费率
        if (mempoolSize > 50000) {
            // 严重拥堵
            feeRate.satPerVByte = Math.max(minFee * 100000 / 1000 * 3, 50);
            feeRate.targetBlocks = 6;
        } else if (mempoolSize > 10000) {
            // 中度拥堵
            feeRate.satPerVByte = Math.max(minFee * 100000 / 1000 * 2, 20);
            feeRate.targetBlocks = 3;
        } else {
            // 正常
            feeRate.satPerVByte = Math.max(minFee * 100000 / 1000, 5);
            feeRate.targetBlocks = 1;
        }

        return feeRate;
    }

    /**
     * 批量交易费率优化
     */
    public double calculateBatchFee(int outputCount, FeeRate baseRate) {
        // 基础大小: 10 bytes (version + locktime)
        // 输入: ~148 bytes (legacy) / ~68 bytes (SegWit)
        // 输出: ~34 bytes

        int baseSize = 10;
        int inputSize = 68; // 使用SegWit
        int outputSize = 34 * outputCount;

        int totalVBytes = baseSize + inputSize + outputSize;

        return totalVBytes * baseRate.satPerVByte;
    }

    private int getTargetBlocks(int urgency) {
        switch (urgency) {
            case 1: return 1;   // 下一个区块
            case 2: return 3;   // 30分钟内
            case 3: return 6;   // 1小时内
            case 4: return 12;  // 2小时内
            case 5: return 144; // 1天内
            default: return 6;
        }
    }

    private double getConservativeEstimate() {
        return 10.0; // 10 sat/vByte 保守估算
    }
}
```

### 1.2 UTXO管理策略

```java
/**
 * UTXO优化管理器
 */
public class UTXOOptimizer {

    public static class UTXO {
        String txid;
        int vout;
        long value;
        int confirmations;
        boolean spendable;
        boolean segwit;
    }

    /**
     * UTXO选择策略
     */
    public enum SelectionStrategy {
        LARGEST_FIRST,      // 最大优先
        SMALLEST_FIRST,     // 最小优先
        OLDEST_FIRST,       // 最老优先
        BRANCH_AND_BOUND,   // 分支定界(最优)
        ACCUMULATIVE        // 累积策略
    }

    /**
     * 智能UTXO选择
     */
    public List<UTXO> selectUTXOs(
            List<UTXO> available,
            long targetAmount,
            double feeRate,
            SelectionStrategy strategy) {

        switch (strategy) {
            case BRANCH_AND_BOUND:
                return branchAndBound(available, targetAmount, feeRate);
            case LARGEST_FIRST:
                return largestFirst(available, targetAmount, feeRate);
            case SMALLEST_FIRST:
                return smallestFirst(available, targetAmount, feeRate);
            default:
                return accumulative(available, targetAmount, feeRate);
        }
    }

    /**
     * 分支定界算法 - 寻找最优UTXO组合
     */
    private List<UTXO> branchAndBound(
            List<UTXO> utxos,
            long target,
            double feeRate) {

        // 排序UTXO
        utxos.sort((a, b) -> Long.compare(b.value, a.value));

        List<UTXO> bestSolution = null;
        long bestWaste = Long.MAX_VALUE;

        // 尝试不同的组合
        for (int mask = 1; mask < (1 << Math.min(utxos.size(), 20)); mask++) {
            List<UTXO> combination = new ArrayList<>();
            long total = 0;

            for (int i = 0; i < utxos.size(); i++) {
                if ((mask & (1 << i)) != 0) {
                    combination.add(utxos.get(i));
                    total += utxos.get(i).value;
                }
            }

            // 计算费用
            long fee = calculateFee(combination.size(), 2, feeRate);

            if (total >= target + fee) {
                // 计算浪费(找零)
                long waste = total - target - fee;

                if (waste < bestWaste) {
                    bestWaste = waste;
                    bestSolution = new ArrayList<>(combination);
                }

                // 如果浪费很小,直接返回
                if (waste < 1000) { // 少于1000 satoshi
                    break;
                }
            }
        }

        return bestSolution != null ? bestSolution :
               accumulative(utxos, target, feeRate);
    }

    /**
     * 累积策略(简单但有效)
     */
    private List<UTXO> accumulative(
            List<UTXO> utxos,
            long target,
            double feeRate) {

        // 优先使用较大的UTXO
        utxos.sort((a, b) -> Long.compare(b.value, a.value));

        List<UTXO> selected = new ArrayList<>();
        long total = 0;

        for (UTXO utxo : utxos) {
            selected.add(utxo);
            total += utxo.value;

            long fee = calculateFee(selected.size(), 2, feeRate);

            if (total >= target + fee) {
                return selected;
            }
        }

        throw new RuntimeException("余额不足");
    }

    private List<UTXO> largestFirst(List<UTXO> utxos, long target, double feeRate) {
        utxos.sort((a, b) -> Long.compare(b.value, a.value));
        return accumulative(utxos, target, feeRate);
    }

    private List<UTXO> smallestFirst(List<UTXO> utxos, long target, double feeRate) {
        utxos.sort((a, b) -> Long.compare(a.value, b.value));
        return accumulative(utxos, target, feeRate);
    }

    /**
     * UTXO整合建议
     */
    public ConsolidationPlan planConsolidation(List<UTXO> utxos, double currentFeeRate) {
        ConsolidationPlan plan = new ConsolidationPlan();

        // 过滤小额UTXO
        List<UTXO> dustUTXOs = utxos.stream()
            .filter(u -> u.value < 10000) // 小于0.0001 BTC
            .collect(Collectors.toList());

        if (dustUTXOs.isEmpty()) {
            plan.needed = false;
            return plan;
        }

        plan.needed = true;
        plan.utxoCount = dustUTXOs.size();

        // 计算整合成本
        long consolidationFee = calculateFee(dustUTXOs.size(), 1, currentFeeRate);
        long totalValue = dustUTXOs.stream().mapToLong(u -> u.value).sum();

        plan.costSatoshis = consolidationFee;
        plan.worthIt = totalValue > consolidationFee * 2;

        // 建议在费率低时整合
        plan.recommendedFeeRate = 5.0; // 5 sat/vByte

        return plan;
    }

    /**
     * 计算交易费用
     */
    private long calculateFee(int inputCount, int outputCount, double feeRate) {
        // 估算交易大小
        int baseSize = 10;
        int inputSize = 68 * inputCount;  // SegWit输入
        int outputSize = 34 * outputCount;

        int totalVBytes = baseSize + inputSize + outputSize;

        return (long) (totalVBytes * feeRate);
    }

    public static class ConsolidationPlan {
        boolean needed;
        int utxoCount;
        long costSatoshis;
        boolean worthIt;
        double recommendedFeeRate;
    }
}
```

### 1.3 批量支付优化

```java
/**
 * 批量支付优化器
 */
public class BatchPaymentOptimizer {

    /**
     * 批量支付构建器
     */
    public Transaction createBatchPayment(
            List<Payment> payments,
            List<UTXO> utxos,
            double feeRate) {

        // 合并相同地址的支付
        Map<String, Long> consolidatedPayments = new HashMap<>();
        for (Payment p : payments) {
            consolidatedPayments.merge(p.address, p.amount, Long::sum);
        }

        // 选择UTXO
        long totalOutput = consolidatedPayments.values().stream()
            .mapToLong(Long::longValue)
            .sum();

        UTXOOptimizer optimizer = new UTXOOptimizer();
        List<UTXO> selectedUTXOs = optimizer.selectUTXOs(
            utxos,
            totalOutput,
            feeRate,
            UTXOOptimizer.SelectionStrategy.BRANCH_AND_BOUND
        );

        // 构建交易
        Transaction tx = new Transaction();

        // 添加输入
        for (UTXO utxo : selectedUTXOs) {
            TxInput input = new TxInput();
            input.setPrevTxid(utxo.txid);
            input.setPrevVout(utxo.vout);
            tx.addInput(input);
        }

        // 添加输出
        for (Map.Entry<String, Long> entry : consolidatedPayments.entrySet()) {
            TxOutput output = new TxOutput();
            output.setAddress(entry.getKey());
            output.setValue(entry.getValue());
            tx.addOutput(output);
        }

        // 计算找零
        long totalInput = selectedUTXOs.stream()
            .mapToLong(u -> u.value)
            .sum();

        long fee = optimizer.calculateFee(
            selectedUTXOs.size(),
            consolidatedPayments.size() + 1, // +1 for change
            feeRate
        );

        long change = totalInput - totalOutput - fee;

        if (change > 546) { // 高于粉尘限制
            TxOutput changeOutput = new TxOutput();
            changeOutput.setAddress(getChangeAddress());
            changeOutput.setValue(change);
            tx.addOutput(changeOutput);
        }

        return tx;
    }

    /**
     * 计算批量支付节省的费用
     */
    public long calculateSavings(List<Payment> payments, double feeRate) {
        // 单独发送的总费用
        long individualCost = 0;
        for (Payment p : payments) {
            // 假设每笔交易 1 input, 2 outputs
            individualCost += (10 + 68 + 34 * 2) * (long)feeRate;
        }

        // 批量发送的费用
        // 1 input, N outputs
        long batchCost = (10 + 68 + 34 * payments.size()) * (long)feeRate;

        return individualCost - batchCost;
    }

    private String getChangeAddress() {
        return "your_change_address";
    }

    public static class Payment {
        String address;
        long amount;
    }
}
```

## 2. SegWit优化

### 2.1 SegWit交易构建

```java
/**
 * SegWit交易优化器
 */
public class SegWitOptimizer {

    /**
     * 创建原生SegWit交易(P2WPKH)
     */
    public Transaction createNativeSegWitTx(
            List<UTXO> inputs,
            List<TxOutput> outputs,
            String changeAddress) {

        Transaction tx = new Transaction();
        tx.setVersion(2);

        // 添加输入
        for (UTXO utxo : inputs) {
            TxInput input = new TxInput();
            input.setPrevTxid(utxo.txid);
            input.setPrevVout(utxo.vout);
            input.setScriptSig(new byte[0]); // SegWit输入scriptSig为空
            input.setSequence(0xFFFFFFFE); // 支持RBF
            tx.addInput(input);
        }

        // 添加输出
        for (TxOutput output : outputs) {
            tx.addOutput(output);
        }

        // 添加witness数据
        for (int i = 0; i < inputs.size(); i++) {
            UTXO utxo = inputs.get(i);
            Witness witness = createWitness(utxo, tx, i);
            tx.setWitness(i, witness);
        }

        return tx;
    }

    /**
     * 创建witness数据
     */
    private Witness createWitness(UTXO utxo, Transaction tx, int inputIndex) {
        Witness witness = new Witness();

        // 签名
        byte[] signature = signSegWitInput(tx, inputIndex, utxo);
        witness.addItem(signature);

        // 公钥
        byte[] pubKey = getPublicKey(utxo);
        witness.addItem(pubKey);

        return witness;
    }

    /**
     * SegWit签名哈希计算(BIP143)
     */
    private byte[] calculateSegWitSigHash(
            Transaction tx,
            int inputIndex,
            byte[] scriptCode,
            long amount) {

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            // 1. nVersion
            writeUint32(baos, tx.getVersion());

            // 2. hashPrevouts
            byte[] hashPrevouts = calculateHashPrevouts(tx);
            baos.write(hashPrevouts);

            // 3. hashSequence
            byte[] hashSequence = calculateHashSequence(tx);
            baos.write(hashSequence);

            // 4. outpoint
            TxInput input = tx.getInputs().get(inputIndex);
            baos.write(Hex.decode(input.getPrevTxid()));
            writeUint32(baos, input.getPrevVout());

            // 5. scriptCode
            writeVarInt(baos, scriptCode.length);
            baos.write(scriptCode);

            // 6. amount
            writeUint64(baos, amount);

            // 7. sequence
            writeUint32(baos, input.getSequence());

            // 8. hashOutputs
            byte[] hashOutputs = calculateHashOutputs(tx);
            baos.write(hashOutputs);

            // 9. nLocktime
            writeUint32(baos, tx.getLockTime());

            // 10. sighash type
            writeUint32(baos, 0x01); // SIGHASH_ALL

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        // 双SHA256
        return Hash.sha256(Hash.sha256(baos.toByteArray()));
    }

    private byte[] calculateHashPrevouts(Transaction tx) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        for (TxInput input : tx.getInputs()) {
            try {
                baos.write(Hex.decode(input.getPrevTxid()));
                writeUint32(baos, input.getPrevVout());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return Hash.sha256(Hash.sha256(baos.toByteArray()));
    }

    private byte[] calculateHashSequence(Transaction tx) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        for (TxInput input : tx.getInputs()) {
            try {
                writeUint32(baos, input.getSequence());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return Hash.sha256(Hash.sha256(baos.toByteArray()));
    }

    private byte[] calculateHashOutputs(Transaction tx) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        for (TxOutput output : tx.getOutputs()) {
            try {
                writeUint64(baos, output.getValue());
                byte[] scriptPubKey = output.getScriptPubKey();
                writeVarInt(baos, scriptPubKey.length);
                baos.write(scriptPubKey);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return Hash.sha256(Hash.sha256(baos.toByteArray()));
    }

    /**
     * 计算SegWit折扣后的交易大小
     */
    public int calculateVirtualSize(Transaction tx) {
        int baseSize = calculateBaseSize(tx);
        int totalSize = calculateTotalSize(tx);
        int weight = baseSize * 3 + totalSize;
        return (weight + 3) / 4; // 向上取整
    }

    private int calculateBaseSize(Transaction tx) {
        // 不包含witness数据的大小
        int size = 0;
        size += 4; // version
        size += tx.getInputs().size() * 41; // inputs without witness
        size += tx.getOutputs().size() * 34; // outputs
        size += 4; // locktime
        return size;
    }

    private int calculateTotalSize(Transaction tx) {
        // 包含witness数据的总大小
        int size = calculateBaseSize(tx);

        // 添加witness数据
        for (Witness witness : tx.getWitnesses()) {
            size += witness.getSize();
        }

        return size;
    }

    /**
     * SegWit vs Legacy 费用对比
     */
    public ComparisonResult compareSegWitVsLegacy(
            int inputCount,
            int outputCount,
            double feeRate) {

        ComparisonResult result = new ComparisonResult();

        // Legacy交易大小
        int legacySize = 10 + inputCount * 148 + outputCount * 34;
        result.legacySize = legacySize;
        result.legacyFee = (long)(legacySize * feeRate);

        // SegWit交易虚拟大小
        int segwitVSize = 10 + inputCount * 68 + outputCount * 34;
        result.segwitVSize = segwitVSize;
        result.segwitFee = (long)(segwitVSize * feeRate);

        // 节省
        result.savings = result.legacyFee - result.segwitFee;
        result.savingsPercent = (result.savings * 100.0) / result.legacyFee;

        return result;
    }

    private byte[] signSegWitInput(Transaction tx, int index, UTXO utxo) {
        // 实现SegWit签名
        return new byte[64];
    }

    private byte[] getPublicKey(UTXO utxo) {
        return new byte[33];
    }

    private void writeUint32(OutputStream os, long value) throws IOException {
        os.write((int)(value & 0xFF));
        os.write((int)((value >> 8) & 0xFF));
        os.write((int)((value >> 16) & 0xFF));
        os.write((int)((value >> 24) & 0xFF));
    }

    private void writeUint64(OutputStream os, long value) throws IOException {
        for (int i = 0; i < 8; i++) {
            os.write((int)((value >> (i * 8)) & 0xFF));
        }
    }

    private void writeVarInt(OutputStream os, long value) throws IOException {
        if (value < 0xFD) {
            os.write((int)value);
        } else if (value <= 0xFFFF) {
            os.write(0xFD);
            writeUint16(os, (int)value);
        } else if (value <= 0xFFFFFFFF) {
            os.write(0xFE);
            writeUint32(os, value);
        } else {
            os.write(0xFF);
            writeUint64(os, value);
        }
    }

    private void writeUint16(OutputStream os, int value) throws IOException {
        os.write(value & 0xFF);
        os.write((value >> 8) & 0xFF);
    }

    public static class ComparisonResult {
        int legacySize;
        long legacyFee;
        int segwitVSize;
        long segwitFee;
        long savings;
        double savingsPercent;
    }

    static class Witness {
        private List<byte[]> items = new ArrayList<>();

        void addItem(byte[] item) {
            items.add(item);
        }

        int getSize() {
            int size = 1; // item count
            for (byte[] item : items) {
                size += 1 + item.length; // length + data
            }
            return size;
        }
    }
}
```

## 3. 网络性能优化

### 3.1 连接池管理

```java
/**
 * 比特币节点连接池
 */
public class NodeConnectionPool {

    private List<NodeConnection> connections;
    private int maxConnections;
    private ExecutorService executor;

    public static class NodeConnection {
        String address;
        int port;
        boolean active;
        long latency;
        int blockHeight;
        long lastSeen;
    }

    /**
     * 优化peer连接
     */
    public void optimizeConnections() {
        // 移除慢速节点
        removeSlow节点();

        // 添加更快的节点
        discoverFastPeers();

        // 平衡地理分布
        balanceGeography();
    }

    private void removeSlow节点() {
        connections.removeIf(conn ->
            conn.latency > 1000 || // 延迟超过1秒
            System.currentTimeMillis() - conn.lastSeen > 60000 // 1分钟无响应
        );
    }

    private void discoverFastPeers() {
        // 从DNS种子获取新节点
        List<String> seedNodes = queryDNSSeeds();

        for (String node : seedNodes) {
            if (connections.size() >= maxConnections) {
                break;
            }

            // 测试节点速度
            long latency = testLatency(node);
            if (latency < 500) { // 延迟小于500ms
                addConnection(node, latency);
            }
        }
    }

    private void balanceGeography() {
        // 确保连接分布在不同地区
        // 避免集中在单一ISP或地区
    }

    private List<String> queryDNSSeeds() {
        return Arrays.asList(
            "seed.bitcoin.sipa.be",
            "dnsseed.bluematt.me",
            "seed.bitcoinstats.com"
        );
    }

    private long testLatency(String node) {
        long start = System.currentTimeMillis();
        // 发送ping消息
        return System.currentTimeMillis() - start;
    }

    private void addConnection(String node, long latency) {
        // 添加新连接
    }
}
```

### 3.2 交易传播优化

```java
/**
 * 交易传播优化器
 */
public class TransactionPropagator {

    /**
     * 智能交易广播
     */
    public void broadcastSmart(Transaction tx, List<NodeConnection> peers) {
        // 1. 选择最优节点
        List<NodeConnection> bestPeers = selectBestPeers(peers, 8);

        // 2. 并行广播
        CountDownLatch latch = new CountDownLatch(bestPeers.size());

        for (NodeConnection peer : bestPeers) {
            executor.submit(() -> {
                try {
                    sendTransaction(peer, tx);
                } finally {
                    latch.countDown();
                }
            });
        }

        // 3. 等待至少一半节点确认
        try {
            latch.await(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private List<NodeConnection> selectBestPeers(
            List<NodeConnection> all,
            int count) {

        return all.stream()
            .filter(p -> p.active)
            .sorted((a, b) -> Long.compare(a.latency, b.latency))
            .limit(count)
            .collect(Collectors.toList());
    }

    private void sendTransaction(NodeConnection peer, Transaction tx) {
        // 发送交易到节点
    }

    private ExecutorService executor = Executors.newFixedThreadPool(10);
}
```

## 4. 存储优化

### 4.1 数据库索引优化

```java
/**
 * 区块链数据库优化
 */
public class BlockchainDatabaseOptimizer {

    /**
     * 创建优化索引
     */
    public void createOptimizedIndexes(Connection conn) throws SQLException {
        // 交易哈希索引
        conn.createStatement().execute(
            "CREATE INDEX IF NOT EXISTS idx_tx_hash " +
            "ON transactions(tx_hash) USING HASH"
        );

        // 地址索引
        conn.createStatement().execute(
            "CREATE INDEX IF NOT EXISTS idx_address " +
            "ON outputs(address) USING BTREE"
        );

        // 区块高度索引
        conn.createStatement().execute(
            "CREATE INDEX IF NOT EXISTS idx_block_height " +
            "ON blocks(height) USING BTREE"
        );

        // UTXO集合索引
        conn.createStatement().execute(
            "CREATE INDEX IF NOT EXISTS idx_utxo " +
            "ON outputs(tx_hash, vout) " +
            "WHERE spent = false"
        );
    }

    /**
     * UTXO集合优化存储
     */
    public void optimizeUTXOSet() {
        // 使用专门的UTXO数据库(如LevelDB)
        // 只存储未花费输出
        // 定期清理已花费的输出
    }
}
```

## 5. 相关文档

- [比特币交易构建与广播](./16.比特币交易构建与广播.md)
- [比特币节点运维实战](./22.比特币节点运维实战.md)
- [比特币改进提案(BIPs)详解](./18.比特币改进提案(BIPs)详解.md)

## 参考资源

- [BIP141: Segregated Witness](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)
- [BIP143: Transaction Signature Verification for SegWit](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki)
- [Bitcoin Core Performance](https://bitcoin.org/en/bitcoin-core/features/validation)