---
title: æ¯”ç‰¹å¸æ”¹è¿›ææ¡ˆ(BIPs)è¯¦è§£
date: 2025-09-30
permalink: /blockchain/bitcoin-bips.html
tags:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸
  - BIP
  - åè®®å‡çº§
categories:
  - åŒºå—é“¾
---

# æ¯”ç‰¹å¸æ”¹è¿›ææ¡ˆ(BIPs)è¯¦è§£

## BIPæ¦‚è¿°

BIPï¼ˆBitcoin Improvement Proposalï¼Œæ¯”ç‰¹å¸æ”¹è¿›ææ¡ˆï¼‰æ˜¯æ¯”ç‰¹å¸ç¤¾åŒºæå‡ºã€è®¨è®ºå’Œå®æ–½åè®®æ”¹è¿›çš„æ ‡å‡†åŒ–æµç¨‹ã€‚

### BIPæµç¨‹

```mermaid
graph LR
    A[æƒ³æ³•] --> B[è‰æ¡ˆ]
    B --> C[æè®®]
    C --> D[æœ€ç»ˆ]
    D --> E[æ¿€æ´»]

    C --> F[è¢«æ‹’ç»]
    C --> G[æ’¤å›]

    style E fill:#90EE90
    style F fill:#FFB6C6
    style G fill:#FFE4B5
```

### BIPç±»å‹

```java
public enum BIPType {
    // æ ‡å‡†è·Ÿè¸ªBIP
    STANDARDS_TRACK("æ ‡å‡†è·Ÿè¸ª", "å½±å“æ¯”ç‰¹å¸å®ç°"),

    // ä¿¡æ¯å‹BIP
    INFORMATIONAL("ä¿¡æ¯å‹", "æä¾›ä¿¡æ¯æˆ–æŒ‡å—"),

    // æµç¨‹BIP
    PROCESS("æµç¨‹", "æè¿°æµç¨‹æˆ–ç¯å¢ƒå˜åŒ–");

    private String name;
    private String description;

    BIPType(String name, String description) {
        this.name = name;
        this.description = description;
    }
}

public enum BIPLayer {
    CONSENSUS("å…±è¯†å±‚", "éœ€è¦ç½‘ç»œå…±è¯†"),
    PEER_SERVICES("å¯¹ç­‰æœåŠ¡", "èŠ‚ç‚¹åè®®"),
    API_RPC("API/RPC", "æ¥å£å±‚"),
    APPLICATIONS("åº”ç”¨å±‚", "åº”ç”¨ç¨‹åº");

    private String name;
    private String description;
}
```

## é‡è¦BIPè¯¦è§£

### BIP 32: HDé’±åŒ…ï¼ˆåˆ†å±‚ç¡®å®šæ€§é’±åŒ…ï¼‰

```java
public class BIP32_HDWallet {

    // æ‰©å±•å¯†é’¥ç»“æ„
    public class ExtendedKey {
        private byte[] key;           // 33å­—èŠ‚ï¼ˆç§é’¥æˆ–å…¬é’¥ï¼‰
        private byte[] chainCode;     // 32å­—èŠ‚
        private int depth;            // 1å­—èŠ‚
        private int fingerprint;      // 4å­—èŠ‚
        private int childNumber;      // 4å­—èŠ‚

        // åºåˆ—åŒ–ä¸ºxprv/xpub
        public String serialize() {
            ByteBuffer buffer = ByteBuffer.allocate(78);

            // ç‰ˆæœ¬ï¼ˆ4å­—èŠ‚ï¼‰
            buffer.putInt(isPrivate() ? 0x0488ADE4 : 0x0488B21E);

            // æ·±åº¦
            buffer.put((byte) depth);

            // çˆ¶æŒ‡çº¹
            buffer.putInt(fingerprint);

            // å­ç´¢å¼•
            buffer.putInt(childNumber);

            // é“¾ç 
            buffer.put(chainCode);

            // å¯†é’¥
            buffer.put(key);

            // Base58Checkç¼–ç 
            return Base58Check.encode(buffer.array());
        }
    }

    // ä¸»å¯†é’¥ç”Ÿæˆ
    public ExtendedKey generateMasterKey(byte[] seed) {
        System.out.println("=== BIP32 ä¸»å¯†é’¥ç”Ÿæˆ ===\n");

        // 1. HMAC-SHA512
        byte[] hmac = HMACSHA512.hash("Bitcoin seed".getBytes(), seed);

        // 2. åˆ†å‰²ä¸ºç§é’¥å’Œé“¾ç 
        byte[] masterPrivateKey = Arrays.copyOfRange(hmac, 0, 32);
        byte[] masterChainCode = Arrays.copyOfRange(hmac, 32, 64);

        ExtendedKey masterKey = new ExtendedKey();
        masterKey.key = masterPrivateKey;
        masterKey.chainCode = masterChainCode;
        masterKey.depth = 0;
        masterKey.fingerprint = 0;
        masterKey.childNumber = 0;

        System.out.println("ä¸»ç§é’¥: " + bytesToHex(masterPrivateKey));
        System.out.println("é“¾ç : " + bytesToHex(masterChainCode));

        return masterKey;
    }

    // å­å¯†é’¥æ´¾ç”Ÿ
    public ExtendedKey deriveChild(ExtendedKey parent, int index) {
        boolean hardened = (index >= 0x80000000);

        System.out.println("\næ´¾ç”Ÿå­å¯†é’¥:");
        System.out.println("ç´¢å¼•: " + index + (hardened ? " (å¼ºåŒ–)" : " (æ™®é€š)"));

        ByteBuffer data = ByteBuffer.allocate(37);

        if (hardened) {
            // å¼ºåŒ–æ´¾ç”Ÿï¼šä½¿ç”¨ç§é’¥
            data.put((byte) 0x00);
            data.put(parent.key);
        } else {
            // æ™®é€šæ´¾ç”Ÿï¼šä½¿ç”¨å…¬é’¥
            byte[] publicKey = derivePublicKey(parent.key);
            data.put(publicKey);
        }

        data.putInt(index);

        // HMAC-SHA512
        byte[] hmac = HMACSHA512.hash(parent.chainCode, data.array());

        // å­ç§é’¥ = parse256(IL) + kpar (mod n)
        byte[] childKey = addKeys(
            Arrays.copyOfRange(hmac, 0, 32),
            parent.key
        );

        byte[] childChainCode = Arrays.copyOfRange(hmac, 32, 64);

        ExtendedKey child = new ExtendedKey();
        child.key = childKey;
        child.chainCode = childChainCode;
        child.depth = parent.depth + 1;
        child.fingerprint = calculateFingerprint(parent);
        child.childNumber = index;

        return child;
    }

    // BIP32æ´¾ç”Ÿè·¯å¾„
    public ExtendedKey derivePath(ExtendedKey master, String path) {
        System.out.println("\n=== æ´¾ç”Ÿè·¯å¾„: " + path + " ===");

        // è§£æè·¯å¾„ m/44'/0'/0'/0/0
        String[] parts = path.split("/");

        ExtendedKey current = master;

        for (int i = 1; i < parts.length; i++) {
            String part = parts[i];
            boolean hardened = part.endsWith("'");

            int index = Integer.parseInt(part.replace("'", ""));
            if (hardened) {
                index += 0x80000000;
            }

            current = deriveChild(current, index);
            System.out.println("çº§åˆ« " + i + ": " + part);
        }

        return current;
    }

    // ç¤ºä¾‹ï¼šç”Ÿæˆæ¥æ”¶åœ°å€
    public void demonstrateHDWallet() {
        System.out.println("=== BIP32 HDé’±åŒ…æ¼”ç¤º ===\n");

        // 1. ä»åŠ©è®°è¯ç”Ÿæˆç§å­
        String mnemonic = "abandon abandon abandon abandon abandon abandon " +
                         "abandon abandon abandon abandon abandon about";
        byte[] seed = mnemonicToSeed(mnemonic);

        // 2. ç”Ÿæˆä¸»å¯†é’¥
        ExtendedKey master = generateMasterKey(seed);
        System.out.println("ä¸»å¯†é’¥: " + master.serialize());

        // 3. æ´¾ç”Ÿè´¦æˆ·ï¼ˆBIP44è·¯å¾„ï¼‰
        // m/44'/0'/0' - æ¯”ç‰¹å¸ä¸»ç½‘ç¬¬ä¸€ä¸ªè´¦æˆ·
        ExtendedKey account = derivePath(master, "m/44'/0'/0'");

        // 4. ç”Ÿæˆæ¥æ”¶åœ°å€
        System.out.println("\næ¥æ”¶åœ°å€:");
        for (int i = 0; i < 5; i++) {
            ExtendedKey address = deriveChild(
                deriveChild(account, 0),  // å¤–éƒ¨é“¾
                i                          // åœ°å€ç´¢å¼•
            );

            String btcAddress = keyToAddress(address.key);
            System.out.println("åœ°å€ " + i + ": " + btcAddress);
        }

        // 5. ç”Ÿæˆæ‰¾é›¶åœ°å€
        System.out.println("\næ‰¾é›¶åœ°å€:");
        for (int i = 0; i < 5; i++) {
            ExtendedKey change = deriveChild(
                deriveChild(account, 1),  // å†…éƒ¨é“¾ï¼ˆæ‰¾é›¶ï¼‰
                i
            );

            String btcAddress = keyToAddress(change.key);
            System.out.println("æ‰¾é›¶ " + i + ": " + btcAddress);
        }
    }
}
```

### BIP 39: åŠ©è®°è¯

```java
public class BIP39_Mnemonic {

    private static final String[] WORDLIST = loadWordlist("english.txt");

    // ç”ŸæˆåŠ©è®°è¯
    public String generateMnemonic(int strength) {
        System.out.println("=== BIP39 åŠ©è®°è¯ç”Ÿæˆ ===\n");

        // 1. ç”Ÿæˆç†µï¼ˆ128-256ä½ï¼‰
        if (strength % 32 != 0 || strength < 128 || strength > 256) {
            throw new IllegalArgumentException("å¼ºåº¦å¿…é¡»æ˜¯128-256ä¹‹é—´çš„32çš„å€æ•°");
        }

        byte[] entropy = new byte[strength / 8];
        new SecureRandom().nextBytes(entropy);

        System.out.println("ç†µå¼ºåº¦: " + strength + " ä½");
        System.out.println("ç†µ: " + bytesToHex(entropy));

        // 2. è®¡ç®—æ ¡éªŒå’Œ
        byte[] hash = SHA256.hash(entropy);
        int checksumLength = strength / 32;

        // 3. å°†ç†µå’Œæ ¡éªŒå’Œç»„åˆ
        BitSet bits = new BitSet(strength + checksumLength);

        // æ·»åŠ ç†µä½
        for (int i = 0; i < strength; i++) {
            if ((entropy[i / 8] & (1 << (7 - i % 8))) != 0) {
                bits.set(i);
            }
        }

        // æ·»åŠ æ ¡éªŒå’Œä½
        for (int i = 0; i < checksumLength; i++) {
            if ((hash[i / 8] & (1 << (7 - i % 8))) != 0) {
                bits.set(strength + i);
            }
        }

        // 4. åˆ†å‰²ä¸º11ä½çš„ç»„
        int wordCount = (strength + checksumLength) / 11;
        String[] words = new String[wordCount];

        for (int i = 0; i < wordCount; i++) {
            int index = 0;
            for (int j = 0; j < 11; j++) {
                if (bits.get(i * 11 + j)) {
                    index |= (1 << (10 - j));
                }
            }
            words[i] = WORDLIST[index];
        }

        String mnemonic = String.join(" ", words);
        System.out.println("\nåŠ©è®°è¯ (" + wordCount + " ä¸ªå•è¯):");
        System.out.println(mnemonic);

        return mnemonic;
    }

    // åŠ©è®°è¯è½¬ç§å­
    public byte[] mnemonicToSeed(String mnemonic, String passphrase) {
        System.out.println("\n=== åŠ©è®°è¯è½¬ç§å­ ===");

        // PBKDF2-HMAC-SHA512
        // ç› = "mnemonic" + passphrase
        String salt = "mnemonic" + (passphrase != null ? passphrase : "");

        // 2048è½®è¿­ä»£
        byte[] seed = PBKDF2.derive(
            mnemonic.getBytes(StandardCharsets.UTF_8),
            salt.getBytes(StandardCharsets.UTF_8),
            2048,
            64  // 512ä½
        );

        System.out.println("ç§å­: " + bytesToHex(seed));

        return seed;
    }

    // éªŒè¯åŠ©è®°è¯
    public boolean validateMnemonic(String mnemonic) {
        String[] words = mnemonic.trim().split("\\s+");

        // æ£€æŸ¥å•è¯æ•°é‡
        if (words.length % 3 != 0 || words.length < 12 || words.length > 24) {
            System.out.println("âŒ æ— æ•ˆçš„å•è¯æ•°é‡: " + words.length);
            return false;
        }

        // æ£€æŸ¥æ‰€æœ‰å•è¯æ˜¯å¦åœ¨è¯è¡¨ä¸­
        for (String word : words) {
            if (!isInWordlist(word)) {
                System.out.println("âŒ æ— æ•ˆçš„å•è¯: " + word);
                return false;
            }
        }

        // éªŒè¯æ ¡éªŒå’Œ
        int totalBits = words.length * 11;
        int checksumLength = totalBits / 33;
        int entropyLength = totalBits - checksumLength;

        BitSet bits = new BitSet(totalBits);

        for (int i = 0; i < words.length; i++) {
            int index = getWordIndex(words[i]);
            for (int j = 0; j < 11; j++) {
                if ((index & (1 << (10 - j))) != 0) {
                    bits.set(i * 11 + j);
                }
            }
        }

        // æå–ç†µ
        byte[] entropy = new byte[entropyLength / 8];
        for (int i = 0; i < entropyLength; i++) {
            if (bits.get(i)) {
                entropy[i / 8] |= (1 << (7 - i % 8));
            }
        }

        // è®¡ç®—æ ¡éªŒå’Œ
        byte[] hash = SHA256.hash(entropy);

        // éªŒè¯æ ¡éªŒå’Œ
        for (int i = 0; i < checksumLength; i++) {
            boolean expected = (hash[i / 8] & (1 << (7 - i % 8))) != 0;
            boolean actual = bits.get(entropyLength + i);

            if (expected != actual) {
                System.out.println("âŒ æ ¡éªŒå’ŒéªŒè¯å¤±è´¥");
                return false;
            }
        }

        System.out.println("âœ… åŠ©è®°è¯æœ‰æ•ˆ");
        return true;
    }

    // å®Œæ•´ç¤ºä¾‹
    public void demonstrateBIP39() {
        System.out.println("=== BIP39 å®Œæ•´æ¼”ç¤º ===\n");

        // 1. ç”ŸæˆåŠ©è®°è¯ï¼ˆ128ä½ç†µ = 12ä¸ªå•è¯ï¼‰
        String mnemonic = generateMnemonic(128);

        // 2. éªŒè¯åŠ©è®°è¯
        validateMnemonic(mnemonic);

        // 3. è½¬æ¢ä¸ºç§å­
        byte[] seed = mnemonicToSeed(mnemonic, "");

        // 4. ä»ç§å­ç”ŸæˆHDé’±åŒ…
        BIP32_HDWallet hdWallet = new BIP32_HDWallet();
        ExtendedKey master = hdWallet.generateMasterKey(seed);

        System.out.println("\nå¯ä»¥å¼€å§‹æ´¾ç”Ÿåœ°å€äº†ï¼");
    }
}
```

### BIP 141: éš”ç¦»è§è¯(SegWit)

```java
public class BIP141_SegWit {

    // SegWitäº¤æ˜“ç»“æ„
    public class SegWitTransaction {
        private int version;
        private byte marker = 0x00;      // SegWitæ ‡è®°
        private byte flag = 0x01;        // SegWitæ ‡å¿—
        private List<TxInput> inputs;
        private List<TxOutput> outputs;
        private List<Witness> witnesses; // è§è¯æ•°æ®
        private int locktime;

        // åˆ›å»ºSegWitäº¤æ˜“
        public SegWitTransaction createSegWitTx() {
            System.out.println("=== BIP141 SegWitäº¤æ˜“ ===\n");

            SegWitTransaction tx = new SegWitTransaction();
            tx.version = 2;

            // è¾“å…¥ï¼ˆscriptSigä¸ºç©ºï¼‰
            TxInput input = new TxInput();
            input.prevTxHash = "abc123...";
            input.outputIndex = 0;
            input.scriptSig = new byte[0];  // ç©ºï¼
            input.sequence = 0xFFFFFFFF;
            tx.inputs.add(input);

            // è¾“å‡º
            TxOutput output = new TxOutput();
            output.value = 100_000_000;  // 1 BTC
            output.scriptPubKey = createP2WPKHScript(recipientPubKeyHash);
            tx.outputs.add(output);

            // è§è¯æ•°æ®
            Witness witness = new Witness();
            witness.addStack(signature);     // ç­¾å
            witness.addStack(publicKey);     // å…¬é’¥
            tx.witnesses.add(witness);

            tx.locktime = 0;

            return tx;
        }

        // P2WPKHè„šæœ¬ï¼ˆåŸç”ŸSegWitï¼‰
        public byte[] createP2WPKHScript(byte[] pubKeyHash) {
            // OP_0 <20å­—èŠ‚pubKeyHash>
            ByteBuffer buffer = ByteBuffer.allocate(22);
            buffer.put((byte) 0x00);  // OP_0ï¼ˆç‰ˆæœ¬ï¼‰
            buffer.put((byte) 0x14);  // 20å­—èŠ‚
            buffer.put(pubKeyHash);

            return buffer.array();
        }

        // P2WSHè„šæœ¬ï¼ˆåŸç”ŸSegWitå¤šç­¾ï¼‰
        public byte[] createP2WSHScript(byte[] scriptHash) {
            // OP_0 <32å­—èŠ‚scriptHash>
            ByteBuffer buffer = ByteBuffer.allocate(34);
            buffer.put((byte) 0x00);  // OP_0
            buffer.put((byte) 0x20);  // 32å­—èŠ‚
            buffer.put(scriptHash);

            return buffer.array();
        }

        // åºåˆ—åŒ–ï¼ˆåŒ…å«è§è¯æ•°æ®ï¼‰
        public byte[] serialize() {
            ByteBuffer buffer = ByteBuffer.allocate(estimateSize());

            // ç‰ˆæœ¬
            buffer.putInt(version);

            // Markerå’ŒFlag
            buffer.put(marker);
            buffer.put(flag);

            // è¾“å…¥
            buffer.put(varInt(inputs.size()));
            for (TxInput input : inputs) {
                buffer.put(input.serialize());
            }

            // è¾“å‡º
            buffer.put(varInt(outputs.size()));
            for (TxOutput output : outputs) {
                buffer.put(output.serialize());
            }

            // è§è¯æ•°æ®
            for (Witness witness : witnesses) {
                buffer.put(varInt(witness.stackCount()));
                for (byte[] stack : witness.getStacks()) {
                    buffer.put(varInt(stack.length));
                    buffer.put(stack);
                }
            }

            // Locktime
            buffer.putInt(locktime);

            return buffer.array();
        }

        // è®¡ç®—äº¤æ˜“IDï¼ˆä¸åŒ…å«è§è¯æ•°æ®ï¼‰
        public String getTxId() {
            ByteBuffer buffer = ByteBuffer.allocate(estimateSizeWithoutWitness());

            // ç‰ˆæœ¬
            buffer.putInt(version);

            // è¾“å…¥ï¼ˆä¸å«markerå’Œflagï¼‰
            buffer.put(varInt(inputs.size()));
            for (TxInput input : inputs) {
                buffer.put(input.serialize());
            }

            // è¾“å‡º
            buffer.put(varInt(outputs.size()));
            for (TxOutput output : outputs) {
                buffer.put(output.serialize());
            }

            // Locktime
            buffer.putInt(locktime);

            // åŒé‡SHA256
            return bytesToHex(SHA256.doubleSha256(buffer.array()));
        }

        // è®¡ç®—è§è¯äº¤æ˜“ID
        public String getWTxId() {
            return bytesToHex(SHA256.doubleSha256(serialize()));
        }
    }

    // SegWitä¼˜åŠ¿
    public void demonstrateAdvantages() {
        System.out.println("\n=== SegWitä¼˜åŠ¿ ===\n");

        System.out.println("1. è§£å†³äº¤æ˜“å»¶å±•æ€§");
        System.out.println("   - ç­¾åä¸å½±å“äº¤æ˜“ID");
        System.out.println("   - æ”¯æŒé—ªç”µç½‘ç»œç­‰Layer 2");

        System.out.println("\n2. å¢åŠ åŒºå—å®¹é‡");
        System.out.println("   - åŒºå—æƒé‡ï¼š4MB");
        System.out.println("   - å®é™…å®¹é‡çº¦2-2.7MB");
        System.out.println("   - å‘åå…¼å®¹");

        System.out.println("\n3. é™ä½æ‰‹ç»­è´¹");
        Transaction legacy = createLegacyTx();
        Transaction segwit = createSegWitTx();

        int legacySize = legacy.getSize();
        int segwitSize = segwit.getVirtualSize();

        double savings = (1 - (double)segwitSize / legacySize) * 100;

        System.out.println("   - ä¼ ç»Ÿäº¤æ˜“å¤§å°: " + legacySize + " å­—èŠ‚");
        System.out.println("   - SegWitè™šæ‹Ÿå¤§å°: " + segwitSize + " vBytes");
        System.out.println("   - èŠ‚çœ: " + String.format("%.1f", savings) + "%");

        System.out.println("\n4. è„šæœ¬å‡çº§");
        System.out.println("   - ç‰ˆæœ¬åŒ–è§è¯ç¨‹åº");
        System.out.println("   - ä¾¿äºæœªæ¥å‡çº§ï¼ˆTaprootï¼‰");
    }

    // Bech32åœ°å€ï¼ˆBIP 173ï¼‰
    public String encodeBech32Address(byte[] witnessProg, int version) {
        System.out.println("\n=== Bech32åœ°å€ç¼–ç  ===");

        // HRP (Human Readable Part)
        String hrp = "bc";  // ä¸»ç½‘ï¼Œæµ‹è¯•ç½‘ç”¨"tb"

        // è½¬æ¢ä¸º5ä½å­—ç»„
        byte[] data = convertBits(witnessProg, 8, 5, true);

        // æ·»åŠ ç‰ˆæœ¬
        byte[] dataWithVersion = new byte[data.length + 1];
        dataWithVersion[0] = (byte) version;
        System.arraycopy(data, 0, dataWithVersion, 1, data.length);

        // è®¡ç®—æ ¡éªŒå’Œ
        byte[] checksum = bech32Checksum(hrp, dataWithVersion);

        // ç»„åˆ
        byte[] combined = new byte[dataWithVersion.length + checksum.length];
        System.arraycopy(dataWithVersion, 0, combined, 0, dataWithVersion.length);
        System.arraycopy(checksum, 0, combined, dataWithVersion.length, checksum.length);

        // ç¼–ç 
        StringBuilder address = new StringBuilder(hrp + "1");
        for (byte b : combined) {
            address.append(BECH32_CHARSET[b]);
        }

        String result = address.toString();
        System.out.println("Bech32åœ°å€: " + result);

        return result;
    }

    private static final char[] BECH32_CHARSET =
        "qpzry9x8gf2tvdw0s3jn54khce6mua7l".toCharArray();
}
```

### BIP 340-342: Taprootå‡çº§

```java
public class BIP340_342_Taproot {

    // Schnorrç­¾åï¼ˆBIP 340ï¼‰
    public class SchnorrSignature {

        public byte[] sign(byte[] privateKey, byte[] message) {
            System.out.println("=== BIP340 Schnorrç­¾å ===\n");

            // 1. ç”Ÿæˆéšæœºæ•°k
            byte[] k = generateNonce(privateKey, message);

            // 2. è®¡ç®—R = k*G
            ECPoint R = secp256k1.multiply(secp256k1.G, k);

            // 3. è®¡ç®—æŒ‘æˆ˜e = Hash(R || P || m)
            byte[] P = secp256k1.multiply(secp256k1.G, privateKey).encode();
            byte[] e = taggedHash("BIP0340/challenge",
                                 concat(R.encode(), P, message));

            // 4. è®¡ç®—s = k + e*d (mod n)
            BigInteger s = new BigInteger(1, k)
                .add(new BigInteger(1, e).multiply(new BigInteger(1, privateKey)))
                .mod(secp256k1.n);

            // 5. ç­¾å = (R, s)
            byte[] signature = concat(R.xCoord(), s.toByteArray());

            System.out.println("Schnorrç­¾å: " + bytesToHex(signature));

            return signature;
        }

        public boolean verify(byte[] publicKey, byte[] message, byte[] signature) {
            // è§£æç­¾å
            byte[] r = Arrays.copyOfRange(signature, 0, 32);
            byte[] s = Arrays.copyOfRange(signature, 32, 64);

            // è®¡ç®—æŒ‘æˆ˜e
            byte[] e = taggedHash("BIP0340/challenge",
                                 concat(r, publicKey, message));

            // éªŒè¯: s*G == R + e*P
            ECPoint sG = secp256k1.multiply(secp256k1.G, s);
            ECPoint R = new ECPoint(r);
            ECPoint eP = secp256k1.multiply(new ECPoint(publicKey), e);
            ECPoint sum = R.add(eP);

            return sG.equals(sum);
        }

        // Schnorrä¼˜åŠ¿
        public void demonstrateAdvantages() {
            System.out.println("\n=== Schnorrç­¾åä¼˜åŠ¿ ===\n");

            System.out.println("1. å¯†é’¥èšåˆ");
            System.out.println("   - å¤šä¸ªç­¾ååˆå¹¶ä¸ºä¸€ä¸ª");
            System.out.println("   - èŠ‚çœç©ºé—´å’Œè´¹ç”¨");

            System.out.println("\n2. æ‰¹é‡éªŒè¯");
            System.out.println("   - åŒæ—¶éªŒè¯å¤šä¸ªç­¾å");
            System.out.println("   - æé«˜éªŒè¯æ•ˆç‡");

            System.out.println("\n3. å¯è¯æ˜å®‰å…¨");
            System.out.println("   - æ•°å­¦è¯æ˜å®‰å…¨æ€§");
            System.out.println("   - ä¼˜äºECDSA");
        }
    }

    // Taprootï¼ˆBIP 341ï¼‰
    public class TaprootOutput {

        public byte[] createTaprootOutput(byte[] internalKey, byte[][] scripts) {
            System.out.println("\n=== BIP341 Taprootè¾“å‡º ===\n");

            // 1. æ„å»ºMerkleæ ‘
            byte[] merkleRoot = buildMerkleTree(scripts);
            System.out.println("Merkleæ ¹: " + bytesToHex(merkleRoot));

            // 2. è°ƒæ•´å†…éƒ¨å¯†é’¥
            byte[] tweakedKey = tweakKey(internalKey, merkleRoot);
            System.out.println("è°ƒæ•´åå¯†é’¥: " + bytesToHex(tweakedKey));

            // 3. åˆ›å»ºè¾“å‡ºè„šæœ¬
            // OP_1 <32å­—èŠ‚tweakedKey>
            byte[] scriptPubKey = new byte[34];
            scriptPubKey[0] = 0x51;  // OP_1 (Taprootç‰ˆæœ¬)
            scriptPubKey[1] = 0x20;  // 32å­—èŠ‚
            System.arraycopy(tweakedKey, 0, scriptPubKey, 2, 32);

            return scriptPubKey;
        }

        // èŠ±è´¹Taprootè¾“å‡º
        public void spendTaproot() {
            System.out.println("\nèŠ±è´¹æ–¹å¼ï¼š\n");

            System.out.println("1. å¯†é’¥è·¯å¾„èŠ±è´¹ï¼ˆKey Pathï¼‰");
            System.out.println("   - ä½¿ç”¨è°ƒæ•´åçš„å¯†é’¥ç­¾å");
            System.out.println("   - æœ€é«˜æ•ˆï¼Œæœ€éšç§");
            System.out.println("   - çœ‹èµ·æ¥åƒæ™®é€šæ”¯ä»˜");

            System.out.println("\n2. è„šæœ¬è·¯å¾„èŠ±è´¹ï¼ˆScript Pathï¼‰");
            System.out.println("   - æä¾›è„šæœ¬å’ŒMerkleè¯æ˜");
            System.out.println("   - ä»…åœ¨å¿…è¦æ—¶ä½¿ç”¨");
            System.out.println("   - ä»…æš´éœ²ä½¿ç”¨çš„è„šæœ¬");
        }

        // æ„å»ºMerkleæ ‘
        private byte[] buildMerkleTree(byte[][] scripts) {
            if (scripts.length == 0) {
                return null;
            }

            // è®¡ç®—æ‰€æœ‰è„šæœ¬çš„å¶å­å“ˆå¸Œ
            List<byte[]> leaves = new ArrayList<>();
            for (byte[] script : scripts) {
                byte[] leafHash = taggedHash("TapLeaf",
                    concat(new byte[]{0xC0}, varInt(script.length), script));
                leaves.add(leafHash);
            }

            // æ„å»ºMerkleæ ‘
            while (leaves.size() > 1) {
                List<byte[]> nextLevel = new ArrayList<>();

                for (int i = 0; i < leaves.size(); i += 2) {
                    if (i + 1 < leaves.size()) {
                        byte[] branch = taggedHash("TapBranch",
                            concat(leaves.get(i), leaves.get(i + 1)));
                        nextLevel.add(branch);
                    } else {
                        nextLevel.add(leaves.get(i));
                    }
                }

                leaves = nextLevel;
            }

            return leaves.get(0);
        }
    }

    // Tapscriptï¼ˆBIP 342ï¼‰
    public class Tapscript {

        public void demonstrateTapscript() {
            System.out.println("\n=== BIP342 Tapscript ===\n");

            System.out.println("å¢å¼ºåŠŸèƒ½ï¼š\n");

            System.out.println("1. ç­¾åæ“ä½œç å‡çº§");
            System.out.println("   - OP_CHECKSIGä½¿ç”¨Schnorr");
            System.out.println("   - OP_CHECKSIGADDæ‰¹é‡éªŒè¯");

            System.out.println("\n2. ç§»é™¤è„šæœ¬é™åˆ¶");
            System.out.println("   - è„šæœ¬å¤§å°é™åˆ¶æ”¾å®½");
            System.out.println("   - æ”¯æŒæ›´å¤æ‚åˆçº¦");

            System.out.println("\n3. æ–°æ“ä½œç ");
            System.out.println("   - OP_SUCCESSä¿ç•™å‡çº§ç©ºé—´");
            System.out.println("   - ä¾¿äºè½¯åˆ†å‰å‡çº§");
        }

        // ç¤ºä¾‹ï¼šå¤šç­¾Taproot
        public void multisigTaproot() {
            System.out.println("\n=== Taprootå¤šç­¾ç¤ºä¾‹ ===\n");

            // å¯†é’¥è·¯å¾„ï¼š3-of-3èšåˆå¯†é’¥
            byte[] aggregatedKey = aggregateKeys(key1, key2, key3);

            // è„šæœ¬è·¯å¾„ï¼šé™çº§åœºæ™¯
            byte[][] scripts = {
                create2of3Script(key1, key2, key3),  // 2-of-3
                createTimelockScript(key1, 90)       // 90å¤©åkey1å•ç­¾
            };

            byte[] taprootOutput = createTaprootOutput(aggregatedKey, scripts);

            System.out.println("æ­£å¸¸æƒ…å†µï¼š3ä¸ªç­¾åèšåˆï¼Œå¯†é’¥è·¯å¾„èŠ±è´¹");
            System.out.println("é™çº§1ï¼š2-of-3è„šæœ¬è·¯å¾„èŠ±è´¹");
            System.out.println("é™çº§2ï¼š90å¤©åkey1å•ç­¾");
            System.out.println("\néšç§ï¼šå¤–éƒ¨æ— æ³•åŒºåˆ†åœºæ™¯");
        }
    }
}
```

### å…¶ä»–é‡è¦BIP

```java
public class OtherImportantBIPs {

    // BIP 9: ç‰ˆæœ¬ä½è½¯åˆ†å‰éƒ¨ç½²
    public void bip9() {
        System.out.println("=== BIP9: ç‰ˆæœ¬ä½è½¯åˆ†å‰ ===\n");

        System.out.println("ç‰¹ç‚¹ï¼š");
        System.out.println("- ä½¿ç”¨åŒºå—ç‰ˆæœ¬ä½ä¿¡å·");
        System.out.println("- çŸ¿å·¥æŠ•ç¥¨æ¿€æ´»");
        System.out.println("- å¤šä¸ªææ¡ˆå¹¶è¡Œ");
        System.out.println("- 95%é˜ˆå€¼æ¿€æ´»");
    }

    // BIP 125: RBF
    public void bip125() {
        System.out.println("\n=== BIP125: è´¹ç”¨æ›¿æ¢ ===\n");

        System.out.println("è§„åˆ™ï¼š");
        System.out.println("1. ä¿¡å·ï¼šnSequence < 0xfffffffe");
        System.out.println("2. æ–°è´¹ç”¨å¿…é¡»æ›´é«˜");
        System.out.println("3. ä¸èƒ½ç§»é™¤ç°æœ‰è¾“å‡º");
        System.out.println("4. æ–°äº¤æ˜“å¤§å°åˆç†");
    }

    // BIP 152: è‡´å¯†åŒºå—ä¸­ç»§
    public void bip152() {
        System.out.println("\n=== BIP152: è‡´å¯†åŒºå— ===\n");

        System.out.println("ä¼˜åŒ–ï¼š");
        System.out.println("- ä»…ä¼ è¾“äº¤æ˜“IDçŸ­å“ˆå¸Œ");
        System.out.println("- èŠ‚ç‚¹æœ¬åœ°é‡å»ºåŒºå—");
        System.out.println("- å‡å°‘å¸¦å®½90%+");
        System.out.println("- åŠ å¿«åŒºå—ä¼ æ’­");
    }

    // BIP 174: PSBT
    public void bip174() {
        System.out.println("\n=== BIP174: éƒ¨åˆ†ç­¾åäº¤æ˜“ ===\n");

        System.out.println("ç”¨é€”ï¼š");
        System.out.println("- å¤šæ–¹åä½œæ„å»ºäº¤æ˜“");
        System.out.println("- ç¡¬ä»¶é’±åŒ…é›†æˆ");
        System.out.println("- ç¦»çº¿ç­¾å");
        System.out.println("- æ ‡å‡†åŒ–æ ¼å¼");
    }
}
```

## BIPæ—¶é—´çº¿

```mermaid
timeline
    title æ¯”ç‰¹å¸é‡è¦BIPæ—¶é—´çº¿
    2012 : BIP 16 P2SH
         : BIP 32 HDé’±åŒ…
    2013 : BIP 39 åŠ©è®°è¯
    2015 : BIP 65 CHECKLOCKTIMEVERIFY
         : BIP 66 ä¸¥æ ¼DERç­¾å
    2016 : BIP 9 ç‰ˆæœ¬ä½éƒ¨ç½²
         : BIP 68/112/113 ç›¸å¯¹æ—¶é—´é”
    2017 : BIP 141 éš”ç¦»è§è¯æ¿€æ´»
         : BIP 173 Bech32åœ°å€
    2021 : BIP 340-342 Taprootæ¿€æ´»
```

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

âœ… **BIPæµç¨‹**
- è‰æ¡ˆ â†’ æè®® â†’ æœ€ç»ˆ â†’ æ¿€æ´»
- ç¤¾åŒºé©±åŠ¨çš„æ”¹è¿›æœºåˆ¶
- å‘åå…¼å®¹ä¼˜å…ˆ

âœ… **å…³é”®BIP**
- BIP 32/39: HDé’±åŒ…å’ŒåŠ©è®°è¯
- BIP 141: éš”ç¦»è§è¯
- BIP 340-342: Taproot
- BIP 125: RBF

âœ… **æŠ€æœ¯æ¼”è¿›**
- æ‰©å®¹ï¼šSegWit, Compact Blocks
- éšç§ï¼šTaproot, Schnorr
- å¯ç”¨æ€§ï¼šHDé’±åŒ…, Bech32
- å®‰å…¨æ€§ï¼šæ—¶é—´é”, å¤šç­¾

---

**ç›¸å…³æ–‡æ¡£ï¼š**
- [æ¯”ç‰¹å¸é’±åŒ…æŠ€æœ¯å®ç°](./07.æ¯”ç‰¹å¸é’±åŒ…æŠ€æœ¯å®ç°.md)
- [æ¯”ç‰¹å¸éšç§æŠ€æœ¯](./19.æ¯”ç‰¹å¸éšç§æŠ€æœ¯.md)
- [æ¯”ç‰¹å¸æ‰©å±•æ–¹æ¡ˆ](./20.æ¯”ç‰¹å¸æ‰©å±•æ–¹æ¡ˆ.md)

BIPæ˜¯æ¯”ç‰¹å¸æŒç»­æ¼”è¿›çš„åŸºç¡€ï¼Œäº†è§£é‡è¦BIPæœ‰åŠ©äºæ·±å…¥ç†è§£æ¯”ç‰¹å¸ï¼ğŸ“œ