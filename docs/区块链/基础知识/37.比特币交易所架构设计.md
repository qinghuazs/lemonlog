---
title: æ¯”ç‰¹å¸äº¤æ˜“æ‰€æ¶æ„è®¾è®¡
date: 2025-09-30
permalink: /blockchain/bitcoin-exchange-architecture.html
tags:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸
  - äº¤æ˜“æ‰€
  - æ¶æ„è®¾è®¡
categories:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸åŸºç¡€
---

# æ¯”ç‰¹å¸äº¤æ˜“æ‰€æ¶æ„è®¾è®¡

## 1. äº¤æ˜“æ‰€æ¶æ„æ¦‚è§ˆ

```mermaid
graph TB
    A[ç”¨æˆ·å±‚] --> B[APIç½‘å…³]
    B --> C[äº¤æ˜“å¼•æ“]
    B --> D[è´¦æˆ·ç³»ç»Ÿ]
    B --> E[é’±åŒ…æœåŠ¡]
    
    C --> F[æ’®åˆå¼•æ“]
    C --> G[è®¢å•ç°¿]
    
    D --> H[ç”¨æˆ·è´¦æˆ·]
    D --> I[èµ„äº§è´¦æˆ·]
    
    E --> J[çƒ­é’±åŒ…]
    E --> K[æ¸©é’±åŒ…]
    E --> L[å†·é’±åŒ…]
    
    M[åŒºå—é“¾èŠ‚ç‚¹] --> E
    N[é£æ§ç³»ç»Ÿ] --> C
    O[æ¸…ç®—ç³»ç»Ÿ] --> D
```

## 2. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 2.1 è´¦æˆ·ç³»ç»Ÿ

```java
public class AccountSystem {
    
    /**
     * ç”¨æˆ·è´¦æˆ·
     */
    public static class UserAccount {
        private String userId;
        private Map<String, Balance> balances; // å¸ç§ -> ä½™é¢
        private KYCLevel kycLevel;
        
        public static class Balance {
            private double available;  // å¯ç”¨ä½™é¢
            private double frozen;     // å†»ç»“ä½™é¢
            private double total;      // æ€»ä½™é¢ = available + frozen
            
            public synchronized boolean freeze(double amount) {
                if (available >= amount) {
                    available -= amount;
                    frozen += amount;
                    return true;
                }
                return false;
            }
            
            public synchronized void unfreeze(double amount) {
                frozen -= amount;
                available += amount;
            }
        }
    }
    
    /**
     * èµ„äº§æµæ°´è®°å½•
     */
    public static class AssetLog {
        private String logId;
        private String userId;
        private String asset;
        private double amount;
        private LogType type;
        private long timestamp;
        
        public enum LogType {
            DEPOSIT,      // å……å€¼
            WITHDRAWAL,   // æç°
            TRADE_BUY,    // ä¹°å…¥
            TRADE_SELL,   // å–å‡º
            FEE,          // æ‰‹ç»­è´¹
            TRANSFER      // è½¬è´¦
        }
    }
}
```

### 2.2 æ’®åˆå¼•æ“

```java
public class MatchingEngine {
    
    private TreeMap<Double, List<Order>> buyOrders;  // ä¹°å•(ä»·æ ¼é™åº)
    private TreeMap<Double, List<Order>> sellOrders; // å–å•(ä»·æ ¼å‡åº)
    
    /**
     * æäº¤è®¢å•
     */
    public synchronized List<Trade> submitOrder(Order order) {
        List<Trade> trades = new ArrayList<>();
        
        if (order.side == OrderSide.BUY) {
            // åŒ¹é…å–å•
            while (order.remainingQty > 0 && !sellOrders.isEmpty()) {
                double bestSellPrice = sellOrders.firstKey();
                
                if (order.price >= bestSellPrice) {
                    Trade trade = matchOrders(order, sellOrders.get(bestSellPrice));
                    if (trade != null) {
                        trades.add(trade);
                    }
                } else {
                    break;
                }
            }
            
            // æœªå®Œå…¨æˆäº¤,åŠ å…¥è®¢å•ç°¿
            if (order.remainingQty > 0) {
                addToBuyBook(order);
            }
        } else {
            // åŒ¹é…ä¹°å•
            while (order.remainingQty > 0 && !buyOrders.isEmpty()) {
                double bestBuyPrice = buyOrders.lastKey();
                
                if (order.price <= bestBuyPrice) {
                    Trade trade = matchOrders(order, buyOrders.get(bestBuyPrice));
                    if (trade != null) {
                        trades.add(trade);
                    }
                } else {
                    break;
                }
            }
            
            if (order.remainingQty > 0) {
                addToSellBook(order);
            }
        }
        
        return trades;
    }
    
    private Trade matchOrders(Order taker, List<Order> makers) {
        Order maker = makers.get(0);
        
        double tradeQty = Math.min(taker.remainingQty, maker.remainingQty);
        double tradePrice = maker.price; // ä½¿ç”¨æŒ‚å•ä»·æ ¼
        
        Trade trade = new Trade();
        trade.price = tradePrice;
        trade.quantity = tradeQty;
        trade.buyOrderId = taker.side == OrderSide.BUY ? 
            taker.orderId : maker.orderId;
        trade.sellOrderId = taker.side == OrderSide.SELL ? 
            taker.orderId : maker.orderId;
        trade.timestamp = System.currentTimeMillis();
        
        taker.remainingQty -= tradeQty;
        maker.remainingQty -= tradeQty;
        
        if (maker.remainingQty == 0) {
            makers.remove(0);
        }
        
        System.out.printf("æˆäº¤: ä»·æ ¼%.2f æ•°é‡%.4f%n", tradePrice, tradeQty);
        
        return trade;
    }
    
    private void addToBuyBook(Order order) {
        buyOrders.computeIfAbsent(order.price, k -> new ArrayList<>()).add(order);
    }
    
    private void addToSellBook(Order order) {
        sellOrders.computeIfAbsent(order.price, k -> new ArrayList<>()).add(order);
    }
    
    public static class Order {
        String orderId;
        String userId;
        OrderSide side;
        double price;
        double quantity;
        double remainingQty;
    }
    
    public enum OrderSide { BUY, SELL }
    
    public static class Trade {
        String buyOrderId;
        String sellOrderId;
        double price;
        double quantity;
        long timestamp;
    }
}
```

### 2.3 é’±åŒ…æ¶æ„

```java
public class WalletArchitecture {
    
    /**
     * ä¸‰å±‚é’±åŒ…æ¶æ„
     */
    public interface WalletTier {
        String getName();
        double getBalanceLimit();
        SecurityLevel getSecurityLevel();
    }
    
    /**
     * çƒ­é’±åŒ… - åœ¨çº¿è‡ªåŠ¨å¤„ç†
     */
    public static class HotWallet implements WalletTier {
        private String address;
        private double balance;
        private static final double LIMIT = 100; // 100 BTCä¸Šé™
        
        public String getName() { return "çƒ­é’±åŒ…"; }
        public double getBalanceLimit() { return LIMIT; }
        public SecurityLevel getSecurityLevel() { return SecurityLevel.LOW; }
        
        /**
         * è‡ªåŠ¨å¤„ç†æç°
         */
        public synchronized Transaction processWithdrawal(
                String recipient, double amount) {
            
            if (balance < amount) {
                throw new RuntimeException("çƒ­é’±åŒ…ä½™é¢ä¸è¶³");
            }
            
            Transaction tx = new Transaction();
            tx.to = recipient;
            tx.amount = amount;
            tx.from = address;
            
            // è‡ªåŠ¨ç­¾åå¹¶å¹¿æ’­
            signAndBroadcast(tx);
            
            balance -= amount;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦è¡¥å……
            if (balance < LIMIT * 0.3) {
                requestRefillFromWarm();
            }
            
            return tx;
        }
        
        private void signAndBroadcast(Transaction tx) {
            System.out.println("çƒ­é’±åŒ…è‡ªåŠ¨å¤„ç†æç°: " + tx.amount + " BTC");
        }
        
        private void requestRefillFromWarm() {
            System.out.println("çƒ­é’±åŒ…ä½™é¢ä½,è¯·æ±‚ä»æ¸©é’±åŒ…è¡¥å……");
        }
    }
    
    /**
     * æ¸©é’±åŒ… - åŠè‡ªåŠ¨,å®šæœŸè¡¥å……çƒ­é’±åŒ…
     */
    public static class WarmWallet implements WalletTier {
        private String address;
        private double balance;
        private static final double LIMIT = 1000; // 1000 BTCä¸Šé™
        
        public String getName() { return "æ¸©é’±åŒ…"; }
        public double getBalanceLimit() { return LIMIT; }
        public SecurityLevel getSecurityLevel() { return SecurityLevel.MEDIUM; }
        
        /**
         * è¡¥å……çƒ­é’±åŒ…(éœ€è¦äººå·¥å®¡æ‰¹)
         */
        public Transaction refillHotWallet(
                String hotWalletAddress, 
                double amount,
                String approver) {
            
            System.out.println("æ¸©é’±åŒ…è¡¥å……çƒ­é’±åŒ…:");
            System.out.println("  æ•°é‡: " + amount + " BTC");
            System.out.println("  å®¡æ‰¹äºº: " + approver);
            
            Transaction tx = new Transaction();
            tx.to = hotWalletAddress;
            tx.amount = amount;
            tx.from = address;
            tx.requiresApproval = true;
            
            balance -= amount;
            
            return tx;
        }
    }
    
    /**
     * å†·é’±åŒ… - ç¦»çº¿å¤šç­¾
     */
    public static class ColdWallet implements WalletTier {
        private String multiSigAddress; // 3-of-5å¤šç­¾
        private double balance;
        
        public String getName() { return "å†·é’±åŒ…"; }
        public double getBalanceLimit() { return Double.MAX_VALUE; }
        public SecurityLevel getSecurityLevel() { return SecurityLevel.HIGH; }
        
        /**
         * è¡¥å……æ¸©é’±åŒ…(éœ€è¦å¤šç­¾+ç‰©ç†éš”ç¦»)
         */
        public Transaction refillWarmWallet(
                String warmWalletAddress,
                double amount,
                List<String> signers) {
            
            if (signers.size() < 3) {
                throw new RuntimeException("è‡³å°‘éœ€è¦3ä¸ªç­¾å");
            }
            
            System.out.println("å†·é’±åŒ…è½¬è´¦(å¤šç­¾):");
            System.out.println("  æ•°é‡: " + amount + " BTC");
            System.out.println("  ç­¾åè€…: " + String.join(", ", signers));
            
            Transaction tx = new Transaction();
            tx.to = warmWalletAddress;
            tx.amount = amount;
            tx.from = multiSigAddress;
            tx.requiresMultiSig = true;
            tx.signers = signers;
            
            balance -= amount;
            
            return tx;
        }
    }
    
    public enum SecurityLevel {
        LOW, MEDIUM, HIGH
    }
    
    public static class Transaction {
        String from;
        String to;
        double amount;
        boolean requiresApproval;
        boolean requiresMultiSig;
        List<String> signers;
    }
}
```

## 3. å……å€¼æç°æµç¨‹

### 3.1 å……å€¼ç›‘æ§

```java
public class DepositMonitor {
    
    private Map<String, String> addressToUser = new HashMap<>();
    
    /**
     * ä¸ºç”¨æˆ·åˆ†é…å……å€¼åœ°å€
     */
    public String assignDepositAddress(String userId) {
        String address = generateAddress();
        addressToUser.put(address, userId);
        
        System.out.println("ä¸ºç”¨æˆ· " + userId + " åˆ†é…åœ°å€: " + address);
        return address;
    }
    
    /**
     * ç›‘æ§åŒºå—é“¾äº¤æ˜“
     */
    public void monitorBlockchain() {
        // è®¢é˜…æ–°åŒºå—
        while (true) {
            Block newBlock = waitForNewBlock();
            
            for (Transaction tx : newBlock.transactions) {
                for (TxOutput output : tx.outputs) {
                    String address = output.address;
                    
                    if (addressToUser.containsKey(address)) {
                        String userId = addressToUser.get(address);
                        double amount = output.amount / 100_000_000.0;
                        
                        // ç­‰å¾…ç¡®è®¤
                        if (tx.confirmations >= 6) {
                            processDeposit(userId, amount, tx.txid);
                        }
                    }
                }
            }
        }
    }
    
    private void processDeposit(String userId, double amount, String txid) {
        System.out.println("æ£€æµ‹åˆ°å……å€¼:");
        System.out.println("  ç”¨æˆ·: " + userId);
        System.out.println("  æ•°é‡: " + amount + " BTC");
        System.out.println("  äº¤æ˜“: " + txid);
        
        // æ›´æ–°ç”¨æˆ·ä½™é¢
        creditUserAccount(userId, amount);
        
        // è½¬ç§»åˆ°çƒ­é’±åŒ…
        if (amount > 1.0) {
            transferToHotWallet(amount);
        }
    }
    
    private String generateAddress() {
        return "bc1q" + java.util.UUID.randomUUID().toString().substring(0, 38);
    }
    
    private Block waitForNewBlock() {
        return new Block(); // ç®€åŒ–
    }
    
    private void creditUserAccount(String userId, double amount) {}
    private void transferToHotWallet(double amount) {}
    
    static class Block {
        List<Transaction> transactions = new ArrayList<>();
    }
    
    static class Transaction {
        String txid;
        int confirmations;
        List<TxOutput> outputs = new ArrayList<>();
    }
    
    static class TxOutput {
        String address;
        long amount;
    }
}
```

### 3.2 æç°å¤„ç†

```java
public class WithdrawalProcessor {
    
    /**
     * æç°å®¡æ ¸
     */
    public WithdrawalStatus processWithdrawal(WithdrawalRequest request) {
        System.out.println("å¤„ç†æç°è¯·æ±‚:");
        System.out.println("  ç”¨æˆ·: " + request.userId);
        System.out.println("  æ•°é‡: " + request.amount + " BTC");
        System.out.println("  åœ°å€: " + request.toAddress);
        
        // 1. é£æ§æ£€æŸ¥
        RiskCheckResult risk = performRiskCheck(request);
        if (!risk.passed) {
            return WithdrawalStatus.REJECTED;
        }
        
        // 2. å†»ç»“ç”¨æˆ·ä½™é¢
        boolean frozen = freezeUserBalance(request.userId, request.amount);
        if (!frozen) {
            return WithdrawalStatus.INSUFFICIENT_BALANCE;
        }
        
        // 3. æ ¹æ®é‡‘é¢é€‰æ‹©é’±åŒ…
        if (request.amount < 1.0) {
            // å°é¢: çƒ­é’±åŒ…è‡ªåŠ¨å¤„ç†
            processFromHotWallet(request);
            return WithdrawalStatus.PROCESSING;
        } else if (request.amount < 10.0) {
            // ä¸­é¢: æ¸©é’±åŒ…,éœ€è¦å®¡æ‰¹
            return WithdrawalStatus.PENDING_APPROVAL;
        } else {
            // å¤§é¢: å†·é’±åŒ…,éœ€è¦å¤šç­¾
            return WithdrawalStatus.PENDING_MULTISIG;
        }
    }
    
    private RiskCheckResult performRiskCheck(WithdrawalRequest req) {
        RiskCheckResult result = new RiskCheckResult();
        
        // æ£€æŸ¥åœ°å€é£é™©
        if (isHighRiskAddress(req.toAddress)) {
            result.passed = false;
            result.reason = "ç›®æ ‡åœ°å€é£é™©è¾ƒé«˜";
            return result;
        }
        
        // æ£€æŸ¥å¼‚å¸¸è¡Œä¸º
        if (hasAbnormalBehavior(req.userId)) {
            result.passed = false;
            result.reason = "æ£€æµ‹åˆ°å¼‚å¸¸è¡Œä¸º";
            return result;
        }
        
        result.passed = true;
        return result;
    }
    
    private void processFromHotWallet(WithdrawalRequest req) {
        System.out.println("ä»çƒ­é’±åŒ…è‡ªåŠ¨å¤„ç†æç°");
    }
    
    private boolean isHighRiskAddress(String address) { return false; }
    private boolean hasAbnormalBehavior(String userId) { return false; }
    private boolean freezeUserBalance(String userId, double amount) { return true; }
    
    public static class WithdrawalRequest {
        String requestId;
        String userId;
        String toAddress;
        double amount;
    }
    
    public enum WithdrawalStatus {
        PROCESSING, PENDING_APPROVAL, PENDING_MULTISIG, 
        COMPLETED, REJECTED, INSUFFICIENT_BALANCE
    }
    
    static class RiskCheckResult {
        boolean passed;
        String reason;
    }
}
```

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 è®¢å•ç°¿ä¼˜åŒ–

- **å†…å­˜æ•°æ®ç»“æ„**: ä½¿ç”¨TreeMapå­˜å‚¨è®¢å•ç°¿
- **ç¼“å­˜å±‚**: Redisç¼“å­˜æœ€æ–°ä»·æ ¼å’Œæ·±åº¦
- **å¼‚æ­¥å¤„ç†**: æ’®åˆå¼•æ“ä½¿ç”¨äº‹ä»¶é©±åŠ¨
- **åˆ†ç‰‡**: ä¸åŒäº¤æ˜“å¯¹ä½¿ç”¨ç‹¬ç«‹æ’®åˆå¼•æ“

### 4.2 æ•°æ®åº“è®¾è®¡

```sql
-- ç”¨æˆ·è´¦æˆ·è¡¨
CREATE TABLE user_accounts (
    user_id VARCHAR(64) PRIMARY KEY,
    created_at TIMESTAMP,
    kyc_level INT
);

-- èµ„äº§ä½™é¢è¡¨
CREATE TABLE balances (
    user_id VARCHAR(64),
    asset VARCHAR(16),
    available DECIMAL(20,8),
    frozen DECIMAL(20,8),
    PRIMARY KEY (user_id, asset),
    INDEX idx_user (user_id)
);

-- è®¢å•è¡¨
CREATE TABLE orders (
    order_id VARCHAR(64) PRIMARY KEY,
    user_id VARCHAR(64),
    pair VARCHAR(16),
    side ENUM('BUY', 'SELL'),
    price DECIMAL(20,8),
    quantity DECIMAL(20,8),
    filled_qty DECIMAL(20,8),
    status ENUM('PENDING', 'PARTIAL', 'FILLED', 'CANCELLED'),
    created_at TIMESTAMP,
    INDEX idx_user_time (user_id, created_at)
);

-- æˆäº¤è®°å½•è¡¨
CREATE TABLE trades (
    trade_id VARCHAR(64) PRIMARY KEY,
    buy_order_id VARCHAR(64),
    sell_order_id VARCHAR(64),
    price DECIMAL(20,8),
    quantity DECIMAL(20,8),
    fee DECIMAL(20,8),
    timestamp TIMESTAMP,
    INDEX idx_time (timestamp)
);
```

## 5. å®‰å…¨æªæ–½

### 5.1 å®‰å…¨æ¸…å•

```
âœ… å†·çƒ­é’±åŒ…åˆ†ç¦»
âœ… å¤šé‡ç­¾å
âœ… æç°ç™½åå•
âœ… IPç™½åå•
âœ… 2FAåŒé‡è®¤è¯
âœ… æç°å»¶è¿Ÿæœºåˆ¶
âœ… å¼‚å¸¸ç›‘æ§å‘Šè­¦
âœ… å®šæœŸå®‰å…¨å®¡è®¡
âœ… æ•°æ®åº“åŠ å¯†
âœ… APIé™æµ
```

### 5.2 ç¾å¤‡æ–¹æ¡ˆ

- ğŸ”„ **æ•°æ®åº“ä¸»ä»å¤åˆ¶**: å®æ—¶åŒæ­¥
- ğŸ’¾ **å®šæœŸå¤‡ä»½**: æ¯æ—¥å…¨é‡+å¢é‡
- ğŸŒ **å¤šåœ°åŸŸéƒ¨ç½²**: å®¹ç¾åˆ‡æ¢
- ğŸ“Š **ç›‘æ§å‘Šè­¦**: 7x24å°æ—¶ç›‘æ§

## 6. ç›¸å…³æ–‡æ¡£

- [26.æ¯”ç‰¹å¸æ”¯ä»˜é›†æˆå®æˆ˜](./26.æ¯”ç‰¹å¸æ”¯ä»˜é›†æˆå®æˆ˜.md)
- [27.æ¯”ç‰¹å¸å¤šç­¾é’±åŒ…å¼€å‘](./27.æ¯”ç‰¹å¸å¤šç­¾é’±åŒ…å¼€å‘.md)
- [34.æ¯”ç‰¹å¸ç›‘ç®¡åˆè§„å®è·µ](./34.æ¯”ç‰¹å¸ç›‘ç®¡åˆè§„å®è·µ.md)

## 7. å‚è€ƒèµ„æ–™

- [äº¤æ˜“æ‰€æ¶æ„æœ€ä½³å®è·µ](https://github.com/topics/cryptocurrency-exchange)
- [Binanceæ¶æ„è§£æ](https://www.binance.com/en/blog)
