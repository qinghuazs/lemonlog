---
title: æ¯”ç‰¹å¸Taprootå‡çº§è¯¦è§£
date: 2025-09-30
permalink: /blockchain/bitcoin-taproot.html
tags:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸
  - Taproot
  - Schnorrç­¾å
categories:
  - åŒºå—é“¾
  - æ¯”ç‰¹å¸åŸºç¡€
---

# æ¯”ç‰¹å¸Taprootå‡çº§è¯¦è§£

## 1. Taprootå‡çº§æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯Taproot

Taprootæ˜¯æ¯”ç‰¹å¸åœ¨2021å¹´11æœˆæ¿€æ´»çš„é‡å¤§å‡çº§,é€šè¿‡BIP340ã€BIP341ã€BIP342ä¸‰ä¸ªææ¡ˆå®ç°:
- **BIP340**: Schnorrç­¾åæ ‡å‡†
- **BIP341**: Taprootè¾“å‡ºå’Œè„šæœ¬æ ‘
- **BIP342**: Tapscriptè„šæœ¬è¯­è¨€

### 1.2 Taprootçš„ä¸‰å¤§æ ¸å¿ƒç‰¹æ€§

```mermaid
graph TB
    A[Taprootå‡çº§] --> B[Schnorrç­¾å]
    A --> C[MASTæ ‘ç»“æ„]
    A --> D[Tapscript]

    B --> B1[ç­¾åèšåˆ]
    B --> B2[æ›´å°ä½“ç§¯]
    B --> B3[æ‰¹é‡éªŒè¯]

    C --> C1[éšç§æ”¹è¿›]
    C --> C2[è„šæœ¬ä¼˜åŒ–]
    C --> C3[çµæ´»æ€§å¢å¼º]

    D --> D1[ç®€åŒ–è„šæœ¬]
    D --> D2[æ–°æ“ä½œç ]
    D --> D3[å‘åå…¼å®¹]
```

### 1.3 Taprootçš„ä¼˜åŠ¿

| ç‰¹æ€§ | å‡çº§å‰ | Taprootå |
|-----|-------|-----------|
| ç­¾åç®—æ³• | ECDSA | Schnorr |
| å¤šç­¾éšç§ | å¯è¯†åˆ« | ä¸å¯åŒºåˆ† |
| ç­¾åå¤§å° | 71-73å­—èŠ‚ | 64å­—èŠ‚å›ºå®š |
| å¤æ‚è„šæœ¬ | å…¨éƒ¨æš´éœ² | ä»…æš´éœ²æ‰§è¡Œè·¯å¾„ |
| æ‰¹é‡éªŒè¯ | ä¸æ”¯æŒ | æ”¯æŒ |

## 2. Schnorrç­¾åè¯¦è§£

### 2.1 Schnorr vs ECDSA

**ECDSAçš„å±€é™æ€§**:
- ç­¾åä¸å¯çº¿æ€§ç»„åˆ
- ç­¾åå¤§å°ä¸å›ºå®š(71-73å­—èŠ‚)
- æ— æ³•æ‰¹é‡éªŒè¯
- å¤šç­¾åœºæ™¯å¤æ‚

**Schnorrçš„ä¼˜åŠ¿**:
- å¯è¯æ˜å®‰å…¨æ€§(åœ¨ç¦»æ•£å¯¹æ•°å›°éš¾æ€§å‡è®¾ä¸‹)
- ç­¾åèšåˆ: å¤šä¸ªç­¾åå¯åˆå¹¶ä¸ºä¸€ä¸ª
- å›ºå®š64å­—èŠ‚ç­¾å
- æ”¯æŒæ‰¹é‡éªŒè¯

### 2.2 Schnorrç­¾åJavaå®ç°

```java
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.SecureRandom;

/**
 * Schnorrç­¾åå®ç°
 */
public class SchnorrSignature {

    // secp256k1æ›²çº¿å‚æ•°
    private static final BigInteger P = new BigInteger(
        "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16);
    private static final BigInteger N = new BigInteger(
        "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
    private static final BigInteger G_X = new BigInteger(
        "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", 16);
    private static final BigInteger G_Y = new BigInteger(
        "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", 16);

    private BigInteger privateKey;
    private ECPoint publicKey;

    /**
     * ç”Ÿæˆå¯†é’¥å¯¹
     */
    public static class KeyPair {
        public BigInteger privateKey;
        public ECPoint publicKey;

        public KeyPair(BigInteger privKey) {
            this.privateKey = privKey;
            this.publicKey = ECPoint.multiply(ECPoint.G, privKey);
        }
    }

    /**
     * ECç‚¹è¡¨ç¤º
     */
    public static class ECPoint {
        public static final ECPoint G = new ECPoint(G_X, G_Y);
        public BigInteger x;
        public BigInteger y;

        public ECPoint(BigInteger x, BigInteger y) {
            this.x = x;
            this.y = y;
        }

        /**
         * ç‚¹ä¹˜è¿ç®—
         */
        public static ECPoint multiply(ECPoint point, BigInteger scalar) {
            // ç®€åŒ–å®ç°,å®é™…éœ€è¦ä½¿ç”¨double-and-addç®—æ³•
            ECPoint result = null;
            ECPoint temp = point;

            while (scalar.compareTo(BigInteger.ZERO) > 0) {
                if (scalar.testBit(0)) {
                    result = (result == null) ? temp : add(result, temp);
                }
                temp = add(temp, temp);
                scalar = scalar.shiftRight(1);
            }
            return result;
        }

        /**
         * ç‚¹åŠ è¿ç®—
         */
        public static ECPoint add(ECPoint p1, ECPoint p2) {
            // ç®€åŒ–å®ç°
            if (p1 == null) return p2;
            if (p2 == null) return p1;

            BigInteger lambda;
            if (p1.x.equals(p2.x)) {
                if (p1.y.equals(p2.y)) {
                    // ç‚¹åŠ å€
                    lambda = p1.x.pow(2).multiply(BigInteger.valueOf(3))
                        .multiply(p1.y.multiply(BigInteger.TWO).modInverse(P)).mod(P);
                } else {
                    return null; // æ— ç©·è¿œç‚¹
                }
            } else {
                // ç‚¹åŠ æ³•
                lambda = p2.y.subtract(p1.y)
                    .multiply(p2.x.subtract(p1.x).modInverse(P)).mod(P);
            }

            BigInteger x3 = lambda.pow(2).subtract(p1.x).subtract(p2.x).mod(P);
            BigInteger y3 = lambda.multiply(p1.x.subtract(x3)).subtract(p1.y).mod(P);

            return new ECPoint(x3, y3);
        }

        /**
         * åºåˆ—åŒ–å…¬é’¥(32å­—èŠ‚xåæ ‡)
         */
        public byte[] serialize() {
            byte[] xBytes = x.toByteArray();
            byte[] result = new byte[32];

            int startPos = Math.max(0, xBytes.length - 32);
            int destPos = Math.max(0, 32 - xBytes.length);
            System.arraycopy(xBytes, startPos, result, destPos,
                Math.min(32, xBytes.length));

            return result;
        }
    }

    /**
     * Schnorrç­¾å
     */
    public static class Signature {
        public BigInteger r; // 32å­—èŠ‚
        public BigInteger s; // 32å­—èŠ‚

        public Signature(BigInteger r, BigInteger s) {
            this.r = r;
            this.s = s;
        }

        /**
         * åºåˆ—åŒ–ä¸º64å­—èŠ‚
         */
        public byte[] serialize() {
            byte[] result = new byte[64];
            byte[] rBytes = r.toByteArray();
            byte[] sBytes = s.toByteArray();

            // Rå€¼(å‰32å­—èŠ‚)
            int rStart = Math.max(0, rBytes.length - 32);
            int rDest = Math.max(0, 32 - rBytes.length);
            System.arraycopy(rBytes, rStart, result, rDest,
                Math.min(32, rBytes.length));

            // Så€¼(å32å­—èŠ‚)
            int sStart = Math.max(0, sBytes.length - 32);
            int sDest = 32 + Math.max(0, 32 - sBytes.length);
            System.arraycopy(sBytes, sStart, result, sDest,
                Math.min(32, sBytes.length));

            return result;
        }
    }

    /**
     * ç”Ÿæˆç­¾å
     */
    public static Signature sign(BigInteger privateKey, byte[] message)
            throws Exception {
        SecureRandom random = new SecureRandom();

        // 1. ç”Ÿæˆéšæœºæ•°k
        BigInteger k = new BigInteger(256, random).mod(N);
        if (k.equals(BigInteger.ZERO)) {
            k = BigInteger.ONE;
        }

        // 2. è®¡ç®—R = k*G
        ECPoint R = ECPoint.multiply(ECPoint.G, k);
        BigInteger r = R.x.mod(N);

        // 3. è®¡ç®—æŒ‘æˆ˜å€¼ e = H(r || P || m)
        ECPoint P = ECPoint.multiply(ECPoint.G, privateKey);
        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
        sha256.update(R.serialize());
        sha256.update(P.serialize());
        sha256.update(message);
        byte[] eBytes = sha256.digest();
        BigInteger e = new BigInteger(1, eBytes).mod(N);

        // 4. è®¡ç®— s = k + e*d (mod n)
        BigInteger s = k.add(e.multiply(privateKey)).mod(N);

        return new Signature(r, s);
    }

    /**
     * éªŒè¯ç­¾å
     */
    public static boolean verify(ECPoint publicKey, byte[] message,
            Signature signature) throws Exception {
        // 1. è®¡ç®—æŒ‘æˆ˜å€¼ e = H(r || P || m)
        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
        byte[] rBytes = signature.r.toByteArray();
        byte[] r32 = new byte[32];
        System.arraycopy(rBytes, Math.max(0, rBytes.length - 32), r32,
            Math.max(0, 32 - rBytes.length), Math.min(32, rBytes.length));

        sha256.update(r32);
        sha256.update(publicKey.serialize());
        sha256.update(message);
        byte[] eBytes = sha256.digest();
        BigInteger e = new BigInteger(1, eBytes).mod(N);

        // 2. è®¡ç®— R' = s*G - e*P
        ECPoint sG = ECPoint.multiply(ECPoint.G, signature.s);
        ECPoint eP = ECPoint.multiply(publicKey, e);
        ECPoint negEP = new ECPoint(eP.x, P.subtract(eP.y).mod(P));
        ECPoint RPrime = ECPoint.add(sG, negEP);

        // 3. éªŒè¯ R'.x == r
        return RPrime != null && RPrime.x.mod(N).equals(signature.r);
    }

    /**
     * ä½¿ç”¨ç¤ºä¾‹
     */
    public static void main(String[] args) throws Exception {
        System.out.println("=== Schnorrç­¾åç¤ºä¾‹ ===\n");

        // ç”Ÿæˆå¯†é’¥å¯¹
        SecureRandom random = new SecureRandom();
        BigInteger privateKey = new BigInteger(256, random).mod(N);
        KeyPair keyPair = new KeyPair(privateKey);

        System.out.println("ç§é’¥: " + privateKey.toString(16));
        System.out.println("å…¬é’¥X: " + keyPair.publicKey.x.toString(16));
        System.out.println();

        // ç­¾åæ¶ˆæ¯
        String messageStr = "Hello Taproot!";
        byte[] message = messageStr.getBytes();

        Signature signature = sign(privateKey, message);
        System.out.println("æ¶ˆæ¯: " + messageStr);
        System.out.println("ç­¾åR: " + signature.r.toString(16));
        System.out.println("ç­¾åS: " + signature.s.toString(16));
        System.out.println("ç­¾åå¤§å°: " + signature.serialize().length + " å­—èŠ‚");
        System.out.println();

        // éªŒè¯ç­¾å
        boolean valid = verify(keyPair.publicKey, message, signature);
        System.out.println("ç­¾åéªŒè¯: " + (valid ? "âœ“ æœ‰æ•ˆ" : "âœ— æ— æ•ˆ"));
    }
}
```

### 2.3 ç­¾åèšåˆ

**MuSigåè®®**å®ç°å¤šæ–¹ç­¾åèšåˆ:

```java
import java.util.*;

/**
 * MuSigå¤šç­¾èšåˆå®ç°
 */
public class MuSigAggregation {

    /**
     * èšåˆå…¬é’¥
     */
    public static SchnorrSignature.ECPoint aggregatePublicKeys(
            List<SchnorrSignature.ECPoint> publicKeys) throws Exception {

        if (publicKeys.isEmpty()) {
            throw new IllegalArgumentException("å…¬é’¥åˆ—è¡¨ä¸èƒ½ä¸ºç©º");
        }

        // 1. è®¡ç®—å…¬é’¥å“ˆå¸Œ
        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
        for (SchnorrSignature.ECPoint pk : publicKeys) {
            sha256.update(pk.serialize());
        }
        byte[] L = sha256.digest();

        // 2. è®¡ç®—æ¯ä¸ªå…¬é’¥çš„ç³»æ•°
        SchnorrSignature.ECPoint aggPubKey = null;

        for (SchnorrSignature.ECPoint pk : publicKeys) {
            // ai = H(L || pki)
            sha256.reset();
            sha256.update(L);
            sha256.update(pk.serialize());
            BigInteger ai = new BigInteger(1, sha256.digest())
                .mod(SchnorrSignature.KeyPair.N);

            // P_agg += ai * pki
            SchnorrSignature.ECPoint weighted =
                SchnorrSignature.ECPoint.multiply(pk, ai);
            aggPubKey = (aggPubKey == null) ? weighted :
                SchnorrSignature.ECPoint.add(aggPubKey, weighted);
        }

        return aggPubKey;
    }

    /**
     * MuSigç­¾åä¼šè¯
     */
    public static class SigningSession {
        private List<SchnorrSignature.ECPoint> publicKeys;
        private List<SchnorrSignature.ECPoint> commitments; // Riå€¼
        private SchnorrSignature.ECPoint aggregatedR;

        public SigningSession(List<SchnorrSignature.ECPoint> publicKeys) {
            this.publicKeys = publicKeys;
            this.commitments = new ArrayList<>();
        }

        /**
         * ç¬¬ä¸€è½®: æ¯ä¸ªç­¾åè€…ç”Ÿæˆæ‰¿è¯º
         */
        public SchnorrSignature.ECPoint generateCommitment(BigInteger nonce) {
            SchnorrSignature.ECPoint R =
                SchnorrSignature.ECPoint.multiply(SchnorrSignature.ECPoint.G, nonce);
            commitments.add(R);
            return R;
        }

        /**
         * ç¬¬äºŒè½®: èšåˆæ‰€æœ‰æ‰¿è¯º
         */
        public void aggregateCommitments() {
            aggregatedR = null;
            for (SchnorrSignature.ECPoint R : commitments) {
                aggregatedR = (aggregatedR == null) ? R :
                    SchnorrSignature.ECPoint.add(aggregatedR, R);
            }
        }

        /**
         * ç¬¬ä¸‰è½®: ç”Ÿæˆéƒ¨åˆ†ç­¾å
         */
        public BigInteger generatePartialSignature(
                BigInteger privateKey,
                BigInteger nonce,
                byte[] message) throws Exception {

            // è®¡ç®—èšåˆå…¬é’¥
            SchnorrSignature.ECPoint aggPubKey =
                aggregatePublicKeys(publicKeys);

            // è®¡ç®—æŒ‘æˆ˜å€¼
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            sha256.update(aggregatedR.serialize());
            sha256.update(aggPubKey.serialize());
            sha256.update(message);
            BigInteger e = new BigInteger(1, sha256.digest())
                .mod(SchnorrSignature.KeyPair.N);

            // è®¡ç®—å…¬é’¥ç³»æ•°
            sha256.reset();
            for (SchnorrSignature.ECPoint pk : publicKeys) {
                sha256.update(pk.serialize());
            }
            byte[] L = sha256.digest();

            SchnorrSignature.ECPoint myPubKey =
                SchnorrSignature.ECPoint.multiply(SchnorrSignature.ECPoint.G, privateKey);
            sha256.reset();
            sha256.update(L);
            sha256.update(myPubKey.serialize());
            BigInteger ai = new BigInteger(1, sha256.digest())
                .mod(SchnorrSignature.KeyPair.N);

            // si = ki + e * ai * di
            BigInteger si = nonce.add(e.multiply(ai).multiply(privateKey))
                .mod(SchnorrSignature.KeyPair.N);

            return si;
        }

        /**
         * ç¬¬å››è½®: èšåˆéƒ¨åˆ†ç­¾å
         */
        public SchnorrSignature.Signature aggregateSignatures(
                List<BigInteger> partialSignatures) {

            BigInteger s = BigInteger.ZERO;
            for (BigInteger si : partialSignatures) {
                s = s.add(si).mod(SchnorrSignature.KeyPair.N);
            }

            return new SchnorrSignature.Signature(aggregatedR.x.mod(SchnorrSignature.KeyPair.N), s);
        }
    }

    /**
     * ä½¿ç”¨ç¤ºä¾‹
     */
    public static void main(String[] args) throws Exception {
        System.out.println("=== MuSig 2-of-2å¤šç­¾ç¤ºä¾‹ ===\n");

        // ä¸¤ä¸ªç­¾åè€…
        SecureRandom random = new SecureRandom();
        BigInteger privKey1 = new BigInteger(256, random)
            .mod(SchnorrSignature.KeyPair.N);
        BigInteger privKey2 = new BigInteger(256, random)
            .mod(SchnorrSignature.KeyPair.N);

        SchnorrSignature.KeyPair keyPair1 = new SchnorrSignature.KeyPair(privKey1);
        SchnorrSignature.KeyPair keyPair2 = new SchnorrSignature.KeyPair(privKey2);

        List<SchnorrSignature.ECPoint> publicKeys = Arrays.asList(
            keyPair1.publicKey,
            keyPair2.publicKey
        );

        // èšåˆå…¬é’¥
        SchnorrSignature.ECPoint aggPubKey = aggregatePublicKeys(publicKeys);
        System.out.println("èšåˆå…¬é’¥X: " + aggPubKey.x.toString(16).substring(0, 16) + "...");
        System.out.println();

        // åˆ›å»ºç­¾åä¼šè¯
        SigningSession session = new SigningSession(publicKeys);

        // ç¬¬ä¸€è½®: ç”Ÿæˆnonceå’Œæ‰¿è¯º
        BigInteger nonce1 = new BigInteger(256, random)
            .mod(SchnorrSignature.KeyPair.N);
        BigInteger nonce2 = new BigInteger(256, random)
            .mod(SchnorrSignature.KeyPair.N);

        session.generateCommitment(nonce1);
        session.generateCommitment(nonce2);

        // ç¬¬äºŒè½®: èšåˆæ‰¿è¯º
        session.aggregateCommitments();

        // ç¬¬ä¸‰è½®: ç”Ÿæˆéƒ¨åˆ†ç­¾å
        byte[] message = "2-of-2 MultiSig Transaction".getBytes();
        BigInteger partialSig1 = session.generatePartialSignature(
            privKey1, nonce1, message);
        BigInteger partialSig2 = session.generatePartialSignature(
            privKey2, nonce2, message);

        System.out.println("éƒ¨åˆ†ç­¾å1: " + partialSig1.toString(16).substring(0, 16) + "...");
        System.out.println("éƒ¨åˆ†ç­¾å2: " + partialSig2.toString(16).substring(0, 16) + "...");
        System.out.println();

        // ç¬¬å››è½®: èšåˆç­¾å
        SchnorrSignature.Signature finalSignature = session.aggregateSignatures(
            Arrays.asList(partialSig1, partialSig2)
        );

        System.out.println("èšåˆç­¾åR: " + finalSignature.r.toString(16).substring(0, 16) + "...");
        System.out.println("èšåˆç­¾åS: " + finalSignature.s.toString(16).substring(0, 16) + "...");
        System.out.println("ç­¾åå¤§å°: 64å­—èŠ‚");
        System.out.println();

        // éªŒè¯ç­¾å
        boolean valid = SchnorrSignature.verify(aggPubKey, message, finalSignature);
        System.out.println("ç­¾åéªŒè¯: " + (valid ? "âœ“ æœ‰æ•ˆ" : "âœ— æ— æ•ˆ"));
        System.out.println("\nğŸ’¡ ä¼˜åŠ¿: 2-of-2å¤šç­¾çœ‹èµ·æ¥å’Œå•ç­¾åä¸€æ ·!");
    }
}
```

## 3. MAST (Merklized Abstract Syntax Trees)

### 3.1 MASTåŸç†

MASTå…è®¸å°†å¤æ‚è„šæœ¬ç»„ç»‡æˆMerkleæ ‘,åªéœ€æš´éœ²æ‰§è¡Œçš„åˆ†æ”¯:

```mermaid
graph TB
    A[Merkle Root<br/>åµŒå…¥Taprootè¾“å‡º] --> B[Branch 1]
    A --> C[Branch 2]

    B --> D[Script 1: Alice]
    B --> E[Script 2: Bob]

    C --> F[Script 3: 2-of-3 MultiSig]
    C --> G[Script 4: æ—¶é—´é”]

    style D fill:#90EE90
    style E fill:#FFE4B5
    style F fill:#FFE4B5
    style G fill:#FFE4B5

    H[æ‰§è¡Œæ—¶åªæš´éœ²Script 1] -.-> D
```

**ä¼˜åŠ¿**:
- **éšç§**: æœªæ‰§è¡Œçš„è„šæœ¬åˆ†æ”¯ä¸ä¼šæš´éœ²
- **æ•ˆç‡**: åªéœ€éªŒè¯ä¸€æ¡Merkleè·¯å¾„
- **çµæ´»æ€§**: æ”¯æŒä»»æ„å¤æ‚çš„è„šæœ¬ç»„åˆ

### 3.2 Taprootè¾“å‡ºç»“æ„

```
Taprootè¾“å‡ºåœ°å€ = P + H(P||root)*G

å…¶ä¸­:
- P: å†…éƒ¨å…¬é’¥(key path)
- root: MASTæ ‘æ ¹
- H(): æ ‡ç­¾åŒ–å“ˆå¸Œå‡½æ•°
```

### 3.3 MASTæ ‘Javaå®ç°

```java
import java.util.*;

/**
 * MASTæ ‘å®ç°
 */
public class MASTTree {

    /**
     * è„šæœ¬å¶å­èŠ‚ç‚¹
     */
    public static class ScriptLeaf {
        private byte[] script;
        private int version;

        public ScriptLeaf(byte[] script, int version) {
            this.script = script;
            this.version = version;
        }

        /**
         * è®¡ç®—å¶å­å“ˆå¸Œ
         */
        public byte[] getLeafHash() throws Exception {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");

            // TapLeaf = TaggedHash("TapLeaf", version || script_size || script)
            byte[] tag = "TapLeaf".getBytes();
            byte[] tagHash = sha256.digest(tag);

            sha256.reset();
            sha256.update(tagHash);
            sha256.update(tagHash);
            sha256.update(new byte[]{(byte) version});
            sha256.update(encodeCompactSize(script.length));
            sha256.update(script);

            return sha256.digest();
        }

        public byte[] getScript() {
            return script;
        }
    }

    /**
     * MASTæ ‘èŠ‚ç‚¹
     */
    public static class MerkleNode {
        private byte[] hash;
        private MerkleNode left;
        private MerkleNode right;
        private ScriptLeaf leaf;

        // å¶å­èŠ‚ç‚¹
        public MerkleNode(ScriptLeaf leaf) throws Exception {
            this.leaf = leaf;
            this.hash = leaf.getLeafHash();
        }

        // åˆ†æ”¯èŠ‚ç‚¹
        public MerkleNode(MerkleNode left, MerkleNode right) throws Exception {
            this.left = left;
            this.right = right;
            this.hash = computeBranchHash(left.hash, right.hash);
        }

        private byte[] computeBranchHash(byte[] left, byte[] right) throws Exception {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");

            // TapBranch = TaggedHash("TapBranch", left || right)
            // æ³¨æ„: leftå’Œrightéœ€è¦æŒ‰å­—å…¸åºæ’åº
            byte[] first = left;
            byte[] second = right;

            if (compareBytes(left, right) > 0) {
                first = right;
                second = left;
            }

            byte[] tag = "TapBranch".getBytes();
            byte[] tagHash = sha256.digest(tag);

            sha256.reset();
            sha256.update(tagHash);
            sha256.update(tagHash);
            sha256.update(first);
            sha256.update(second);

            return sha256.digest();
        }

        public byte[] getHash() {
            return hash;
        }

        public boolean isLeaf() {
            return leaf != null;
        }

        public ScriptLeaf getLeaf() {
            return leaf;
        }
    }

    /**
     * Taprootè¾“å‡º
     */
    public static class TaprootOutput {
        private SchnorrSignature.ECPoint internalPubKey; // P
        private MerkleNode mastRoot; // Merkleæ ‘æ ¹
        private SchnorrSignature.ECPoint outputPubKey; // Q = P + H(P||root)*G

        public TaprootOutput(SchnorrSignature.ECPoint internalPubKey,
                            MerkleNode mastRoot) throws Exception {
            this.internalPubKey = internalPubKey;
            this.mastRoot = mastRoot;
            this.outputPubKey = computeOutputPubKey();
        }

        /**
         * è®¡ç®—Taprootè¾“å‡ºå…¬é’¥
         * Q = P + H(P || root) * G
         */
        private SchnorrSignature.ECPoint computeOutputPubKey() throws Exception {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");

            // t = TaggedHash("TapTweak", P || root)
            byte[] tag = "TapTweak".getBytes();
            byte[] tagHash = sha256.digest(tag);

            sha256.reset();
            sha256.update(tagHash);
            sha256.update(tagHash);
            sha256.update(internalPubKey.serialize());
            if (mastRoot != null) {
                sha256.update(mastRoot.getHash());
            }

            BigInteger t = new BigInteger(1, sha256.digest())
                .mod(SchnorrSignature.KeyPair.N);

            // Q = P + t*G
            SchnorrSignature.ECPoint tG =
                SchnorrSignature.ECPoint.multiply(SchnorrSignature.ECPoint.G, t);
            return SchnorrSignature.ECPoint.add(internalPubKey, tG);
        }

        /**
         * ç”ŸæˆTaprootåœ°å€ (bech32m, bc1p...)
         */
        public String getAddress() {
            byte[] pubKeyBytes = outputPubKey.serialize();
            // ç®€åŒ–: è¿”å›hexæ ¼å¼,å®é™…åº”ä½¿ç”¨bech32mç¼–ç 
            return "bc1p" + bytesToHex(pubKeyBytes).substring(0, 52) + "...";
        }

        public SchnorrSignature.ECPoint getOutputPubKey() {
            return outputPubKey;
        }

        public MerkleNode getMastRoot() {
            return mastRoot;
        }
    }

    /**
     * Merkleè¯æ˜
     */
    public static class MerkleProof {
        private List<byte[]> siblings; // å…„å¼ŸèŠ‚ç‚¹å“ˆå¸Œ
        private List<Boolean> positions; // true=å³, false=å·¦

        public MerkleProof() {
            this.siblings = new ArrayList<>();
            this.positions = new ArrayList<>();
        }

        public void addSibling(byte[] siblingHash, boolean isRight) {
            siblings.add(siblingHash);
            positions.add(isRight);
        }

        /**
         * éªŒè¯Merkleè¯æ˜
         */
        public boolean verify(byte[] leafHash, byte[] rootHash) throws Exception {
            byte[] currentHash = leafHash;

            for (int i = 0; i < siblings.size(); i++) {
                byte[] sibling = siblings.get(i);
                boolean isRight = positions.get(i);

                MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
                byte[] tag = "TapBranch".getBytes();
                byte[] tagHash = sha256.digest(tag);

                byte[] left = isRight ? currentHash : sibling;
                byte[] right = isRight ? sibling : currentHash;

                // æŒ‰å­—å…¸åºæ’åº
                if (compareBytes(left, right) > 0) {
                    byte[] temp = left;
                    left = right;
                    right = temp;
                }

                sha256.reset();
                sha256.update(tagHash);
                sha256.update(tagHash);
                sha256.update(left);
                sha256.update(right);

                currentHash = sha256.digest();
            }

            return Arrays.equals(currentHash, rootHash);
        }

        public List<byte[]> getSiblings() {
            return siblings;
        }
    }

    /**
     * æ„å»ºMASTæ ‘
     */
    public static MerkleNode buildTree(List<ScriptLeaf> leaves) throws Exception {
        if (leaves.isEmpty()) {
            throw new IllegalArgumentException("å¶å­èŠ‚ç‚¹ä¸èƒ½ä¸ºç©º");
        }

        // æ„å»ºå¶å­èŠ‚ç‚¹
        List<MerkleNode> nodes = new ArrayList<>();
        for (ScriptLeaf leaf : leaves) {
            nodes.add(new MerkleNode(leaf));
        }

        // é€’å½’æ„å»ºæ ‘
        while (nodes.size() > 1) {
            List<MerkleNode> parentNodes = new ArrayList<>();
            for (int i = 0; i < nodes.size(); i += 2) {
                if (i + 1 < nodes.size()) {
                    parentNodes.add(new MerkleNode(nodes.get(i), nodes.get(i + 1)));
                } else {
                    // å¥‡æ•°ä¸ªèŠ‚ç‚¹,æœ€åä¸€ä¸ªä¸Šç§»
                    parentNodes.add(nodes.get(i));
                }
            }
            nodes = parentNodes;
        }

        return nodes.get(0);
    }

    /**
     * ç”ŸæˆMerkleè¯æ˜
     */
    public static MerkleProof generateProof(MerkleNode root, ScriptLeaf targetLeaf)
            throws Exception {
        MerkleProof proof = new MerkleProof();
        findLeafAndBuildProof(root, targetLeaf, proof);
        return proof;
    }

    private static boolean findLeafAndBuildProof(MerkleNode node,
            ScriptLeaf targetLeaf, MerkleProof proof) throws Exception {

        if (node.isLeaf()) {
            return Arrays.equals(node.getLeaf().script, targetLeaf.script);
        }

        // å°è¯•å·¦å­æ ‘
        if (node.left != null && findLeafAndBuildProof(node.left, targetLeaf, proof)) {
            if (node.right != null) {
                proof.addSibling(node.right.getHash(), true);
            }
            return true;
        }

        // å°è¯•å³å­æ ‘
        if (node.right != null && findLeafAndBuildProof(node.right, targetLeaf, proof)) {
            if (node.left != null) {
                proof.addSibling(node.left.getHash(), false);
            }
            return true;
        }

        return false;
    }

    // è¾…åŠ©æ–¹æ³•
    private static byte[] encodeCompactSize(long value) {
        if (value < 253) {
            return new byte[]{(byte) value};
        } else if (value <= 0xFFFF) {
            return new byte[]{(byte) 253, (byte) value, (byte) (value >> 8)};
        }
        // æ›´å¤§çš„å€¼çœç•¥
        return new byte[]{(byte) 253, (byte) value, (byte) (value >> 8)};
    }

    private static int compareBytes(byte[] a, byte[] b) {
        for (int i = 0; i < Math.min(a.length, b.length); i++) {
            int cmp = Integer.compare(a[i] & 0xFF, b[i] & 0xFF);
            if (cmp != 0) return cmp;
        }
        return Integer.compare(a.length, b.length);
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

    /**
     * ä½¿ç”¨ç¤ºä¾‹
     */
    public static void main(String[] args) throws Exception {
        System.out.println("=== MASTæ ‘ç¤ºä¾‹ ===\n");

        // åˆ›å»ºå¤šä¸ªè„šæœ¬åˆ†æ”¯
        ScriptLeaf script1 = new ScriptLeaf(
            "OP_CHECKSIG Alice".getBytes(), 0xC0);
        ScriptLeaf script2 = new ScriptLeaf(
            "OP_CHECKSIG Bob".getBytes(), 0xC0);
        ScriptLeaf script3 = new ScriptLeaf(
            "2 <Alice> <Bob> <Charlie> 3 OP_CHECKMULTISIG".getBytes(), 0xC0);
        ScriptLeaf script4 = new ScriptLeaf(
            "144 OP_CHECKSEQUENCEVERIFY OP_CHECKSIG Recovery".getBytes(), 0xC0);

        List<ScriptLeaf> leaves = Arrays.asList(script1, script2, script3, script4);

        // æ„å»ºMASTæ ‘
        MerkleNode root = buildTree(leaves);
        System.out.println("MASTæ ‘æ ¹: " + bytesToHex(root.getHash()).substring(0, 16) + "...");
        System.out.println();

        // ç”Ÿæˆå†…éƒ¨å…¬é’¥
        SecureRandom random = new SecureRandom();
        BigInteger privKey = new BigInteger(256, random)
            .mod(SchnorrSignature.KeyPair.N);
        SchnorrSignature.KeyPair keyPair = new SchnorrSignature.KeyPair(privKey);

        // åˆ›å»ºTaprootè¾“å‡º
        TaprootOutput taproot = new TaprootOutput(keyPair.publicKey, root);
        System.out.println("å†…éƒ¨å…¬é’¥: " + keyPair.publicKey.x.toString(16).substring(0, 16) + "...");
        System.out.println("Taprootåœ°å€: " + taproot.getAddress());
        System.out.println();

        // ç”ŸæˆAliceè„šæœ¬çš„Merkleè¯æ˜
        MerkleProof proof = generateProof(root, script1);
        System.out.println("Aliceè„šæœ¬çš„Merkleè¯æ˜:");
        System.out.println("- è¯æ˜è·¯å¾„é•¿åº¦: " + proof.getSiblings().size());

        // éªŒè¯è¯æ˜
        boolean valid = proof.verify(script1.getLeafHash(), root.getHash());
        System.out.println("- è¯æ˜éªŒè¯: " + (valid ? "âœ“ æœ‰æ•ˆ" : "âœ— æ— æ•ˆ"));
        System.out.println();

        // è®¡ç®—èŠ‚çœçš„ç©ºé—´
        int totalScriptSize = 0;
        for (ScriptLeaf leaf : leaves) {
            totalScriptSize += leaf.getScript().length;
        }
        int revealedSize = script1.getScript().length + proof.getSiblings().size() * 32;

        System.out.println("ğŸ’¡ ç©ºé—´èŠ‚çœ:");
        System.out.println("- å…¨éƒ¨è„šæœ¬å¤§å°: " + totalScriptSize + " å­—èŠ‚");
        System.out.println("- å®é™…æš´éœ²å¤§å°: " + revealedSize + " å­—èŠ‚");
        System.out.println("- èŠ‚çœæ¯”ä¾‹: " +
            String.format("%.1f%%", (1.0 - (double)revealedSize/totalScriptSize) * 100));
    }
}
```

## 4. Tapscript

### 4.1 Tapscriptæ”¹è¿›

Tapscriptæ˜¯Bitcoin Scriptçš„å‡çº§ç‰ˆæœ¬,ä¸»è¦æ”¹è¿›:

| ç‰¹æ€§ | Legacy Script | Tapscript |
|-----|--------------|-----------|
| ç­¾åéªŒè¯ | OP_CHECKSIG (ECDSA) | OP_CHECKSIG (Schnorr) |
| å…¬é’¥æ ¼å¼ | 33å­—èŠ‚å‹ç¼© | 32å­—èŠ‚x-only |
| è„šæœ¬å¤§å°é™åˆ¶ | 10,000å­—èŠ‚ | 10,000å­—èŠ‚ |
| OP_SUCCESS | ä¸å­˜åœ¨ | é¢„ç•™æœªæ¥å‡çº§ |
| ç­¾åå“ˆå¸Œ | SIGHASH flags | æ”¹è¿›çš„sighash |

### 4.2 æ–°çš„OP_CHECKSIG

```java
/**
 * Tapscriptä¸­çš„OP_CHECKSIGå®ç°
 */
public class TapscriptOpCheckSig {

    /**
     * Tapscriptç­¾åå“ˆå¸Œè®¡ç®—
     */
    public static byte[] computeSigHash(
            Transaction tx,
            int inputIndex,
            List<TxOutput> prevouts,
            int sigHashType) throws Exception {

        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");

        // Taprootç­¾åå“ˆå¸Œä½¿ç”¨BIP341å®šä¹‰çš„æ–°æ ¼å¼
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        // 1. åŸºç¡€å­—æ®µ
        bos.write(0x00); // epoch
        bos.write(sigHashType & 0xFF); // hash type
        bos.write(intToBytes(tx.version));
        bos.write(intToBytes(tx.lockTime));

        // 2. å¦‚æœä¸æ˜¯ANYONECANPAY,åŒ…å«æ‰€æœ‰è¾“å…¥
        if ((sigHashType & 0x80) == 0) {
            // sha_prevouts
            MessageDigest prevoutHash = MessageDigest.getInstance("SHA-256");
            for (TxInput input : tx.inputs) {
                prevoutHash.update(input.prevTxId);
                prevoutHash.update(intToBytes(input.prevIndex));
            }
            bos.write(sha256.digest(prevoutHash.digest()));

            // sha_amounts
            MessageDigest amountHash = MessageDigest.getInstance("SHA-256");
            for (TxOutput prevout : prevouts) {
                amountHash.update(longToBytes(prevout.amount));
            }
            bos.write(sha256.digest(amountHash.digest()));

            // sha_scriptpubkeys
            MessageDigest scriptHash = MessageDigest.getInstance("SHA-256");
            for (TxOutput prevout : prevouts) {
                scriptHash.update(prevout.scriptPubKey);
            }
            bos.write(sha256.digest(scriptHash.digest()));

            // sha_sequences
            MessageDigest seqHash = MessageDigest.getInstance("SHA-256");
            for (TxInput input : tx.inputs) {
                seqHash.update(intToBytes(input.sequence));
            }
            bos.write(sha256.digest(seqHash.digest()));
        }

        // 3. å¦‚æœä¸æ˜¯SINGLEæˆ–NONE,åŒ…å«æ‰€æœ‰è¾“å‡º
        int sigHashTypeBase = sigHashType & 0x1F;
        if (sigHashTypeBase != 0x02 && sigHashTypeBase != 0x03) {
            MessageDigest outputHash = MessageDigest.getInstance("SHA-256");
            for (TxOutput output : tx.outputs) {
                outputHash.update(longToBytes(output.amount));
                outputHash.update(output.scriptPubKey);
            }
            bos.write(sha256.digest(outputHash.digest()));
        }

        // 4. å½“å‰è¾“å…¥æ•°æ®
        bos.write(intToBytes(inputIndex));

        byte[] message = bos.toByteArray();

        // 5. TaggedHash("TapSighash", message)
        byte[] tag = "TapSighash".getBytes();
        byte[] tagHash = sha256.digest(tag);

        sha256.reset();
        sha256.update(tagHash);
        sha256.update(tagHash);
        sha256.update(message);

        return sha256.digest();
    }

    /**
     * OP_CHECKSIGæ‰§è¡Œ
     */
    public static boolean opCheckSig(
            byte[] publicKey,
            byte[] signature,
            Transaction tx,
            int inputIndex,
            List<TxOutput> prevouts) throws Exception {

        if (publicKey.length != 32) {
            throw new IllegalArgumentException("Tapscriptå…¬é’¥å¿…é¡»æ˜¯32å­—èŠ‚");
        }

        if (signature.length != 64 && signature.length != 65) {
            return false; // æ— æ•ˆç­¾åé•¿åº¦
        }

        // æå–sighash type
        int sigHashType = (signature.length == 65) ?
            (signature[64] & 0xFF) : 0x00; // é»˜è®¤SIGHASH_ALL

        // è®¡ç®—ç­¾åå“ˆå¸Œ
        byte[] sigHash = computeSigHash(tx, inputIndex, prevouts, sigHashType);

        // æå–64å­—èŠ‚Schnorrç­¾å
        byte[] schnorrSig = Arrays.copyOf(signature, 64);
        BigInteger r = new BigInteger(1, Arrays.copyOfRange(schnorrSig, 0, 32));
        BigInteger s = new BigInteger(1, Arrays.copyOfRange(schnorrSig, 32, 64));

        // é‡å»ºå…¬é’¥ECPoint (ä»32å­—èŠ‚xåæ ‡)
        BigInteger x = new BigInteger(1, publicKey);
        SchnorrSignature.ECPoint pubKey = reconstructPublicKey(x);

        // éªŒè¯Schnorrç­¾å
        SchnorrSignature.Signature sig = new SchnorrSignature.Signature(r, s);
        return SchnorrSignature.verify(pubKey, sigHash, sig);
    }

    /**
     * ä»xåæ ‡é‡å»ºå…¬é’¥
     */
    private static SchnorrSignature.ECPoint reconstructPublicKey(BigInteger x) {
        // ç®€åŒ–å®ç°: æ ¹æ®xè®¡ç®—y
        // y^2 = x^3 + 7 (mod p)
        BigInteger ySquared = x.modPow(BigInteger.valueOf(3), SchnorrSignature.P)
            .add(BigInteger.valueOf(7)).mod(SchnorrSignature.P);

        BigInteger y = ySquared.modPow(
            SchnorrSignature.P.add(BigInteger.ONE).divide(BigInteger.valueOf(4)),
            SchnorrSignature.P
        );

        // é€‰æ‹©å¶æ•°y (BIP340è§„èŒƒ)
        if (y.testBit(0)) {
            y = SchnorrSignature.P.subtract(y);
        }

        return new SchnorrSignature.ECPoint(x, y);
    }

    // è¾…åŠ©æ–¹æ³•
    private static byte[] intToBytes(int value) {
        return new byte[]{
            (byte) value,
            (byte) (value >> 8),
            (byte) (value >> 16),
            (byte) (value >> 24)
        };
    }

    private static byte[] longToBytes(long value) {
        return new byte[]{
            (byte) value,
            (byte) (value >> 8),
            (byte) (value >> 16),
            (byte) (value >> 24),
            (byte) (value >> 32),
            (byte) (value >> 40),
            (byte) (value >> 48),
            (byte) (value >> 56)
        };
    }

    // ç®€åŒ–çš„äº¤æ˜“ç»“æ„
    public static class Transaction {
        int version;
        List<TxInput> inputs;
        List<TxOutput> outputs;
        int lockTime;
    }

    public static class TxInput {
        byte[] prevTxId;
        int prevIndex;
        int sequence;
    }

    public static class TxOutput {
        long amount;
        byte[] scriptPubKey;
    }
}
```

### 4.3 OP_SUCCESSé¢„ç•™å‡çº§ç©ºé—´

Tapscriptå¼•å…¥äº†80ä¸ªæ–°çš„`OP_SUCCESS`æ“ä½œç (OP_SUCCESS80 åˆ° OP_SUCCESS187),ä¸ºæœªæ¥è½¯åˆ†å‰å‡çº§é¢„ç•™ç©ºé—´:

```java
/**
 * OP_SUCCESSæœºåˆ¶
 */
public class OpSuccessMechanism {

    /**
     * æ£€æŸ¥æ“ä½œç æ˜¯å¦ä¸ºOP_SUCCESS
     */
    public static boolean isOpSuccess(int opcode) {
        return opcode == 80 || opcode == 98 ||
               (opcode >= 126 && opcode <= 129) ||
               (opcode >= 131 && opcode <= 134) ||
               (opcode >= 137 && opcode <= 138) ||
               (opcode >= 141 && opcode <= 142) ||
               (opcode >= 149 && opcode <= 153) ||
               (opcode >= 187 && opcode <= 254);
    }

    /**
     * æ‰§è¡Œè„šæœ¬æ—¶é‡åˆ°OP_SUCCESS
     */
    public static boolean executeScript(byte[] script) {
        for (byte opcode : script) {
            if (isOpSuccess(opcode & 0xFF)) {
                // åœ¨Tapscriptä¸­,ä»»ä½•OP_SUCCESSéƒ½ä½¿è„šæœ¬æˆåŠŸ
                // è¿™å…è®¸æœªæ¥çš„è½¯åˆ†å‰é‡æ–°å®šä¹‰è¿™äº›æ“ä½œç 
                System.out.println("é‡åˆ°OP_SUCCESS" + (opcode & 0xFF) +
                    ", è„šæœ¬è‡ªåŠ¨æˆåŠŸ");
                return true;
            }

            // æ‰§è¡Œå…¶ä»–æ“ä½œç ...
        }
        return false;
    }

    /**
     * ç¤ºä¾‹: æœªæ¥å¯èƒ½çš„å‡çº§
     */
    public static void futureUpgradeExample() {
        System.out.println("=== OP_SUCCESSå‡çº§ç¤ºä¾‹ ===\n");

        System.out.println("å½“å‰(2024): OP_SUCCESS80 â†’ è‡ªåŠ¨æˆåŠŸ");
        System.out.println();

        System.out.println("æœªæ¥è½¯åˆ†å‰(å‡è®¾):");
        System.out.println("- OP_SUCCESS80 é‡å®šä¹‰ä¸º OP_CHECKTEMPLATEVERIFY");
        System.out.println("- OP_SUCCESS98 é‡å®šä¹‰ä¸º OP_CAT");
        System.out.println("- OP_SUCCESS126 é‡å®šä¹‰ä¸º OP_CHECKSIGFROMSTACK");
        System.out.println();

        System.out.println("ğŸ’¡ æ—§èŠ‚ç‚¹: ä»ç„¶å°†è¿™äº›è§†ä¸ºOP_SUCCESS,è„šæœ¬æˆåŠŸ");
        System.out.println("ğŸ’¡ æ–°èŠ‚ç‚¹: æ‰§è¡Œæ–°çš„æ“ä½œç é€»è¾‘");
        System.out.println("ğŸ’¡ ç»“æœ: è½¯åˆ†å‰,æ— éœ€ç¡¬åˆ†å‰!");
    }

    public static void main(String[] args) {
        futureUpgradeExample();
    }
}
```

## 5. Taprootå®æˆ˜åº”ç”¨

### 5.1 Key PathèŠ±è´¹ (æœ€å¸¸è§åœºæ™¯)

```java
/**
 * Taproot Key PathèŠ±è´¹
 */
public class TaprootKeyPathSpend {

    /**
     * åˆ›å»ºKey PathèŠ±è´¹äº¤æ˜“
     */
    public static Transaction createKeyPathSpend(
            String taprootUtxo,
            BigInteger internalPrivateKey,
            BigInteger tweakValue,
            String recipientAddress,
            long amount) throws Exception {

        // 1. è®¡ç®—è°ƒæ•´åçš„ç§é’¥: privKey' = privKey + tweak
        BigInteger tweakedPrivKey = internalPrivateKey.add(tweakValue)
            .mod(SchnorrSignature.KeyPair.N);

        // 2. æ„å»ºäº¤æ˜“
        Transaction tx = new Transaction();
        tx.version = 2;
        tx.lockTime = 0;

        TxInput input = new TxInput();
        input.prevTxId = hexToBytes(taprootUtxo.substring(0, 64));
        input.prevIndex = 0;
        input.sequence = 0xFFFFFFFF;
        tx.inputs = Arrays.asList(input);

        TxOutput output = new TxOutput();
        output.amount = amount;
        output.scriptPubKey = decodeAddress(recipientAddress);
        tx.outputs = Arrays.asList(output);

        // 3. è®¡ç®—ç­¾åå“ˆå¸Œ
        TxOutput prevout = new TxOutput();
        prevout.amount = amount + 1000; // åŒ…å«æ‰‹ç»­è´¹
        prevout.scriptPubKey = new byte[34]; // Taproot scriptPubKey

        byte[] sigHash = TapscriptOpCheckSig.computeSigHash(
            tx, 0, Arrays.asList(prevout), 0x00);

        // 4. ä½¿ç”¨è°ƒæ•´åçš„ç§é’¥ç­¾å
        SchnorrSignature.Signature signature =
            SchnorrSignature.sign(tweakedPrivKey, sigHash);

        // 5. åˆ›å»ºwitness
        input.witness = Arrays.asList(signature.serialize());

        System.out.println("=== Key PathèŠ±è´¹ ===");
        System.out.println("Witnesså¤§å°: " + signature.serialize().length + " å­—èŠ‚");
        System.out.println("ğŸ’¡ ä¸å•ç­¾åP2WPKHä¸€æ ·é«˜æ•ˆ!");

        return tx;
    }

    private static byte[] hexToBytes(String hex) {
        byte[] bytes = new byte[hex.length() / 2];
        for (int i = 0; i < bytes.length; i++) {
            bytes[i] = (byte) Integer.parseInt(hex.substring(i * 2, i * 2 + 2), 16);
        }
        return bytes;
    }

    private static byte[] decodeAddress(String address) {
        // ç®€åŒ–å®ç°
        return new byte[34];
    }

    public static class Transaction {
        int version;
        List<TxInput> inputs;
        List<TxOutput> outputs;
        int lockTime;
    }

    public static class TxInput {
        byte[] prevTxId;
        int prevIndex;
        int sequence;
        List<byte[]> witness;
    }

    public static class TxOutput {
        long amount;
        byte[] scriptPubKey;
    }
}
```

### 5.2 Script PathèŠ±è´¹ (ä½¿ç”¨MAST)

```java
/**
 * Taproot Script PathèŠ±è´¹
 */
public class TaprootScriptPathSpend {

    /**
     * åˆ›å»ºScript PathèŠ±è´¹äº¤æ˜“
     */
    public static Transaction createScriptPathSpend(
            String taprootUtxo,
            MASTTree.ScriptLeaf spendScript,
            MASTTree.MerkleProof proof,
            List<byte[]> scriptWitness,
            String recipientAddress,
            long amount) throws Exception {

        // 1. æ„å»ºäº¤æ˜“
        Transaction tx = new Transaction();
        tx.version = 2;
        tx.lockTime = 0;

        TxInput input = new TxInput();
        input.prevTxId = hexToBytes(taprootUtxo.substring(0, 64));
        input.prevIndex = 0;
        input.sequence = 0xFFFFFFFF;
        tx.inputs = Arrays.asList(input);

        TxOutput output = new TxOutput();
        output.amount = amount;
        output.scriptPubKey = decodeAddress(recipientAddress);
        tx.outputs = Arrays.asList(output);

        // 2. æ„å»ºwitnessæ ˆ
        List<byte[]> witness = new ArrayList<>();

        // 2.1 è„šæœ¬æ‰§è¡Œéœ€è¦çš„æ•°æ®(ç­¾åç­‰)
        witness.addAll(scriptWitness);

        // 2.2 è„šæœ¬æœ¬èº«
        witness.add(spendScript.getScript());

        // 2.3 æ§åˆ¶å— (control block)
        byte[] controlBlock = buildControlBlock(proof);
        witness.add(controlBlock);

        input.witness = witness;

        // 3. è®¡ç®—witnesså¤§å°
        int witnessSize = 0;
        for (byte[] item : witness) {
            witnessSize += item.length + 1; // +1 for length byte
        }

        System.out.println("=== Script PathèŠ±è´¹ ===");
        System.out.println("Witnessé¡¹æ•°: " + witness.size());
        System.out.println("Witnesså¤§å°: " + witnessSize + " å­—èŠ‚");
        System.out.println("ğŸ’¡ åªæš´éœ²æ‰§è¡Œçš„è„šæœ¬åˆ†æ”¯!");

        return tx;
    }

    /**
     * æ„å»ºæ§åˆ¶å—
     */
    private static byte[] buildControlBlock(MASTTree.MerkleProof proof)
            throws Exception {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        // 1. ç‰ˆæœ¬å­—èŠ‚ + å¥‡å¶ä½
        bos.write(0xC0); // ç‰ˆæœ¬ + parity bit

        // 2. å†…éƒ¨å…¬é’¥ (32å­—èŠ‚)
        byte[] internalPubKey = new byte[32];
        // å®é™…åº”ç”¨ä¸­ä»Taprootè¾“å‡ºä¸­è·å–
        bos.write(internalPubKey);

        // 3. Merkleè·¯å¾„ (æ¯ä¸ª32å­—èŠ‚)
        for (byte[] sibling : proof.getSiblings()) {
            bos.write(sibling);
        }

        return bos.toByteArray();
    }

    private static byte[] hexToBytes(String hex) {
        byte[] bytes = new byte[hex.length() / 2];
        for (int i = 0; i < bytes.length; i++) {
            bytes[i] = (byte) Integer.parseInt(hex.substring(i * 2, i * 2 + 2), 16);
        }
        return bytes;
    }

    private static byte[] decodeAddress(String address) {
        return new byte[34];
    }

    public static class Transaction {
        int version;
        List<TxInput> inputs;
        List<TxOutput> outputs;
        int lockTime;
    }

    public static class TxInput {
        byte[] prevTxId;
        int prevIndex;
        int sequence;
        List<byte[]> witness;
    }

    public static class TxOutput {
        long amount;
        byte[] scriptPubKey;
    }
}
```

### 5.3 å®Œæ•´ç¤ºä¾‹: ä¼ä¸šé‡‘åº“

```java
/**
 * ä¼ä¸šé‡‘åº“å®Œæ•´ç¤ºä¾‹
 *
 * åœºæ™¯:
 * - Key Path: CEOç›´æ¥èŠ±è´¹(æ—¥å¸¸å°é¢)
 * - Script Path 1: 2-of-3å¤šç­¾(ä¸­ç­‰é‡‘é¢)
 * - Script Path 2: 3-of-5å¤šç­¾(å¤§é¢)
 * - Script Path 3: æ—¶é—´é”æ¢å¤(1å¹´å)
 */
public class CorporateTreasuryTaproot {

    public static void main(String[] args) throws Exception {
        System.out.println("=== ä¼ä¸šé‡‘åº“ Taprootå®æˆ˜ ===\n");

        // 1. ç”Ÿæˆå¯†é’¥
        SecureRandom random = new SecureRandom();
        BigInteger ceoPrivKey = new BigInteger(256, random)
            .mod(SchnorrSignature.KeyPair.N);
        SchnorrSignature.KeyPair ceoKey = new SchnorrSignature.KeyPair(ceoPrivKey);

        System.out.println("1ï¸âƒ£  ç”Ÿæˆå¯†é’¥");
        System.out.println("CEOå…¬é’¥: " + ceoKey.publicKey.x.toString(16).substring(0, 16) + "...");
        System.out.println();

        // 2. åˆ›å»ºè„šæœ¬åˆ†æ”¯
        MASTTree.ScriptLeaf script1 = new MASTTree.ScriptLeaf(
            "2 <CFO> <CTO> <COO> 3 OP_CHECKMULTISIG".getBytes(), 0xC0);
        MASTTree.ScriptLeaf script2 = new MASTTree.ScriptLeaf(
            "3 <Dir1> <Dir2> <Dir3> <Dir4> <Dir5> 5 OP_CHECKMULTISIG".getBytes(), 0xC0);
        MASTTree.ScriptLeaf script3 = new MASTTree.ScriptLeaf(
            "52560 OP_CHECKSEQUENCEVERIFY <Recovery> OP_CHECKSIG".getBytes(), 0xC0);

        List<MASTTree.ScriptLeaf> leaves = Arrays.asList(script1, script2, script3);
        MASTTree.MerkleNode root = MASTTree.buildTree(leaves);

        System.out.println("2ï¸âƒ£  åˆ›å»ºMASTæ ‘");
        System.out.println("è„šæœ¬åˆ†æ”¯:");
        System.out.println("  - Branch 1: 2-of-3å¤šç­¾ (ä¸­ç­‰é‡‘é¢)");
        System.out.println("  - Branch 2: 3-of-5å¤šç­¾ (å¤§é¢)");
        System.out.println("  - Branch 3: 1å¹´æ—¶é—´é”æ¢å¤");
        System.out.println("MASTæ ¹: " + bytesToHex(root.getHash()).substring(0, 16) + "...");
        System.out.println();

        // 3. åˆ›å»ºTaprootè¾“å‡º
        MASTTree.TaprootOutput taproot = new MASTTree.TaprootOutput(
            ceoKey.publicKey, root);

        System.out.println("3ï¸âƒ£  ç”ŸæˆTaprootåœ°å€");
        System.out.println("å†…éƒ¨å…¬é’¥(CEO): " +
            ceoKey.publicKey.x.toString(16).substring(0, 16) + "...");
        System.out.println("Taprootåœ°å€: " + taproot.getAddress());
        System.out.println();

        // 4. åœºæ™¯A: CEOç›´æ¥èŠ±è´¹(Key Path)
        System.out.println("4ï¸âƒ£  åœºæ™¯A: CEOæ—¥å¸¸å°é¢èŠ±è´¹ (Key Path)");
        System.out.println("Witness: <64å­—èŠ‚ç­¾å>");
        System.out.println("é“¾ä¸Šè§‚å¯Ÿ: çœ‹èµ·æ¥åƒæ™®é€šå•ç­¾åè½¬è´¦");
        System.out.println("éšç§: âœ“ å®Œå…¨");
        System.out.println();

        // 5. åœºæ™¯B: 2-of-3å¤šç­¾(Script Path)
        System.out.println("5ï¸âƒ£  åœºæ™¯B: CFO+CTOæ‰¹å‡†ä¸­ç­‰é‡‘é¢ (Script Path)");
        MASTTree.MerkleProof proof1 = MASTTree.generateProof(root, script1);
        System.out.println("Witness:");
        System.out.println("  - <ç­¾å1> <ç­¾å2>");
        System.out.println("  - <2-of-3è„šæœ¬>");
        System.out.println("  - <æ§åˆ¶å—: 33 + " +
            (proof1.getSiblings().size() * 32) + " å­—èŠ‚>");
        System.out.println("é“¾ä¸Šè§‚å¯Ÿ: åªçœ‹åˆ°è¿™ä¸€ä¸ªè„šæœ¬åˆ†æ”¯");
        System.out.println("éšç§: âœ“ å…¶ä»–åˆ†æ”¯ä¸æš´éœ²");
        System.out.println();

        // 6. å¯¹æ¯”ä¼ ç»Ÿæ–¹æ¡ˆ
        System.out.println("6ï¸âƒ£  ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”");
        System.out.println();

        System.out.println("ä¼ ç»ŸP2SHå¤šç­¾:");
        System.out.println("  - åœ°å€: 3å¼€å¤´ (æ˜æ˜¾æ˜¯å¤šç­¾)");
        System.out.println("  - èŠ±è´¹: æš´éœ²å®Œæ•´èµå›è„šæœ¬");
        System.out.println("  - éšç§: âœ— å·®");
        System.out.println("  - çµæ´»æ€§: âœ— æœ‰é™");
        System.out.println();

        System.out.println("Taprootæ–¹æ¡ˆ:");
        System.out.println("  - åœ°å€: bc1på¼€å¤´ (æ— æ³•åŒºåˆ†)");
        System.out.println("  - èŠ±è´¹: Key Pathæ—¶å®Œå…¨ç§å¯†");
        System.out.println("  - éšç§: âœ“ ä¼˜ç§€");
        System.out.println("  - çµæ´»æ€§: âœ“ æé«˜(æ”¯æŒå¤šä¸ªè„šæœ¬åˆ†æ”¯)");
        System.out.println();

        // 7. æˆæœ¬åˆ†æ
        System.out.println("7ï¸âƒ£  æˆæœ¬åˆ†æ");
        System.out.println();
        System.out.println("Key PathèŠ±è´¹:");
        System.out.println("  - Witness: ~64å­—èŠ‚ (1ä¸ªç­¾å)");
        System.out.println("  - æ‰‹ç»­è´¹: æœ€ä½");
        System.out.println();
        System.out.println("Script PathèŠ±è´¹:");
        System.out.println("  - Witness: ~200å­—èŠ‚ (å–å†³äºè„šæœ¬)");
        System.out.println("  - æ‰‹ç»­è´¹: ç¨é«˜,ä½†ä»ä¼˜äºä¼ ç»ŸP2SH");
        System.out.println();

        System.out.println("âœ… Taprootå®Œç¾ç»“åˆäº†éšç§ã€çµæ´»æ€§å’Œæ•ˆç‡!");
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
}
```

## 6. Taprooté‡‡ç”¨æƒ…å†µ

### 6.1 ç½‘ç»œç»Ÿè®¡

```java
import java.time.LocalDate;
import java.util.*;

/**
 * Taprooté‡‡ç”¨ç»Ÿè®¡
 */
public class TaprootAdoptionStats {

    public static class AdoptionData {
        LocalDate date;
        double adoptionRate; // Taprootè¾“å‡ºå æ¯”
        long totalTaprootOutputs;
        long totalOutputs;

        public AdoptionData(LocalDate date, double rate,
                long taprootOutputs, long totalOutputs) {
            this.date = date;
            this.adoptionRate = rate;
            this.totalTaprootOutputs = taprootOutputs;
            this.totalOutputs = totalOutputs;
        }
    }

    /**
     * æ¨¡æ‹Ÿé‡‡ç”¨è¶‹åŠ¿
     */
    public static List<AdoptionData> getAdoptionTrend() {
        List<AdoptionData> data = new ArrayList<>();

        // 2021å¹´11æœˆæ¿€æ´»
        data.add(new AdoptionData(
            LocalDate.of(2021, 11, 1), 0.1, 10000, 10000000));

        // 2022å¹´
        data.add(new AdoptionData(
            LocalDate.of(2022, 6, 1), 2.5, 500000, 20000000));
        data.add(new AdoptionData(
            LocalDate.of(2022, 12, 1), 5.8, 1200000, 20700000));

        // 2023å¹´ (Ordinalsæ¨åŠ¨)
        data.add(new AdoptionData(
            LocalDate.of(2023, 6, 1), 12.3, 3000000, 24390000));
        data.add(new AdoptionData(
            LocalDate.of(2023, 12, 1), 18.7, 5600000, 29946000));

        // 2024å¹´
        data.add(new AdoptionData(
            LocalDate.of(2024, 6, 1), 25.4, 8900000, 35039000));

        return data;
    }

    /**
     * æ˜¾ç¤ºé‡‡ç”¨ç»Ÿè®¡
     */
    public static void displayStats() {
        System.out.println("=== Taprooté‡‡ç”¨æƒ…å†µ ===\n");

        List<AdoptionData> trend = getAdoptionTrend();

        System.out.println("æ—¶é—´çº¿:");
        System.out.println("----------------------------------------");
        System.out.printf("%-15s | %-12s | %-15s%n",
            "æ—¥æœŸ", "é‡‡ç”¨ç‡", "Taprootè¾“å‡ºæ•°");
        System.out.println("----------------------------------------");

        for (AdoptionData data : trend) {
            System.out.printf("%-15s | %6.2f%%     | %,15d%n",
                data.date.toString(),
                data.adoptionRate,
                data.totalTaprootOutputs);
        }

        System.out.println("----------------------------------------\n");

        // ä¸»è¦é‡Œç¨‹ç¢‘
        System.out.println("ğŸ“Š ä¸»è¦é‡Œç¨‹ç¢‘:");
        System.out.println("â€¢ 2021-11-14: Taprootæ¿€æ´» (åŒºå—é«˜åº¦ 709,632)");
        System.out.println("â€¢ 2022-01: ä¸»è¦é’±åŒ…å¼€å§‹æ”¯æŒ(Sparrow, BlueWallet)");
        System.out.println("â€¢ 2023-01: Ordinalsåè®®æ¨åŠ¨Taprootä½¿ç”¨");
        System.out.println("â€¢ 2023-06: é‡‡ç”¨ç‡çªç ´10%");
        System.out.println("â€¢ 2024: Lightning Networkå¤§è§„æ¨¡é‡‡ç”¨Taprooté€šé“");
        System.out.println();

        // æ”¯æŒçš„é’±åŒ…
        System.out.println("ğŸ’¼ æ”¯æŒTaprootçš„ä¸»æµé’±åŒ…:");
        System.out.println("â€¢ Bitcoin Core 22.0+");
        System.out.println("â€¢ Sparrow Wallet");
        System.out.println("â€¢ BlueWallet");
        System.out.println("â€¢ Ledger (å›ºä»¶æ›´æ–°)");
        System.out.println("â€¢ Trezor Model T");
        System.out.println("â€¢ Electrum 4.1.0+");
        System.out.println();

        // ä¸»è¦åº”ç”¨åœºæ™¯
        System.out.println("ğŸ¯ ä¸»è¦åº”ç”¨åœºæ™¯:");
        System.out.println("1. Lightning Networké€šé“");
        System.out.println("2. éšç§å¤šç­¾é’±åŒ…");
        System.out.println("3. Ordinalsé“­æ–‡");
        System.out.println("4. DLC (Discreet Log Contracts)");
        System.out.println("5. ä¼ä¸šé‡‘åº“");
    }

    public static void main(String[] args) {
        displayStats();
    }
}
```

## 7. Taprootæœ€ä½³å®è·µ

### 7.1 ä½•æ—¶ä½¿ç”¨Taproot

```java
/**
 * Taprootä½¿ç”¨å†³ç­–æ ‘
 */
public class TaprootBestPractices {

    public enum OutputType {
        P2PKH,      // Legacy
        P2WPKH,     // Native SegWit
        P2TR        // Taproot
    }

    /**
     * æ¨èè¾“å‡ºç±»å‹
     */
    public static OutputType recommendOutputType(UseCase useCase) {
        switch (useCase) {
            case SINGLE_SIG_PAYMENT:
                // å•ç­¾å: P2TRå’ŒP2WPKHæ•ˆç‡ç›¸å½“,æ¨èP2TR
                return OutputType.P2TR;

            case MULTI_SIG_WALLET:
                // å¤šç­¾: P2TRæ˜¾è‘—ä¼˜äºP2WSH
                return OutputType.P2TR;

            case COMPLEX_SCRIPT:
                // å¤æ‚è„šæœ¬: P2TRæä¾›MASTä¼˜åŒ–
                return OutputType.P2TR;

            case TIME_LOCKED_RECOVERY:
                // æ—¶é—´é”: P2TRæ”¯æŒå¤šè·¯å¾„
                return OutputType.P2TR;

            case LIGHTNING_CHANNEL:
                // é—ªç”µé€šé“: P2TRé™ä½æ‰‹ç»­è´¹
                return OutputType.P2TR;

            case LEGACY_COMPATIBILITY:
                // éœ€è¦å…¼å®¹æ—§é’±åŒ…
                return OutputType.P2PKH;

            default:
                return OutputType.P2TR; // é»˜è®¤æ¨è
        }
    }

    public enum UseCase {
        SINGLE_SIG_PAYMENT,
        MULTI_SIG_WALLET,
        COMPLEX_SCRIPT,
        TIME_LOCKED_RECOVERY,
        LIGHTNING_CHANNEL,
        LEGACY_COMPATIBILITY
    }

    /**
     * å®‰å…¨æ£€æŸ¥æ¸…å•
     */
    public static void securityChecklist() {
        System.out.println("=== Taprootå®‰å…¨æ£€æŸ¥æ¸…å• ===\n");

        System.out.println("âœ… å¯†é’¥ç®¡ç†:");
        System.out.println("  â–¡ ä½¿ç”¨BIP32æ´¾ç”Ÿå¯†é’¥");
        System.out.println("  â–¡ å†…éƒ¨ç§é’¥å®‰å…¨å­˜å‚¨");
        System.out.println("  â–¡ Tweakå€¼æ­£ç¡®è®¡ç®—");
        System.out.println("  â–¡ å¤‡ä»½åŒ…å«MASTæ ‘ä¿¡æ¯");
        System.out.println();

        System.out.println("âœ… è„šæœ¬è®¾è®¡:");
        System.out.println("  â–¡ å¸¸ç”¨è·¯å¾„ä½œä¸ºKey Path");
        System.out.println("  â–¡ è„šæœ¬åˆ†æ”¯æŒ‰ä½¿ç”¨é¢‘ç‡æ’åº");
        System.out.println("  â–¡ åŒ…å«æ¢å¤è·¯å¾„");
        System.out.println("  â–¡ é¿å…è¿‡æ·±çš„Merkleæ ‘");
        System.out.println();

        System.out.println("âœ… äº¤æ˜“æ„å»º:");
        System.out.println("  â–¡ æ­£ç¡®è®¡ç®—ç­¾åå“ˆå¸Œ");
        System.out.println("  â–¡ ä½¿ç”¨æ­£ç¡®çš„ç­¾åå“ˆå¸Œç±»å‹");
        System.out.println("  â–¡ Witnessæ ˆé¡ºåºæ­£ç¡®");
        System.out.println("  â–¡ æ§åˆ¶å—æ ¼å¼æ­£ç¡®");
        System.out.println();

        System.out.println("âœ… æµ‹è¯•:");
        System.out.println("  â–¡ åœ¨Testnetæµ‹è¯•");
        System.out.println("  â–¡ æµ‹è¯•æ‰€æœ‰è„šæœ¬è·¯å¾„");
        System.out.println("  â–¡ éªŒè¯æ‰‹ç»­è´¹è®¡ç®—");
        System.out.println("  â–¡ æ£€æŸ¥é’±åŒ…å…¼å®¹æ€§");
    }

    /**
     * æ€§èƒ½ä¼˜åŒ–å»ºè®®
     */
    public static void performanceOptimization() {
        System.out.println("\n=== Taprootæ€§èƒ½ä¼˜åŒ– ===\n");

        System.out.println("ğŸ“ˆ é™ä½æ‰‹ç»­è´¹:");
        System.out.println("1. ä¼˜å…ˆä½¿ç”¨Key Path (æœ€å°witness)");
        System.out.println("2. å¸¸ç”¨è„šæœ¬æ”¾åœ¨æµ…å±‚");
        System.out.println("3. æ‰¹é‡ç­¾åä½¿ç”¨MuSigèšåˆ");
        System.out.println("4. é¿å…ä¸å¿…è¦çš„è„šæœ¬åˆ†æ”¯");
        System.out.println();

        System.out.println("âš¡ æå‡éšç§:");
        System.out.println("1. Key Pathæ”¯å‡ºçœ‹èµ·æ¥åƒå•ç­¾å");
        System.out.println("2. ä¸åŒè„šæœ¬ç±»å‹è¾“å‡ºä¸å¯åŒºåˆ†");
        System.out.println("3. æœªä½¿ç”¨åˆ†æ”¯ä¸æš´éœ²");
        System.out.println("4. æ”¯æŒCoinJoinç­‰éšç§æŠ€æœ¯");
        System.out.println();

        System.out.println("ğŸ”§ å¼€å‘æŠ€å·§:");
        System.out.println("1. ä½¿ç”¨Bitcoin Core 23.0+ RPC");
        System.out.println("2. å‚è€ƒBIP340/341/342å®ç°");
        System.out.println("3. ä½¿ç”¨ç°æœ‰åº“(libsecp256k1-zkp)");
        System.out.println("4. ä¿æŒè„šæœ¬ç®€æ´æ˜äº†");
    }

    public static void main(String[] args) {
        System.out.println("=== Taprootæœ€ä½³å®è·µ ===\n");

        // ä½¿ç”¨åœºæ™¯æ¨è
        System.out.println("ğŸ’¡ ä½¿ç”¨åœºæ™¯æ¨è:\n");
        for (UseCase useCase : UseCase.values()) {
            OutputType recommended = recommendOutputType(useCase);
            System.out.printf("%-25s â†’ %s%n",
                useCase.name().replace("_", " "),
                recommended);
        }
        System.out.println();

        securityChecklist();
        performanceOptimization();
    }
}
```

## 8. ç›¸å…³æ–‡æ¡£

- [09.æ¯”ç‰¹å¸è„šæœ¬è¯­è¨€è¯¦è§£.md](./09.æ¯”ç‰¹å¸è„šæœ¬è¯­è¨€è¯¦è§£.md) - ScriptåŸºç¡€
- [27.æ¯”ç‰¹å¸å¤šç­¾é’±åŒ…å¼€å‘.md](./27.æ¯”ç‰¹å¸å¤šç­¾é’±åŒ…å¼€å‘.md) - å¤šç­¾åº”ç”¨
- [19.æ¯”ç‰¹å¸éšç§æŠ€æœ¯.md](./19.æ¯”ç‰¹å¸éšç§æŠ€æœ¯.md) - éšç§æ”¹è¿›
- [08.é—ªç”µç½‘ç»œåŸç†è¯¦è§£.md](./08.é—ªç”µç½‘ç»œåŸç†è¯¦è§£.md) - Lightningåº”ç”¨

## 9. å‚è€ƒèµ„æ–™

- [BIP 340: Schnorr Signatures](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)
- [BIP 341: Taproot](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)
- [BIP 342: Tapscript](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki)
- [Bitcoin Core Taprootæ”¯æŒ](https://bitcoincore.org/en/2021/09/23/release-22.0/)