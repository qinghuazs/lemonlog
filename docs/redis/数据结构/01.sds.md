---
title: Redis SDS (Simple Dynamic String) 详解
date: 2023-08-22 10:00:00
tags:
- Redis
categories:
- Redis
---

## 1. 概述

Redis 的 SDS（Simple Dynamic String，简单动态字符串）是 Redis 中用于替代 C 原生字符串的核心数据结构。它解决了传统 C 字符串的诸多缺陷（如无法直接获取长度、缓冲区溢出风险、频繁内存分配等），并提供了高效的字符串操作。

## 2. 数据结构设计

### 2.1 基本结构

```c
struct sdshdr {
    long len;      // 字符串长度
    long free;     // 剩余可用空间
    char buf[];    // 字符串缓冲区
};

typedef char *sds;  // SDS类型定义
```

### 2.2 内存布局图

```
┌─────────────────────────────────────────────────────────────────┐
│                        SDS 内存布局                              │
├─────────────┬─────────────┬─────────────────────────────────────┤
│    len      │    free     │              buf[]                  │
│   (8字节)    │   (8字节)    │           (len+free+1字节)           │
├─────────────┼─────────────┼─────────────────────────────────────┤
│    实际      │   剩余       │    字符串内容 + '\0'                 │
│   字符串     │   可用       │                                     │
│    长度      │   空间       │                                     │
└─────────────┴─────────────┴─────────────────────────────────────┘

示例：存储字符串 "hello"
┌─────────────┬─────────────┬─────────────────────────────────────┐
│      5      │      0      │    h  e  l  l  o  \0                │
└─────────────┴─────────────┴─────────────────────────────────────┘
```

### 2.3 多版本SDS结构

Redis 3.2之后引入了多种SDS类型以优化内存使用：

```
┌──────────────────────────────────────────────────────────────────┐
│                     SDS 类型对比                                  │
├──────────┬──────────┬──────────┬──────────┬──────────┬──────────┤
│   类型    │  sdshdr5 │ sdshdr8  │ sdshdr16 │ sdshdr32 │ sdshdr64 │
├──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│  flags   │   1字节   │   1字节   │   1字节   │   1字节   │   1字节   │
├──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│   len    │    无     │   1字节   │   2字节   │   4字节   │   8字节   │
├──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│  alloc   │    无     │   1字节   │   2字节   │   4字节   │   8字节   │
├──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│   buf    │   字符串   │   字符串   │   字符串   │   字符串   │   字符串   │
├──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│ 最大长度  │    31     │   255    │  65535   │   2^32   │   2^64   │
└──────────┴──────────┴──────────┴──────────┴──────────┴──────────┘
```

## len（长度字段）
- 作用 ：记录当前字符串的实际长度（不包括结尾的'\0'字符）
- 优势 ：
  - 获取字符串长度的时间复杂度为O(1)，而C字符串需要O(n)
  - 避免了遍历整个字符串来计算长度
  - 支持二进制安全，可以存储包含'\0'字符的数据
- 示例 ：字符串"hello"的len值为5

## alloc（分配空间字段）
- 作用 ：记录为buf数组分配的总空间大小（不包括结尾的'\0'字符）
- 优势 ：
  - 实现空间预分配策略，减少内存重新分配次数
  - 支持惰性空间释放，提高性能
  - 通过alloc-len可以快速计算剩余可用空间
- 示例 ：如果alloc=10，len=5，则还有5字节的空闲空间

## flags（标志字段）
- 作用 ：标识SDS的类型和一些状态信息
- 功能 ：
  - 低3位用于标识SDS类型（sdshdr5/8/16/32/64）
  - 高5位在sdshdr5中用于存储字符串长度（因为sdshdr5没有独立的len字段）
  - 帮助Redis根据字符串长度选择最合适的SDS类型
- 示例 ：flags=1表示sdshdr8类型

## buf（字符数组字段）
- 作用 ：实际存储字符串内容的字节数组
- 特点 ：
  - 以'\0'结尾，保持与C字符串的兼容性
  - 支持二进制安全，可以存储任意二进制数据
  - 大小由alloc字段决定
- 示例 ：存储"hello\0"，实际占用6字节


## 3. 源码解析

### 3.1 创建SDS

```c
sds sdsnewlen(const void *init, size_t initlen) {
    struct sdshdr *sh;

    // 分配内存：头部 + 字符串长度 + 1(null终止符)
    sh = zmalloc(sizeof(struct sdshdr) + initlen + 1);
    
    // 内存分配失败处理
#ifdef SDS_ABORT_ON_OOM
    if (sh == NULL) sdsOomAbort();
#else
    if (sh == NULL) return NULL;
#endif
    
    // 初始化头部信息
    sh->len = initlen;          // 设置字符串长度
    sh->free = 0;               // 初始无剩余空间
    
    // 复制初始数据
    if (initlen) {
        if (init) 
            memcpy(sh->buf, init, initlen);  // 复制数据
        else 
            memset(sh->buf, 0, initlen);     // 清零
    }
    
    sh->buf[initlen] = '\0';    // null终止符
    return (char*)sh->buf;      // 返回字符串指针
}
```

### 3.2 获取SDS长度

```c
size_t sdslen(const sds s) {
    // 通过指针偏移获取头部结构
    struct sdshdr *sh = (void*)(s - sizeof(struct sdshdr));
    return sh->len;  // 直接返回长度，O(1)时间复杂度
}
```

### 3.3 SDS扩容机制

```c
sds sdsMakeRoomFor(sds s, size_t addlen) {
    struct sdshdr *sh, *newsh;
    size_t free = sdsavail(s);  // 获取可用空间
    size_t len, newlen;

    // 如果剩余空间足够，直接返回
    if (free >= addlen) return s;

    len = sdslen(s);
    sh = (void*) (s - sizeof(struct sdshdr));
    newlen = (len + addlen);
    
    // 扩容策略：
    // 1. 如果新长度小于1MB，扩容为2倍
    // 2. 如果新长度大于1MB，每次增加1MB
    if (newlen < SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        newlen += SDS_MAX_PREALLOC;

    // 重新分配内存
    newsh = zrealloc(sh, sizeof(struct sdshdr) + newlen + 1);
    if (newsh == NULL) return NULL;

    // 更新free字段
    newsh->free = newlen - len;
    return newsh->buf;
}
```

## 4. SDS的优势

### 4.1 与C字符串对比

| 特性 | C字符串 | SDS |
|------|---------|-----|
| 获取长度 | O(n) | O(1) |
| 缓冲区溢出 | 不安全 | 安全 |
| 内存重分配 | 频繁 | 减少 |
| 二进制安全 | 否 | 是 |
| 兼容性 | - | 兼容C字符串函数 |

### 4.2 核心优势

1. **常数时间复杂度获取字符串长度**
   - C字符串需要遍历整个字符串
   - SDS直接读取len字段

2. **杜绝缓冲区溢出**
   - 修改前检查空间是否足够
   - 自动扩容机制

3. **减少内存重分配次数**
   - 空间预分配策略
   - 惰性空间释放

4. **二进制安全**
   - 不依赖'\0'判断字符串结束
   - 可以存储任意二进制数据

## 5. 应用场景

### 5.1 Redis中的使用

- **键值存储**：所有Redis键都是SDS
- **字符串值**：SET/GET操作的值
- **缓冲区**：客户端输入缓冲区、AOF缓冲区
- **内部数据**：错误信息、日志等

### 5.2 操作示例

```redis
# 基本字符串操作
SET name "Redis"
GET name

# 追加操作（利用SDS扩容机制）
APPEND name " Database"

# 获取长度（O(1)操作）
STRLEN name

# 二进制安全存储
SET binary "\x00\x01\x02"
```

## 6. 面试题目与解答

### 6.1 基础概念题

**Q1: 什么是SDS？它解决了什么问题？**

**A1:** SDS（Simple Dynamic String）是Redis实现的动态字符串结构。它解决了C字符串的几个问题：
- 获取长度需要O(n)时间复杂度
- 容易发生缓冲区溢出
- 频繁的内存重分配
- 不能存储二进制数据

**Q2: SDS的内存布局是怎样的？**

**A2:** SDS由三部分组成：
- `len`：记录字符串长度（8字节）
- `free`：记录剩余可用空间（8字节）
- `buf[]`：存储字符串内容的字符数组

### 6.2 实现原理题

**Q3: SDS如何实现O(1)时间复杂度获取字符串长度？**

**A3:** SDS在头部结构中维护了`len`字段，直接记录字符串长度。获取长度时只需要读取这个字段，而不需要遍历整个字符串。

```c
size_t sdslen(const sds s) {
    struct sdshdr *sh = (void*)(s - sizeof(struct sdshdr));
    return sh->len;  // 直接返回，O(1)
}
```

**Q4: SDS的扩容策略是什么？为什么这样设计？**

**A4:** SDS采用分级扩容策略：
- 新长度 < 1MB：扩容为2倍
- 新长度 ≥ 1MB：每次增加1MB

这样设计的原因：
- 小字符串：2倍扩容减少重分配次数
- 大字符串：避免过度浪费内存

### 6.3 应用场景题

**Q5: 为什么Redis选择SDS而不是C字符串？**

**A5:** 主要原因：
1. **性能**：O(1)获取长度，减少内存重分配
2. **安全**：避免缓冲区溢出
3. **功能**：支持二进制数据存储
4. **兼容性**：仍可使用C字符串函数

**Q6: SDS在Redis的哪些地方被使用？**

**A6:** SDS在Redis中广泛使用：
- 所有的键（key）
- 字符串类型的值（value）
- 客户端输入/输出缓冲区
- AOF缓冲区
- 错误信息和日志

### 6.4 优化相关题

**Q7: Redis 3.2后对SDS做了什么优化？**

**A7:** 引入了多种SDS类型（sdshdr5/8/16/32/64），根据字符串长度选择合适的头部大小：
- 减少内存占用
- 提高缓存局部性
- 针对不同长度字符串优化

**Q8: SDS的空间预分配和惰性释放是如何工作的？**

**A8:** 
- **空间预分配**：扩容时分配额外空间，减少后续扩容次数
- **惰性释放**：缩短字符串时不立即释放内存，而是记录在free字段中，供后续使用

### 6.5 实战应用题

**Q9: 如何利用SDS的特性优化字符串操作？**

**A9:** 
1. **批量操作**：利用预分配空间进行多次APPEND
2. **长度检查**：使用STRLEN命令（O(1)）而非遍历
3. **二进制存储**：存储序列化对象、图片等二进制数据

**Q10: 在什么场景下SDS的优势最明显？**

**A10:** 
1. **频繁的字符串修改**：append、trim等操作
2. **需要频繁获取长度**：统计、分页等场景
3. **二进制数据存储**：图片、音频等文件
4. **大量小字符串**：缓存场景中的键值对

## 7. 总结

SDS是Redis中一个精心设计的数据结构，它在保持与C字符串兼容性的同时，解决了传统C字符串的诸多问题。通过空间换时间的策略，SDS实现了高性能的字符串操作，是Redis高性能的重要基础之一。

理解SDS的设计思想和实现原理，不仅有助于更好地使用Redis，也为我们设计高性能的数据结构提供了很好的参考。